<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hny" href="http://hening25.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hny" href="http://hening25.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="Hny" href="http://hening25.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="java,git,cas"><link rel="canonical" href="http://hening25.gitee.io/2025/08/15/2025-08-15-Leetcode/"><title>Leetcode刷题记录 - 技能工具 | Hening = Hny = 终有弱水替沧海 再无相思寄巫山</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Leetcode刷题记录</h1><div class="meta"><span class="item" title="创建时间：2025-08-15 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-08-15T00:00:00+08:00">2025-08-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>15k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hening</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/ca90e642a3afabae3b1ef15332a097dc.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/a94c1ab5035dabcbb45959e3e8c2ce8d.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/befe95e11d78ada4fa98995e4a103519.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/6eb83263fe4ffd97749f97063037fe45.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/01ab3882e15260d90629328d9bb15779.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/142d2ce10548c990a335b356aaff4ed5.jpeg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E6%8A%80%E8%83%BD%E5%B7%A5%E5%85%B7/" itemprop="item" rel="index" title="分类于 技能工具"><span itemprop="name">技能工具</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://hening25.gitee.io/2025/08/15/2025-08-15-Leetcode/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Hening"><meta itemprop="description" content="终有弱水替沧海 再无相思寄巫山, 终有弱水替沧海 再无相思寄巫山"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hny"></span><div class="body md" itemprop="articleBody"><p>Leetcode刷题记录</p><span id="more"></span><h1 id="Leetcode刷题"><a href="#Leetcode刷题" class="headerlink" title="Leetcode刷题"></a>Leetcode刷题</h1><h2 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组&#x2F;字符串"></a>数组&#x2F;字符串</h2><h3 id="1071-字符串的最大公因子"><a href="#1071-字符串的最大公因子" class="headerlink" title="1071. 字符串的最大公因子"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmVhdGVzdC1jb21tb24tZGl2aXNvci1vZi1zdHJpbmdzLw==">1071. 字符串的最大公因子</span></h3><p>对于字符串 <code>s</code> 和 <code>t</code>，只有在 <code>s = t + t + t + ... + t + t</code>（<code>t</code> 自身连接 1 次或多次）时，我们才认定 “<code>t</code> 能除尽 <code>s</code>”。</p><p>给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回 <em>最长字符串 <code>x</code>，要求满足 <code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p><p>:::info no-icon</p><p>若两个字符串是由同一个字符串 X重复拼接而成，那么无论先拼哪个，结果应该相同。<br>如果 str1 + str2 !&#x3D; str2 +str1，说明不存在公共的重复因子，直接返回空串 “”。<br>如果两个字符串都是由同一个字符串 X 组成，那么 X 的长度必然是str1.size()和 str2.size() 的最大公约数。</p><p>作者：Random<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmVhdGVzdC1jb21tb24tZGl2aXNvci1vZi1zdHJpbmdzL3NvbHV0aW9ucy8zNzQ5ODkxL3NodS14dWUtenVpLWRhLWdvbmcteXVlLXNodS1ieS1jb2Rlci1yYW4tYTg4dS8=">https://leetcode.cn/problems/greatest-common-divisor-of-strings/solutions/3749891/shu-xue-zui-da-gong-yue-shu-by-coder-ran-a88u/</span></p><p>:::</p><pre><code class="language-python">class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -&gt; str:
        if not str1 + str2 == str2 + str1:
            return &quot;&quot;
        return str1[0:self.gcd(len(str1), len(str2))]
    
    def gcd(self, a,b):
        if b == 0: return a
        else: return gcd(b, a%b)
    
</code></pre><h3 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tcGxhY2UtZmxvd2Vycy8=">605. 种花问题</span></h3><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p><p>:::info no-icon</p><p>从左到右遍历数组，能种花就立刻种花。</p><p>如何判断能否种花？由于「花不能种植在相邻的地块上」，如果要在下标 i 处种花，需要满足 flowerbed[i−1],flowerbed[i],flowerbed[i+1] 均为 0。</p><p>每种一朵花，就把 n 减一。如果最后 n≤0，则返回 true，否则返回 false。</p><p>为了简化判断逻辑，可以在数组的开头和末尾各插入一个 0。</p><p>作者：灵茶山艾府<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tcGxhY2UtZmxvd2Vycy9zb2x1dGlvbnMvMjQ2MzAxOC9iZW4tdGktenVpLWppYW4tZGFuLXhpZS1mYS1weXRob25qYXZhY2dvLTZhNmsv">https://leetcode.cn/problems/can-place-flowers/solutions/2463018/ben-ti-zui-jian-dan-xie-fa-pythonjavacgo-6a6k/</span></p><p>:::</p><pre><code class="language-python">class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -&gt; bool:
      nums = len(flowerbed)
      new_flowerbed = [0] + flowerbed + [0]
      for i in range(1,len(new_flowerbed)-1):
        if new_flowerbed[i-1] == 0 and new_flowerbed[i+1] == 0 and new_flowerbed[i] == 0:
          new_flowerbed[i] = 1
          n -= 1
      return n &lt;= 0
</code></pre><h3 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbmNyZWFzaW5nLXRyaXBsZXQtc3Vic2VxdWVuY2Uv">334. 递增的三元子序列</span></h3><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p><p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>:::info no-icon</p><p>;;;id1 巧解</p><p>核心想法：遍历一遍数组，希望遍历到的这个数three，前面已经有一个比他小的数two，再前面有一个比two小的数one。<br>我们需要维护两个变量：one和two。代表递增子序列的第一个数和第二个数。<br>假设我们已经有了这两个数，那么three的大小有以下三种情况：</p><ol><li><p><strong>three大于two</strong> 此情况下：即找到了三元组，直接返回true。</p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-01.png" width="300"></li><li><p><strong>three介于two和one之间</strong> 此情况下：应更新two，赋值为这个更小的值。这相当于帮我们扩大了three的可选择范围，当再次遇到一个比更新过的two大的数即可找到。</p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-02.png" width="300"> <img data-src="/2025/08/15/2025-08-15-Leetcode/334-03.png" width="300"></li><li><p><strong>three小于one</strong> 此情况下：应更新one，赋值为这个更小的值。而不需要动two。这相当于帮我们扩大了之后出现的two的可选择范围。进而扩大了之后出现的three的可选择范围。</p></li></ol><img data-src="/2025/08/15/2025-08-15-Leetcode/334-04.png" width="300"> <img data-src="/2025/08/15/2025-08-15-Leetcode/334-05.png" width="300"> <img data-src="/2025/08/15/2025-08-15-Leetcode/334-06.png" width="300"><p>需要注意的是，我们只更新one，原先的two不需要更改，因为子序列是从前往后的，只有当之后再出现比two小的数的时候再按照第二步那样更改。</p><p>假设有如下示例：[2,5,1,6]，在遇到1之后更新了one，后遇到6，因为先判断是否大于two，由于6大于5，就直接返回true了。</p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-07.png" width="300"><p>注意：two附带隐含信息——这之前有个数比two小<br>所以此时找到的递增子序列不是one、two、three的1 5 6，而是old one、two、three的2 5 6。</p><p>这里更新的one的意思是，为之后可能存在的更小的递增子序列打基础。<br>假设有如下示例：[2,5,1,2,6]，在遇到1之后更新了one，后遇到2，2介于1和5（two）之间，更新two为2，后遇到6，由于6大于2，返回true。<br>此时找到的递增子序列才是one、two、three的1 2 6</p><p>最后考虑one、two的初值，容易想到设定为Integer.MAX_VALUE即可。</p><p>作者：Xzz<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbmNyZWFzaW5nLXRyaXBsZXQtc3Vic2VxdWVuY2Uvc29sdXRpb25zLzUzNTcyNS9wb3UteGktYmVuLXpoaS15aS13ZW4tYmFuZy1uaS1rYW4tcWluZy10LTN5ZTIv">https://leetcode.cn/problems/increasing-triplet-subsequence/solutions/535725/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/</span></p><pre><code class="language-python">class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
      one, two = inf, inf
      for three in nums:
        if three &gt; two : return True
        elif three &lt;= one: one = three
        else: two = three
      return False
</code></pre><p>+++info 解析（GPT）</p><p><strong>1. 递增三元组的性质</strong></p><p>假设数组中存在递增三元组 <code>a &lt; b &lt; c</code>，它们的顺序在数组中是 <strong>前后顺序</strong>，我们只关心：</p><ul><li>第一个数最小</li><li>第二个数比第一个数大</li><li>第三个数比第二个数大</li></ul><p><strong>关键点</strong>：我们不需要知道三元组具体位置，只需要保证存在。</p><p><strong>2. one 和 two 的作用</strong></p><ul><li><code>one</code>：当前找到的<strong>最小的候选第一个数</strong></li><li><code>two</code>：在 <code>one</code> 之后，找到的<strong>最小的候选第二个数</strong></li></ul><p><strong>核心思想</strong>：</p><ul><li>我们并不是在找数组中所有可能的三元组，而是在<strong>维护最优候选序列</strong>。</li><li>“最优候选”意味着 <strong>尽可能小的 one 和 two</strong>，这样可以最大化出现第三个数 three 的机会。</li></ul><p>换句话说：</p><ol><li>遍历到一个数 three：<ul><li>如果 three &gt; two → 说明找到了一个合法三元组（不管前面 one&#x2F;two 是不是更新过的，都会形成合法的递增序列）。</li></ul></li><li>如果 three &lt;&#x3D; one → 更新 one<ul><li>因为这个更小的 one 可以为之后出现的 two 提供更多可能。</li></ul></li><li>否则 → 更新 two<ul><li>因为这个更小的 two 可以为之后出现的 three 提供更多可能。</li></ul></li></ol><p><strong>3. 为什么不会漏掉任何情况</strong></p><p>假设数组中有递增三元组 <code>x &lt; y &lt; z</code>，为什么算法一定能找到它？</p><ul><li>当我们遍历到 x：<ul><li>one 会被更新为 ≤ x</li></ul></li><li>当我们遍历到 y：<ul><li>two 会被更新为 ≤ y</li></ul></li><li>当我们遍历到 z：<ul><li>如果 z &gt; two → 返回 True</li></ul></li></ul><p><strong>关键点</strong>：</p><ul><li>即使 one&#x2F;two 被后面更小的数更新过，<strong>old one&#x2F;two 仍然保留了前序信息</strong>，保证当前 three 大于某个二元组时，必然能形成递增三元组。</li><li>换句话说，one&#x2F;two 是动态维护的 <strong>最小可能序列候选</strong>，任何真正存在的递增三元组都会被捕获。</li></ul><p>+++</p><p>;;;</p><p>;;;id1 常规</p><p>常规解法</p><p>;;;</p><p>:::</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="1208-尽可能使字符串相等"><a href="#1208-尽可能使字符串相等" class="headerlink" title="1208. 尽可能使字符串相等"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZXQtZXF1YWwtc3Vic3RyaW5ncy13aXRoaW4tYnVkZ2V0Lw==">1208. 尽可能使字符串相等</span></h3><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p><p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p><p>+++info 示例</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3
输出：3
解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0
输出：1
解释：a -&gt; a, cost = 0，字符串未发生变化，所以最大长度为 1。
</code></pre><p>+++</p><p>:::info no-icon</p><p>两个长度相等字符串的 s 和 t ，把 i 位置的 s[i] 转成 t[i] 的开销是两者 ASCII 码之差的绝对值。题目给出了允许的最大预算 maxCost ，求不超过预算的情况下能够转换的最长子串。</p><p>比如，对于 s &#x3D; “abcd”, t &#x3D; “bcdf”, cost &#x3D; 3 而言，我们使用 costs[i] 表示从 s[i] 转成 t[i] 的开销，那么 costs &#x3D; [1, 1, 1, 2] 。由于 maxCost &#x3D; 3， 所以最多允许其前面三个字符进行转换。</p><p>于是题目变成了：<strong>已知一个数组 costs ，求：和不超过 maxCost 时最长的子数组的长度</strong>。</p><img data-src="/2025/08/15/2025-08-15-Leetcode/1208-01.png" width="300"><pre><code class="language-python">class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -&gt; int:
        n = len(s)
        left, right = 0, 0
        result = 0
        cost = 0
        while right &lt; n:
            cost += abs(ord(s[right]) - ord(t[right]))
            while cost &gt; maxCost:
                cost -= abs(ord(s[left]) - ord(t[left]))
                left += 1
                
            result = max(result, right - left + 1)
            right += 1
        return result
</code></pre><p>《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。</p><p>+++info 滑动窗口问题模板</p><p>我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXgtY29uc2VjdXRpdmUtb25lcy1paWkv">1004. 最大连续1的个数 III</span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQv">424. 替换后的最长重复字符</span>）：</p><pre><code class="language-python">def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right &lt; N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
</code></pre><p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p><p>模板的整体思想是：</p><p>定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；<br>第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和&#x2F;计数；<br>第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和&#x2F;计数；<br>在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。<br>right 指针每次向右移动一步，开始探索新的区间。<br>模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。</p><p>另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间[left, right]不符合题意 。对于本题而言，就是该区内的和 sums 超过了 maxCost 。</p><p>+++</p><p>作者：负雪明烛<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZXQtZXF1YWwtc3Vic3RyaW5ncy13aXRoaW4tYnVkZ2V0L3NvbHV0aW9ucy81OTIzNTQvZmVuLXhpYW5nLXpoZW4tY2FuZy1kZS1odWEtZG9uZy1jaHVhbmctay1lM3JkLw==">https://leetcode.cn/problems/get-equal-substrings-within-budget/solutions/592354/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/</span><br>:::</p><h3 id="424-替换后的最长重复字符"><a href="#424-替换后的最长重复字符" class="headerlink" title="424. 替换后的最长重复字符"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQv">424. 替换后的最长重复字符</span></h3><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p><p>在执行上述操作后，返回 <em>包含相同字母的最长子字符串的长度。</em></p><p>+++info 示例</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;ABAB&quot;, k = 2
输出：4
解释：用两个&#39;A&#39;替换为两个&#39;B&#39;,反之亦然。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;AABABBA&quot;, k = 1
输出：4
解释：
将中间的一个&#39;A&#39;替换为&#39;B&#39;,字符串变为 &quot;AABBBBA&quot;。
子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。
可能存在其他的方法来得到同样的结果。
</code></pre><p>+++</p><p>:::info no-icon</p><p>本题解根据常规的滑动窗口思路进行解题，不需要任何的技巧。<br>滑动窗口法是指通过Left以及Right指针来框定一个窗口，当在窗口内的字符串满足题目要求则记录下当前窗口长度并进一步扩张寻找更长的窗口，若不满足则进行窗口平移。<br>题目中给定的K值是让我们在选定有效窗口时的要求放宽了：</p><p>当K&#x3D;0时，要求滑动窗口内部的所有字母都必须相同；<br>而当K&gt;0时，要求滑动窗口内最多替换K次使得所有字母都必须相同。这里有一个关键点，即我们将当前滑动窗口内出现次数最多的字母作为基准字母（Benchmark），那么其他不一样的字母(Others)都选择替换操作即可以最小的代价转换为全部相同的字母。<br>因此，我们首先通过一个数组(count)记录所有字母在当前窗口出现的次数，通过Max函数选择窗口内的基准字母，然后其他字母出现的次数为Sum(count)-Max(count)，通过与K进行比较，即可知道当前窗口是否有效，下一步是继续扩张还是位移。</p><p>作者：Derrick.S<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQvc29sdXRpb25zLzc5OTAxMy9odWEtZG9uZy1jaHVhbmcta291LWZhLWppYW4tZGFuLXlpLWRvbmctM3F3ZWwv">https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/799013/hua-dong-chuang-kou-fa-jian-dan-yi-dong-3qwel/</span></p><pre><code class="language-python">class Solution:
    def characterReplacement(self, s: str, k: int) -&gt; int:
        count = [0 for _ in range(26)]  #记录当前窗口的字母出现次数
        
        left = 0    #滑动窗口左边界
        right = 0   #滑动窗口右边界
        retval = 0  #最长窗口长度
        
        while right &lt; len(s):
            count[ord(s[right])-ord(&#39;A&#39;)] += 1  
            benchmark = max(count)              #选择出现次数最多的字母为基准 
            others = sum(count) - benchmark     #则其他字母需要通过替换操作来变为基准
            if others &lt;= k:                     #通过与K进行比较来判断窗口是进行扩张？
                right += 1
                retval = max(retval, right-left)#记录当前有效窗口长度
            else:                               #通过与K进行比较来判断窗口还是进行位移？
                count[ord(s[left])-ord(&#39;A&#39;)] -= 1
                left += 1
                right += 1                      #这里注意：位移操作需要整个向右移，不仅仅只是left向右
        
        return retval                           #返回最长窗口长度
        
</code></pre><p>:::</p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="724-寻找数组的中心下标"><a href="#724-寻找数组的中心下标" class="headerlink" title="724. 寻找数组的中心下标"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBpdm90LWluZGV4Lw==">724. 寻找数组的中心下标</span></h3><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><p>+++info 示例</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
</code></pre><p>+++</p><p>:::info no-icon</p><p>设 nums 的元素之和为 s。</p><p>设中心下标为 i，其左侧元素和为 $leftS&#x3D;nums[0]+nums[1]+⋯+nums[i−1]$，那么右侧元素和为 $s−nums[i]−leftS$。</p><p>由于左侧元素和等于右侧元素和，所以有</p><p>$$leftS&#x3D;s−nums[i]−leftS$$<br>即</p><p>$$2⋅leftS&#x3D;s−nums[i]$$<br>从左到右遍历数组，一边遍历，一边累加元素更新 leftS。每次累加前，检查是否满足上式，满足则返回 i。</p><p>如果不存在这样的 i，返回 −1。</p><p>作者：灵茶山艾府<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBpdm90LWluZGV4L3NvbHV0aW9ucy8yODM0Njg3L2ppYW4tamkteGllLWZhLW8xLWUtd2FpLWtvbmctamlhbi1weXRob24tdHowcC8=">https://leetcode.cn/problems/find-pivot-index/solutions/2834687/jian-ji-xie-fa-o1-e-wai-kong-jian-python-tz0p/</span></p><pre><code class="language-python">class Solution:
    def pivotIndex(self, nums: List[int]) -&gt; int:
        s = sum(nums)
        sum_left = 0
        for i, num in enumerate(nums):
            if 2*sum_left == s - num:
                return i
            sum_left += num
        return -1
</code></pre><p>:::</p><h3 id="2352-相等行列对"><a href="#2352-相等行列对" class="headerlink" title="2352. 相等行列对"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lcXVhbC1yb3ctYW5kLWNvbHVtbi1wYWlycy8=">2352. 相等行列对</span></h3><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code> 列相等的行列对 <code>(Ri, Cj)</code> 的数目*。*</p><p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p><p>::: info no-icon</p><p>用哈希表统计每行出现的次数，然后遍历列，累加哈希表中列出现的次数。</p><p>作者：灵茶山艾府<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lcXVhbC1yb3ctYW5kLWNvbHVtbi1wYWlycy9zb2x1dGlvbnMvMTY5NDA0Ny9oYS14aS1iaWFvLXB5dGhvbi1saWFuZy14aW5nLWJ5LWVuZGxlc3NjLWxqYWUv">https://leetcode.cn/problems/equal-row-and-column-pairs/solutions/1694047/ha-xi-biao-python-liang-xing-by-endlessc-ljae/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>;;;id2 Demo 1</p><pre><code class="language-python">class Solution:
    def equalPairs(self, grid: List[List[int]]) -&gt; int:
        cnt = Counter(tuple(row) for row in grid)
        return sum(cnt[col] for col in zip(*grid))
</code></pre><p>;;;</p><p>;;;id2 Demo2</p><pre><code class="language-python">class Solution:
    def equalPairs(self, grid: List[List[int]]) -&gt; int:
        n = len(grid)
        count = &#123;&#125;
        result = 0
        for i in range(n):
            count[tuple(grid[i])] = count.get(tuple(grid[i]), 0) + 1
        print(count)
        for j in zip(*grid):
            print(j)
            result += count.get(j,0)
            # print(grid[:][j], grid[j][:])
        return result
</code></pre><p>;;;</p><p>:::</p><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="735-小行星碰撞"><a href="#735-小行星碰撞" class="headerlink" title="735. 小行星碰撞"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3Rlcm9pZC1jb2xsaXNpb24v">735. 小行星碰撞</span></h3><p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。</p><p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p><p>找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。</p><p>+++info 示例</p><p><strong>示例 1：</strong></p><pre><code>输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：asteroids = [8,-8]
输出：[]
解释：8 和 -8 碰撞后，两者都发生爆炸。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：asteroids = [10,2,-5]
输出：[10]
解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。
</code></pre><p>+++</p><p>:::info no-icon</p><p>这道栈的题目难点应该主要是在分析场景上了。<br>我们需要明确什么时候无脑入栈，什么时候需要判断，理解这两点就可以轻松解题了。<br>首先，循环每一个元素时，在什么情况下无脑入栈呢？</p><p>栈为空<br>栈顶元素为负数(下一个为负数则一起向左，下一个为正数则分向两边)<br>当前元素为正数（栈顶为正一起向右，栈顶为负分向两边）<br>下来，我们需要看碰撞的场景又细分为什么情况：</p><p>栈顶元素大于abs(当前元素)，当前元素被撞毁<br>栈顶元素等于abs(当前元素)，栈顶弹出和当前元素抵消<br>栈顶元素小于abs(当前元素)，栈顶弹出，并与新栈顶完成上述判断<br>最终返回栈即可。</p><p>作者：清风Python<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3Rlcm9pZC1jb2xsaXNpb24vc29sdXRpb25zLzk5NDEwMC83MzV4aW5nLXhpbmctcGVuZy16aHVhbmctamkteXUtemhhbi1xdS1mLXhwZDEv">https://leetcode.cn/problems/asteroid-collision/solutions/994100/735xing-xing-peng-zhuang-ji-yu-zhan-qu-f-xpd1/</span></p><pre><code class="language-python">class Solution:
    def asteroidCollision(self, asteroids: List[int]) -&gt; List[int]:
        stack, index = [], 0
        while index &lt; len(asteroids):
            ast = asteroids[index]
            if ast &gt; 0 or len(stack)==0 or stack[-1]&lt;0: stack.append(ast)
            elif stack[-1] &lt;= - ast:
                if stack.pop(-1) &lt; - ast:
                    continue
            index += 1
        return stack
</code></pre><p>:::</p><h3 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nLw==">394. 字符串解码</span></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p>测试用例保证输出的长度不会超过 <code>105</code>。</p><p>+++info 示例</p><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;3[a]2[bc]&quot;
输出：&quot;aaabcbc&quot;
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;3[a2[c]]&quot;
输出：&quot;accaccacc&quot;
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;2[abc]3[cd]ef&quot;
输出：&quot;abcabccdcdcdef&quot;
</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：s = &quot;abc3[cd]xyz&quot;
输出：&quot;abccdcdcdxyz&quot;
</code></pre><p>+++</p><p>:::info no-icon</p><ul><li><p>本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。</p></li><li><p>算法流程：</p><ul><li><p>构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</p><ul><li><p>当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</p></li><li><p>当 c 为字母时，在 res 尾部添加 c；</p></li><li><p>当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：<br>记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；<br>记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × […] 字符串。<br>进入到新 [ 后，res 和 multi 重新记录。</p></li><li><p>当 c 为 ] 时，stack 出栈，拼接字符串 res &#x3D; last_res + cur_multi * res，其中:</p><ul><li>last_res是上个 [ 到当前 [ 的字符串，例如 “3[a2[c]]” 中的 a；</li><li>cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 “3[a2[c]]” 中的 2。</li></ul></li></ul></li><li><p>返回字符串 res。</p></li></ul></li></ul><p>作者：Krahets<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL3NvbHV0aW9ucy8xOTQ0Ny9kZWNvZGUtc3RyaW5nLWZ1LXpodS16aGFuLWZhLWRpLWd1aS1mYS1ieS1qeWQv">https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/</span></p><pre><code class="language-python">class Solution:
    def decodeString(self, s: str) -&gt; str:
        result = &#39;&#39;
        stack = []
        res, num = &#39;&#39;, 0
        for c in s:
            if c == &#39;[&#39;:
                stack.append((res, num))
                res, num = &#39;&#39;, 0
            elif c == &#39;]&#39;:
                out_res, out_num = stack.pop()
                res = out_res + out_num*res
            elif &#39;0&#39;&lt;= c &lt;= &#39;9&#39;:
                num = num*10 + int(c)
            else:
                res += c
        return res
</code></pre><p>:::</p><h3 id="649-Dota2-参议院"><a href="#649-Dota2-参议院" class="headerlink" title="649. Dota2 参议院"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kb3RhMi1zZW5hdGUv">649. Dota2 参议院</span></h3><p>Dota2 的世界里有两个阵营：<code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一</strong> 项：</p><ul><li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 <strong>所有的权利</strong> 。</li><li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li></ul><p>给你一个字符串 <code>senate</code> 代表每个参议员的阵营。字母 <code>&#39;R&#39;</code> 和 <code>&#39;D&#39;</code>分别代表了 <code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是 <code>n</code>。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 <code>&quot;Radiant&quot;</code> 或 <code>&quot;Dire&quot;</code> 。</p><p>+++info 示例</p><p><strong>示例 1：</strong></p><pre><code>输入：senate = &quot;RD&quot;
输出：&quot;Radiant&quot;
解释：
第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。
这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。
第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：senate = &quot;RDD&quot;
输出：&quot;Dire&quot;
解释：
第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。
这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。
这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
</code></pre><p>+++</p><p>:::info no-icon</p><p>这道题模拟了一个游戏过程，最终当有权利投票的参议员都是 同一个阵营的 ，这个阵营即获胜。</p><p>那么两个阵营的每个参议员为了获胜，当他拥有权力的时候，一定是会将自己之后首个对立阵营的参议员的权力禁止掉。【这就是每一位参议会为自己的政党做出最好的策略】。请注意：当之后没有对立阵营的参议员的时候，相当于将之前的参议员加到其之后。</p><p><img data-src="/2025-08-15-Leetcode%5C649-01.png" alt="300"></p><p><img data-src="/2025-08-15-Leetcode%5C649-02.png" alt="300"></p><p><img data-src="/2025-08-15-Leetcode%5C649-03.png" alt="300"></p><p><img data-src="/2025-08-15-Leetcode%5C649-04.png" alt="300"></p><p><img data-src="/2025-08-15-Leetcode%5C649-05.png" alt="300"></p><pre><code class="language-python">class Solution:
    def predictPartyVictory(self, senate: str) -&gt; str:
        radiants, dires = [], []
        n = len(senate)
        for i, se in enumerate(senate):
            if se == &#39;R&#39;: radiants.append(i)
            else: dires.append(i)
        while radiants and dires:
            if radiants[0] &lt; dires[0]:
                dires.pop(0)
                radiants.append(radiants.pop(0) + n)
            else:
                radiants.pop(0)
                dires.append(dires.pop(0) + n)
        return &quot;Radiant&quot; if radiants else &#39;Dire&#39;
        
</code></pre><p>作者：画图小匠<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kb3RhMi1zZW5hdGUvc29sdXRpb25zLzI4NjIxMTUvamF2YXB5dGhvbjNjZHVpLWxpZS1tby1uaS1qaW4temhpLXpoaS1oby1sNHBiLw==">https://leetcode.cn/problems/dota2-senate/solutions/2862115/javapython3cdui-lie-mo-ni-jin-zhi-zhi-ho-l4pb/</span></p><p>:::</p><h3 id="2095-删除链表的中间节点"><a href="#2095-删除链表的中间节点" class="headerlink" title="2095. 删除链表的中间节点"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtdGhlLW1pZGRsZS1ub2RlLW9mLWEtbGlua2VkLWxpc3Qv">2095. 删除链表的中间节点</span></h3><p>给你一个链表的头节点 <code>head</code> 。<strong>删除</strong> 链表的 <strong>中间节点</strong> ，并返回修改后的链表的头节点 <code>head</code> 。</p><p>长度为 <code>n</code> 链表的中间节点是从头数起第 <code>⌊n / 2⌋</code> 个节点（下标从 <strong>0</strong> 开始），其中 <code>⌊x⌋</code> 表示小于或等于 <code>x</code> 的最大整数。</p><ul><li>对于 <code>n</code> &#x3D; <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 和 <code>5</code> 的情况，中间节点的下标分别是 <code>0</code>、<code>1</code>、<code>1</code>、<code>2</code> 和 <code>2</code> 。</li></ul><p>:::info no-icon</p><p>本题可遍历计数先得到 n，再遍历一次删除指定节点即可，这很简单。本篇讲的是快慢指针这种方法。</p><p>我们令 fast 和 slow 这两个指针同时前进，fast 每次移动两格，slow 每次移动一格，在检测到 <code>fast.next == null</code> 或者 <code>fast.next.next == null</code> 时退出循环。</p><p>引入一个哑巴节点 dummy 便于处理，考虑循环停止时的场景。<br>为方便考虑，本篇题解认为原链表下标从 1 开始，需要删除第 $⌊\frac{n}{2}⌋+1$ 个节点。</p><ul><li>如果 <em>n</em> 为偶数，如下所示。设 <em>n</em>&#x3D;2<em>k</em>，fast 停在第 2<em>k</em> 个节点，slow 停在第 <em>k</em> 即 $⌊\frac{n}{2}⌋$ 个节点。</li></ul><p><img data-src="/2025-08-15-Leetcode%5C2095-01.png" alt="300"></p><ul><li>如果 <em>n</em> 为奇数，如下所示，设 <em>n</em>&#x3D;2<em>k</em>+1。fast 停在第 2<em>k</em> 个节点，slow 停在第 <em>k</em> 即 $⌊\frac{n}{2}⌋$ 个节点。</li></ul><p><img data-src="/2025-08-15-Leetcode%5C2095-02.png" alt="300"></p><p>所以退出循环时 slow 一定停在 $⌊\frac{n}{2}⌋$ 个节点，令 <code>slow.next = slow.next.next</code> 即删除了 $⌊\frac{n}{2}⌋+1$ 个节点。</p><p>作者：Shawxing精讲算法<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtdGhlLW1pZGRsZS1ub2RlLW9mLWEtbGlua2VkLWxpc3Qvc29sdXRpb25zLzI4NDQyMjkvamlhbi1taW5nLXlhbi1qaW4tZGUta3VhaS1tYW4temhpLXpoZW4tZi04NHN4Lw==">https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solutions/2844229/jian-ming-yan-jin-de-kuai-man-zhi-zhen-f-84sx/</span><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        zero = ListNode(0, head)
        slow, fast = zero, zero
        while fast and fast.next:
            fast = fast.next.next
            if not fast: break
            slow = slow.next
        slow.next = slow.next.next
        return zero.next

        
</code></pre><p>:::</p><h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC8=">328. 奇偶链表</span></h3><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。</p><p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。</p><p>:::info no-icon</p><p>如果链表为空，则直接返回链表。</p><p>对于原始链表，每个节点都是奇数节点或偶数节点。头节点是奇数节点，头节点的后一个节点是偶数节点，相邻节点的奇偶性不同。因此可以将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。</p><p>原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead &#x3D; head.next，则 evenHead 是偶数链表的头节点。</p><p>维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd &#x3D; head，even &#x3D; evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。</p><ul><li><p>更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next &#x3D; even.next，然后令 odd &#x3D; odd.next，此时 odd 变成 even 的后一个节点。</p></li><li><p>更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next &#x3D; odd.next，然后令 even &#x3D; even.next，此时 even 变成 odd 的后一个节点。</p></li></ul><p><img data-src="/2025-08-15-Leetcode%5C328-01.png" alt="300"></p><p><img data-src="/2025-08-15-Leetcode%5C328-02.png" alt="300"></p><p><img data-src="/2025-08-15-Leetcode%5C328-03.png" alt="300"></p><p><img data-src="/2025-08-15-Leetcode%5C328-04.png" alt="300"></p><p>在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。</p><p>最后令 odd.next &#x3D; evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。</p><p>作者：力扣官方题解<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC9zb2x1dGlvbnMvNDgyNzM3L3FpLW91LWxpYW4tYmlhby1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">https://leetcode.cn/problems/odd-even-linked-list/solutions/482737/qi-ou-lian-biao-by-leetcode-solution/</span></p><pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        if not head: return head
        even_head = head.next
        odd, even = head, even_head
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = even_head
        return head
</code></pre><p>:::</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-08-17 12:14:30" itemprop="dateModified" datetime="2025-08-17T12:14:30+08:00">2025-08-17</time> </span><span id="2025/08/15/2025-08-15-Leetcode/" class="item leancloud_visitors" data-flag-title="Leetcode刷题记录" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2025/07/17/2025-07-17-Tucker%E5%88%86%E8%A7%A3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s1.imagehub.cc&#x2F;images&#x2F;2023&#x2F;11&#x2F;16&#x2F;2a04752fdd0a7afde268910897c2113e.jpeg" title="Tucker分解"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 工具</span><h3>Tucker分解</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Leetcode%E5%88%B7%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Leetcode刷题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">数组&#x2F;字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">1071. 字符串的最大公因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">605. 种花问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#334-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">334. 递增的三元子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">1208. 尽可能使字符串相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">424. 替换后的最长重复字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87"><span class="toc-number">1.3.1.</span> <span class="toc-text">724. 寻找数组的中心下标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2352-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">2352. 相等行列对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#735-%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E"><span class="toc-number">1.4.1.</span> <span class="toc-text">735. 小行星碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#649-Dota2-%E5%8F%82%E8%AE%AE%E9%99%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">649. Dota2 参议院</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2095-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.4.</span> <span class="toc-text">2095. 删除链表的中间节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.5.</span> <span class="toc-text">328. 奇偶链表</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/12/06/2023-12-06_%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="bookmark" title="特征图可视化">特征图可视化</a></li><li class="active"><a href="/2025/08/15/2025-08-15-Leetcode/" rel="bookmark" title="Leetcode刷题记录">Leetcode刷题记录</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Hening" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Hening</p><div class="description" itemprop="description">终有弱水替沧海 再无相思寄巫山</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">10</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hueTEyMTY=" title="https:&#x2F;&#x2F;github.com&#x2F;Hny1216"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmhlbmluZzI1QG1haWwyLnN5c3UuZWR1LmNu" title="mailto:hening25@mail2.sysu.edu.cn"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/amusement/" rel="section"><i class="ic i-magic"></i>摸鱼</a></li><li class="item"><a href="/logging/" rel="section"><i class="ic i-file"></i>日志</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Hening @ Hening</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">170k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:35</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/08/15/2025-08-15-Leetcode/",favicon:{show:"Hening",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>