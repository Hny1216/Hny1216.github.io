<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hny" href="http://hening25.gitee.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hny" href="http://hening25.gitee.io/atom.xml"><link rel="alternate" type="application/json" title="Hny" href="http://hening25.gitee.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="java,git,cas"><link rel="canonical" href="http://hening25.gitee.io/2025/08/15/2025-08-15-Leetcode/"><title>Leetcode刷题记录 - 技能工具 | Hening = Hny = 终有弱水替沧海 再无相思寄巫山</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Leetcode刷题记录</h1><div class="meta"><span class="item" title="创建时间：2025-08-15 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-08-15T00:00:00+08:00">2025-08-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>21k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>19 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hening</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/ca90e642a3afabae3b1ef15332a097dc.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/012010a425f462ca2654fdd8a7517fc8.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/66a8a8bc0791b5140db06e3b9d60800c.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/d8a2c21d3abc2dd94ed5feff81f832bb.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/f5aae732ff21e61e4758727176920d75.jpeg"></li><li class="item" data-background-image="https://s1.imagehub.cc/images/2023/11/16/43ac0258d446a565ddf0640b2c99dcb2.jpeg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E6%8A%80%E8%83%BD%E5%B7%A5%E5%85%B7/" itemprop="item" rel="index" title="分类于 技能工具"><span itemprop="name">技能工具</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://hening25.gitee.io/2025/08/15/2025-08-15-Leetcode/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Hening"><meta itemprop="description" content="终有弱水替沧海 再无相思寄巫山, 终有弱水替沧海 再无相思寄巫山"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hny"></span><div class="body md" itemprop="articleBody"><p>Leetcode 刷题记录</p><p><span id="more"></span></p><h1 id="leetcode刷题"><a class="anchor" href="#leetcode刷题">#</a> Leetcode 刷题</h1><h2 id="数组字符串"><a class="anchor" href="#数组字符串">#</a> 数组 / 字符串</h2><h3 id="1071-字符串的最大公因子"><a class="anchor" href="#1071-字符串的最大公因子">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmVhdGVzdC1jb21tb24tZGl2aXNvci1vZi1zdHJpbmdzLw==">1071. 字符串的最大公因子</span></h3><p>对于字符串 <code>s</code> 和 <code>t</code> ，只有在 <code>s = t + t + t + ... + t + t</code> （ <code>t</code> 自身连接 1 次或多次）时，我们才认定 “ <code>t</code> 能除尽 <code>s</code> ”。</p><p>给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回 <em>最长字符串 <code>x</code> ，要求满足 <code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code> </em>。</p><div class="note info no-icon"><p>若两个字符串是由同一个字符串 X 重复拼接而成，那么无论先拼哪个，结果应该相同。<br>如果 str1 + str2 != str2 +str1，说明不存在公共的重复因子，直接返回空串 &quot;&quot;。<br>如果两个字符串都是由同一个字符串 X 组成，那么 X 的长度必然是 str1.size () 和 str2.size () 的最大公约数。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">gcdOfStrings</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> str1<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> str2<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token keyword">if</span> <span class="token keyword">not</span> str1 <span class="token operator">+</span> str2 <span class="token operator">==</span> str2 <span class="token operator">+</span> str1<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">return</span> <span class="token string">""</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">return</span> str1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>self<span class="token punctuation">.</span>gcd<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    </pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">gcd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">return</span> a</pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> gcd<span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">)</span></pre></td></tr></table></figure><p>作者：Random<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmVhdGVzdC1jb21tb24tZGl2aXNvci1vZi1zdHJpbmdzL3NvbHV0aW9ucy8zNzQ5ODkxL3NodS14dWUtenVpLWRhLWdvbmcteXVlLXNodS1ieS1jb2Rlci1yYW4tYTg4dS8=">https://leetcode.cn/problems/greatest-common-divisor-of-strings/solutions/3749891/shu-xue-zui-da-gong-yue-shu-by-coder-ran-a88u/</span></p></div><h3 id="605-种花问题"><a class="anchor" href="#605-种花问题">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tcGxhY2UtZmxvd2Vycy8=">605. 种花问题</span></h3><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花， <code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p><div class="note info no-icon"><p>从左到右遍历数组，能种花就立刻种花。</p><p>如何判断能否种花？由于「花不能种植在相邻的地块上」，如果要在下标 i 处种花，需要满足 flowerbed [i−1],flowerbed [i],flowerbed [i+1] 均为 0。</p><p>每种一朵花，就把 n 减一。如果最后 n≤0，则返回 true，否则返回 false。</p><p>为了简化判断逻辑，可以在数组的开头和末尾各插入一个 0。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">canPlaceFlowers</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> flowerbed<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      nums <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>flowerbed<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      new_flowerbed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> flowerbed <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>new_flowerbed<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">if</span> new_flowerbed<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> new_flowerbed<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> new_flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          new_flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="8"></td><td><pre>          n <span class="token operator">-=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token keyword">return</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span></pre></td></tr></table></figure><p>作者：灵茶山艾府<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tcGxhY2UtZmxvd2Vycy9zb2x1dGlvbnMvMjQ2MzAxOC9iZW4tdGktenVpLWppYW4tZGFuLXhpZS1mYS1weXRob25qYXZhY2dvLTZhNmsv">https://leetcode.cn/problems/can-place-flowers/solutions/2463018/ben-ti-zui-jian-dan-xie-fa-pythonjavacgo-6a6k/</span></p></div><h3 id="334-递增的三元子序列"><a class="anchor" href="#334-递增的三元子序列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbmNyZWFzaW5nLXRyaXBsZXQtc3Vic2VxdWVuY2Uv">334. 递增的三元子序列</span></h3><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p><p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><div class="note info no-icon"><div class="tab" data-id="id1" data-title="巧解"><p>核心想法：遍历一遍数组，希望遍历到的这个数 three，前面已经有一个比他小的数 two，再前面有一个比 two 小的数 one。<br>我们需要维护两个变量：one 和 two。代表递增子序列的第一个数和第二个数。<br>假设我们已经有了这两个数，那么 three 的大小有以下三种情况：</p><ol><li><p><strong>three 大于 two</strong> 此情况下：即找到了三元组，直接返回 true。</p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-01.png" width="300"></p></li><li><p><strong>three 介于 two 和 one 之间</strong> 此情况下：应更新 two，赋值为这个更小的值。这相当于帮我们扩大了 three 的可选择范围，当再次遇到一个比更新过的 two 大的数即可找到。</p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-02.png" width="300"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-03.png" width="300"></p></li><li><p><strong>three 小于 one</strong> 此情况下：应更新 one，赋值为这个更小的值。而不需要动 two。这相当于帮我们扩大了之后出现的 two 的可选择范围。进而扩大了之后出现的 three 的可选择范围。</p></li></ol><p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-04.png" width="300"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-05.png" width="300"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-06.png" width="300"></p><p>需要注意的是，我们只更新 one，原先的 two 不需要更改，因为子序列是从前往后的，只有当之后再出现比 two 小的数的时候再按照第二步那样更改。</p><p>假设有如下示例：[2,5,1,6]，在遇到 1 之后更新了 one，后遇到 6，因为先判断是否大于 two，由于 6 大于 5，就直接返回 true 了。</p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/334-07.png" width="300"></p><p>注意：two 附带隐含信息 —— 这之前有个数比 two 小<br>所以此时找到的递增子序列不是 one、two、three 的 1 5 6，而是 old one、two、three 的 2 5 6。</p><p>这里更新的 one 的意思是，为之后可能存在的更小的递增子序列打基础。<br>假设有如下示例：[2,5,1,2,6]，在遇到 1 之后更新了 one，后遇到 2，2 介于 1 和 5（two）之间，更新 two 为 2，后遇到 6，由于 6 大于 2，返回 true。<br>此时找到的递增子序列才是 one、two、three 的 1 2 6</p><p>最后考虑 one、two 的初值，容易想到设定为 Integer.MAX_VALUE 即可。</p><p>作者：Xzz<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbmNyZWFzaW5nLXRyaXBsZXQtc3Vic2VxdWVuY2Uvc29sdXRpb25zLzUzNTcyNS9wb3UteGktYmVuLXpoaS15aS13ZW4tYmFuZy1uaS1rYW4tcWluZy10LTN5ZTIv">https://leetcode.cn/problems/increasing-triplet-subsequence/solutions/535725/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/</span></p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">increasingTriplet</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      one<span class="token punctuation">,</span> two <span class="token operator">=</span> inf<span class="token punctuation">,</span> inf</pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token keyword">for</span> three <span class="token keyword">in</span> nums<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">if</span> three <span class="token operator">></span> two <span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">elif</span> three <span class="token operator">&lt;=</span> one<span class="token punctuation">:</span> one <span class="token operator">=</span> three</pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">else</span><span class="token punctuation">:</span> two <span class="token operator">=</span> three</pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token keyword">return</span> <span class="token boolean">False</span></pre></td></tr></table></figure><details class="info"><summary>解析（GPT）</summary><div><p><strong>1. 递增三元组的性质</strong></p><p>假设数组中存在递增三元组 <code>a &lt; b &lt; c</code> ，它们的顺序在数组中是 <strong>前后顺序</strong>，我们只关心：</p><ul><li>第一个数最小</li><li>第二个数比第一个数大</li><li>第三个数比第二个数大</li></ul><p><strong>关键点</strong>：我们不需要知道三元组具体位置，只需要保证存在。</p><p><strong>2. one 和 two 的作用</strong></p><ul><li><code>one</code> ：当前找到的<strong>最小的候选第一个数</strong></li><li><code>two</code> ：在 <code>one</code> 之后，找到的<strong>最小的候选第二个数</strong></li></ul><p><strong>核心思想</strong>：</p><ul><li>我们并不是在找数组中所有可能的三元组，而是在<strong>维护最优候选序列</strong>。</li><li>“最优候选” 意味着 <strong>尽可能小的 one 和 two</strong>，这样可以最大化出现第三个数 three 的机会。</li></ul><p>换句话说：</p><ol><li>遍历到一个数 three：<ul><li>如果 three &gt; two → 说明找到了一个合法三元组（不管前面 one/two 是不是更新过的，都会形成合法的递增序列）。</li></ul></li><li>如果 three &lt;= one → 更新 one<ul><li>因为这个更小的 one 可以为之后出现的 two 提供更多可能。</li></ul></li><li>否则 → 更新 two<ul><li>因为这个更小的 two 可以为之后出现的 three 提供更多可能。</li></ul></li></ol><p><strong>3. 为什么不会漏掉任何情况</strong></p><p>假设数组中有递增三元组 <code>x &lt; y &lt; z</code> ，为什么算法一定能找到它？</p><ul><li>当我们遍历到 x：<ul><li>one 会被更新为 ≤ x</li></ul></li><li>当我们遍历到 y：<ul><li>two 会被更新为 ≤ y</li></ul></li><li>当我们遍历到 z：<ul><li>如果 z &gt; two → 返回 True</li></ul></li></ul><p><strong>关键点</strong>：</p><ul><li>即使 one/two 被后面更小的数更新过，<strong>old one/two 仍然保留了前序信息</strong>，保证当前 three 大于某个二元组时，必然能形成递增三元组。</li><li>换句话说，one/two 是动态维护的 <strong>最小可能序列候选</strong>，任何真正存在的递增三元组都会被捕获。</li></ul></div></details></div><div class="tab" data-id="id1" data-title="常规"><p>常规解法</p></div></div><h2 id="滑动窗口"><a class="anchor" href="#滑动窗口">#</a> 滑动窗口</h2><h3 id="1208-尽可能使字符串相等"><a class="anchor" href="#1208-尽可能使字符串相等">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZXQtZXF1YWwtc3Vic3RyaW5ncy13aXRoaW4tYnVkZ2V0Lw==">1208. 尽可能使字符串相等</span></h3><p>给你两个长度相同的字符串， <code>s</code> 和 <code>t</code> 。</p><p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p><p>用于变更字符串的最大预算是 <code>maxCost</code> 。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p><p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p><p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code> 。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3
输出：3
解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0
输出：1
解释：a -&gt; a, cost = 0，字符串未发生变化，所以最大长度为 1。
</code></pre></div></details><div class="note info no-icon"><p>两个长度相等字符串的 s 和 t ，把 i 位置的 s [i] 转成 t [i] 的开销是两者 ASCII 码之差的绝对值。题目给出了允许的最大预算 maxCost ，求不超过预算的情况下能够转换的最长子串。</p><p>比如，对于 s = &quot;abcd&quot;, t = &quot;bcdf&quot;, cost = 3 而言，我们使用 costs [i] 表示从 s [i] 转成 t [i] 的开销，那么 costs = [1, 1, 1, 2] 。由于 maxCost = 3， 所以最多允许其前面三个字符进行转换。</p><p>于是题目变成了：<strong>已知一个数组 costs ，求：和不超过 maxCost 时最长的子数组的长度</strong>。</p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/1208-01.png" width="300"></p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">equalSubstring</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> t<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> maxCost<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        result <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        cost <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> n<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            cost <span class="token operator">+=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">while</span> cost <span class="token operator">></span> maxCost<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                cost <span class="token operator">-=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                left <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                </pre></td></tr><tr><td data-num="13"></td><td><pre>            result <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            right <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> result</pre></td></tr></table></figure><p>《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。</p><details class="info"><summary>滑动窗口问题模板</summary><div><p>我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题（<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXgtY29uc2VjdXRpdmUtb25lcy1paWkv">1004. 最大连续 1 的个数 III</span>，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQv">424. 替换后的最长重复字符</span>）：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">findSubArray</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    N <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token comment"># 数组 / 字符串长度</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token comment"># 双指针，表示当前遍历的区间 [left, right]，闭区间</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    sums <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># 用于统计 子数组 / 子区间 是否有效，根据题目可能会改成求和 / 计数</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    res <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment"># 保存最大的满足题目要求的 子数组 / 子串 长度</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">while</span> right <span class="token operator">&lt;</span> N<span class="token punctuation">:</span> <span class="token comment"># 当右边的指针没有搜索到 数组 / 字符串 的结尾</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        sums <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token comment"># 增加当前右边指针的数字 / 字符的求和 / 计数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span> 区间<span class="token punctuation">[</span>left<span class="token punctuation">,</span> right<span class="token punctuation">]</span>不符合题意：<span class="token comment"># 此时需要一直移动左指针，直至找到一个符合题意的区间</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            sums <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token comment"># 移动左指针前需要从 counter 中减少 left 位置字符的求和 / 计数</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            left <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment"># 真正的移动左指针，注意不能跟上面一行代码写反</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token comment"># 到 while 结束时，我们找到了一个符合题意要求的 子数组 / 子串</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        res <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># 需要更新结果</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        right <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment"># 移动右指针，去探索新的区间</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">return</span> res</pre></td></tr></table></figure><p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p><p>模板的整体思想是：</p><p>定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；<br>第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和 / 计数；<br>第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和 / 计数；<br>在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max (res, 当前区间的长度) 。<br>right 指针每次向右移动一步，开始探索新的区间。<br>模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把 sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。</p><p>另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间 [left, right] 不符合题意 。对于本题而言，就是该区内的和 sums 超过了 maxCost 。</p></div></details><p>作者：负雪明烛<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZXQtZXF1YWwtc3Vic3RyaW5ncy13aXRoaW4tYnVkZ2V0L3NvbHV0aW9ucy81OTIzNTQvZmVuLXhpYW5nLXpoZW4tY2FuZy1kZS1odWEtZG9uZy1jaHVhbmctay1lM3JkLw==">https://leetcode.cn/problems/get-equal-substrings-within-budget/solutions/592354/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/</span></p></div><h3 id="424-替换后的最长重复字符"><a class="anchor" href="#424-替换后的最长重复字符">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQv">424. 替换后的最长重复字符</span></h3><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p><p>在执行上述操作后，返回 <em>包含相同字母的最长子字符串的长度。</em></p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;ABAB&quot;, k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;AABABBA&quot;, k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 &quot;AABBBBA&quot;。
子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。
可能存在其他的方法来得到同样的结果。
</code></pre></div></details><div class="note info no-icon"><p>本题解根据常规的滑动窗口思路进行解题，不需要任何的技巧。<br>滑动窗口法是指通过 Left 以及 Right 指针来框定一个窗口，当在窗口内的字符串满足题目要求则记录下当前窗口长度并进一步扩张寻找更长的窗口，若不满足则进行窗口平移。<br>题目中给定的 K 值是让我们在选定有效窗口时的要求放宽了：</p><p>当 K=0 时，要求滑动窗口内部的所有字母都必须相同；<br>而当 K&gt;0 时，要求滑动窗口内最多替换 K 次使得所有字母都必须相同。这里有一个关键点，即我们将当前滑动窗口内出现次数最多的字母作为基准字母（Benchmark），那么其他不一样的字母 (Others) 都选择替换操作即可以最小的代价转换为全部相同的字母。<br>因此，我们首先通过一个数组 (count) 记录所有字母在当前窗口出现的次数，通过 Max 函数选择窗口内的基准字母，然后其他字母出现的次数为 Sum (count)-Max (count)，通过与 K 进行比较，即可知道当前窗口是否有效，下一步是继续扩张还是位移。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">characterReplacement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment">#记录当前窗口的字母出现次数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        </pre></td></tr><tr><td data-num="5"></td><td><pre>        left <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment">#滑动窗口左边界</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        right <span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment">#滑动窗口右边界</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        retval <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment">#最长窗口长度</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        </pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">while</span> right <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            count<span class="token punctuation">[</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>  </pre></td></tr><tr><td data-num="11"></td><td><pre>            benchmark <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>              <span class="token comment">#选择出现次数最多的字母为基准 </span></pre></td></tr><tr><td data-num="12"></td><td><pre>            others <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token operator">-</span> benchmark     <span class="token comment">#则其他字母需要通过替换操作来变为基准</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> others <span class="token operator">&lt;=</span> k<span class="token punctuation">:</span>                     <span class="token comment">#通过与 K 进行比较来判断窗口是进行扩张？</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                right <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                retval <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>retval<span class="token punctuation">,</span> right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token comment">#记录当前有效窗口长度</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token keyword">else</span><span class="token punctuation">:</span>                               <span class="token comment">#通过与 K 进行比较来判断窗口还是进行位移？</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                count<span class="token punctuation">[</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token builtin">ord</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                left <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                right <span class="token operator">+=</span> <span class="token number">1</span>                      <span class="token comment">#这里注意：位移操作需要整个向右移，不仅仅只是 left 向右</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        </pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token keyword">return</span> retval                           <span class="token comment">#返回最长窗口长度</span></pre></td></tr></table></figure><p>作者：Derrick.S<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQvc29sdXRpb25zLzc5OTAxMy9odWEtZG9uZy1jaHVhbmcta291LWZhLWppYW4tZGFuLXlpLWRvbmctM3F3ZWwv">https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/799013/hua-dong-chuang-kou-fa-jian-dan-yi-dong-3qwel/</span></p></div><h2 id="前缀和"><a class="anchor" href="#前缀和">#</a> 前缀和</h2><h3 id="724-寻找数组的中心下标"><a class="anchor" href="#724-寻找数组的中心下标">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBpdm90LWluZGV4Lw==">724. 寻找数组的中心下标</span></h3><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p><p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
</code></pre></div></details><div class="note info no-icon"><p>设 nums 的元素之和为 s。</p><p>设中心下标为 i，其左侧元素和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>S</mi><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">leftS=nums[0]+nums[1]+⋯+nums[i−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，那么右侧元素和为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mtext>−</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext>−</mtext><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">s−nums[i]−leftS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mord">−</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>。</p><p>由于左侧元素和等于右侧元素和，所以有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>S</mi><mo>=</mo><mi>s</mi><mtext>−</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mtext>−</mtext><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">leftS=s−nums[i]−leftS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mord">−</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span></span></p><p>即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>2</mn><mo>⋅</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>S</mi><mo>=</mo><mi>s</mi><mtext>−</mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">2⋅leftS=s−nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">2</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">s</span><span class="mord">−</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></p><p>从左到右遍历数组，一边遍历，一边累加元素更新 leftS。每次累加前，检查是否满足上式，满足则返回 i。</p><p>如果不存在这样的 i，返回 −1。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">pivotIndex</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        s <span class="token operator">=</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        sum_left <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> num <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> <span class="token number">2</span><span class="token operator">*</span>sum_left <span class="token operator">==</span> s <span class="token operator">-</span> num<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                <span class="token keyword">return</span> i</pre></td></tr><tr><td data-num="8"></td><td><pre>            sum_left <span class="token operator">+=</span> num</pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span></pre></td></tr></table></figure><p>作者：灵茶山艾府<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBpdm90LWluZGV4L3NvbHV0aW9ucy8yODM0Njg3L2ppYW4tamkteGllLWZhLW8xLWUtd2FpLWtvbmctamlhbi1weXRob24tdHowcC8=">https://leetcode.cn/problems/find-pivot-index/solutions/2834687/jian-ji-xie-fa-o1-e-wai-kong-jian-python-tz0p/</span></p></div><h3 id="2352-相等行列对"><a class="anchor" href="#2352-相等行列对">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lcXVhbC1yb3ctYW5kLWNvbHVtbi1wYWlycy8=">2352. 相等行列对</span></h3><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code> 列相等的行列对 <code>(Ri, Cj)</code> 的数目 *。*</p><p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p><div class="note info no-icon"><p>用哈希表统计每行出现的次数，然后遍历列，累加哈希表中列出现的次数。</p><p>作者：灵茶山艾府<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lcXVhbC1yb3ctYW5kLWNvbHVtbi1wYWlycy9zb2x1dGlvbnMvMTY5NDA0Ny9oYS14aS1iaWFvLXB5dGhvbi1saWFuZy14aW5nLWJ5LWVuZGxlc3NjLWxqYWUv">https://leetcode.cn/problems/equal-row-and-column-pairs/solutions/1694047/ha-xi-biao-python-liang-xing-by-endlessc-ljae/</span></p><div class="tab" data-id="id2" data-title="Demo 1"><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">equalPairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        cnt <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> grid<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">return</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>grid<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure></div><div class="tab" data-id="id2" data-title="Demo2"><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">equalPairs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> grid<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        count <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        result <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            count<span class="token punctuation">[</span><span class="token builtin">tuple</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token builtin">tuple</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span><span class="token operator">*</span>grid<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            result <span class="token operator">+=</span> count<span class="token punctuation">.</span>get<span class="token punctuation">(</span>j<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token comment"># print(grid[:][j], grid[j][:])</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token keyword">return</span> result</pre></td></tr></table></figure></div></div><h2 id="栈与队列"><a class="anchor" href="#栈与队列">#</a> 栈与队列</h2><h3 id="735-小行星碰撞"><a class="anchor" href="#735-小行星碰撞">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3Rlcm9pZC1jb2xsaXNpb24v">735. 小行星碰撞</span></h3><p>给定一个整数数组 <code>asteroids</code> ，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。</p><p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p><p>找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><pre><code>输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：asteroids = [8,-8]
输出：[]
解释：8 和 -8 碰撞后，两者都发生爆炸。
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：asteroids = [10,2,-5]
输出：[10]
解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。
</code></pre></div></details><div class="note info no-icon"><p>这道栈的题目难点应该主要是在分析场景上了。<br>我们需要明确什么时候无脑入栈，什么时候需要判断，理解这两点就可以轻松解题了。<br>首先，循环每一个元素时，在什么情况下无脑入栈呢？</p><p>栈为空<br>栈顶元素为负数 (下一个为负数则一起向左，下一个为正数则分向两边)<br>当前元素为正数（栈顶为正一起向右，栈顶为负分向两边）<br>下来，我们需要看碰撞的场景又细分为什么情况：</p><p>栈顶元素大于 abs (当前元素)，当前元素被撞毁<br>栈顶元素等于 abs (当前元素)，栈顶弹出和当前元素抵消<br>栈顶元素小于 abs (当前元素)，栈顶弹出，并与新栈顶完成上述判断<br>最终返回栈即可。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">asteroidCollision</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> asteroids<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        stack<span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>asteroids<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            ast <span class="token operator">=</span> asteroids<span class="token punctuation">[</span>index<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> ast <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">or</span> <span class="token builtin">len</span><span class="token punctuation">(</span>stack<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token keyword">or</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span> stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ast<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">elif</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token operator">-</span> ast<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                <span class="token keyword">if</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token operator">-</span> ast<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                    <span class="token keyword">continue</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            index <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">return</span> stack</pre></td></tr></table></figure><p>作者：清风 Python<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3Rlcm9pZC1jb2xsaXNpb24vc29sdXRpb25zLzk5NDEwMC83MzV4aW5nLXhpbmctcGVuZy16aHVhbmctamkteXUtemhhbi1xdS1mLXhwZDEv">https://leetcode.cn/problems/asteroid-collision/solutions/994100/735xing-xing-peng-zhuang-ji-yu-zhan-qu-f-xpd1/</span></p></div><h3 id="394-字符串解码"><a class="anchor" href="#394-字符串解码">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nLw==">394. 字符串解码</span></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code> ，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p>测试用例保证输出的长度不会超过 <code>105</code> 。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><pre><code>输入：s = &quot;3[a]2[bc]&quot;
输出：&quot;aaabcbc&quot;
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：s = &quot;3[a2[c]]&quot;
输出：&quot;accaccacc&quot;
</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：s = &quot;2[abc]3[cd]ef&quot;
输出：&quot;abcabccdcdcdef&quot;
</code></pre><p><strong>示例 4：</strong></p><pre><code>输入：s = &quot;abc3[cd]xyz&quot;
输出：&quot;abccdcdcdxyz&quot;
</code></pre></div></details><div class="note info no-icon"><ul><li><p>本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。</p></li><li><p>算法流程：</p><ul><li><p>构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</p><ul><li><p>当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</p></li><li><p>当 c 为字母时，在 res 尾部添加 c；</p></li><li><p>当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：<br>记录此 [前的临时结果 res 至栈，用于发现对应] 后的拼接操作；<br>记录此 [前的倍数 multi 至栈，用于发现对应] 后，获取 multi × [...] 字符串。<br>进入到新 [ 后，res 和 multi 重新记录。</p></li><li><p>当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:</p><ul><li>last_res 是上个 [到当前 [ 的字符串，例如 &quot;3 [a2 [c]]&quot; 中的 a；</li><li>cur_multi 是当前 [到] 内字符串的重复倍数，例如 &quot;3 [a2 [c]]&quot; 中的 2。</li></ul></li></ul></li><li><p>返回字符串 res。</p></li></ul></li></ul><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">decodeString</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        result <span class="token operator">=</span> <span class="token string">''</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        res<span class="token punctuation">,</span> num <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">for</span> c <span class="token keyword">in</span> s<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">if</span> c <span class="token operator">==</span> <span class="token string">'['</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                res<span class="token punctuation">,</span> num <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            <span class="token keyword">elif</span> c <span class="token operator">==</span> <span class="token string">']'</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                out_res<span class="token punctuation">,</span> out_num <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                res <span class="token operator">=</span> out_res <span class="token operator">+</span> out_num<span class="token operator">*</span>res</pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">elif</span> <span class="token string">'0'</span><span class="token operator">&lt;=</span> c <span class="token operator">&lt;=</span> <span class="token string">'9'</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                num <span class="token operator">=</span> num<span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> <span class="token builtin">int</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">else</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                res <span class="token operator">+=</span> c</pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> res</pre></td></tr></table></figure><p>作者：Krahets<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL3NvbHV0aW9ucy8xOTQ0Ny9kZWNvZGUtc3RyaW5nLWZ1LXpodS16aGFuLWZhLWRpLWd1aS1mYS1ieS1qeWQv">https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/</span></p></div><h3 id="649-dota2-参议院"><a class="anchor" href="#649-dota2-参议院">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kb3RhMi1zZW5hdGUv">649. Dota2 参议院</span></h3><p>Dota2 的世界里有两个阵营： <code>Radiant</code> （天辉）和 <code>Dire</code> （夜魇）</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一</strong> 项：</p><ul><li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 <strong>所有的权利</strong> 。</li><li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li></ul><p>给你一个字符串 <code>senate</code> 代表每个参议员的阵营。字母 <code>'R'</code> 和 <code>'D'</code> 分别代表了 <code>Radiant</code> （天辉）和 <code>Dire</code> （夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是 <code>n</code> 。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 <code>&quot;Radiant&quot;</code> 或 <code>&quot;Dire&quot;</code> 。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><pre><code>输入：senate = &quot;RD&quot;
输出：&quot;Radiant&quot;
解释：
第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。
这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。
第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。
</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：senate = &quot;RDD&quot;
输出：&quot;Dire&quot;
解释：
第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。
这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。
这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
</code></pre></div></details><div class="note info no-icon"><p>这道题模拟了一个游戏过程，最终当有权利投票的参议员都是 同一个阵营的 ，这个阵营即获胜。</p><p>那么两个阵营的每个参议员为了获胜，当他拥有权力的时候，一定是会将自己之后首个对立阵营的参议员的权力禁止掉。【这就是每一位参议会为自己的政党做出最好的策略】。请注意：当之后没有对立阵营的参议员的时候，相当于将之前的参议员加到其之后。</p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/649-01.png" width="500"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/649-02.png" width="500"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/649-03.png" width="500"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/649-04.png" width="500"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/649-05.png" width="500"></p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">predictPartyVictory</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> senate<span class="token punctuation">:</span> <span class="token builtin">str</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        radiants<span class="token punctuation">,</span> dires <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>senate<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> se <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>senate<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token keyword">if</span> se <span class="token operator">==</span> <span class="token string">'R'</span><span class="token punctuation">:</span> radiants<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">else</span><span class="token punctuation">:</span> dires<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">while</span> radiants <span class="token keyword">and</span> dires<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            <span class="token keyword">if</span> radiants<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> dires<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                dires<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                radiants<span class="token punctuation">.</span>append<span class="token punctuation">(</span>radiants<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">else</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                radiants<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>                dires<span class="token punctuation">.</span>append<span class="token punctuation">(</span>dires<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> n<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> <span class="token string">"Radiant"</span> <span class="token keyword">if</span> radiants <span class="token keyword">else</span> <span class="token string">'Dire'</span></pre></td></tr></table></figure><p>作者：画图小匠<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kb3RhMi1zZW5hdGUvc29sdXRpb25zLzI4NjIxMTUvamF2YXB5dGhvbjNjZHVpLWxpZS1tby1uaS1qaW4temhpLXpoaS1oby1sNHBiLw==">https://leetcode.cn/problems/dota2-senate/solutions/2862115/javapython3cdui-lie-mo-ni-jin-zhi-zhi-ho-l4pb/</span></p></div><h2 id="链表"><a class="anchor" href="#链表">#</a> 链表</h2><div class="note info no-icon"><ol><li>找中间节点：快慢指针</li></ol><ul><li><p>中间值左侧：需要加一个 dummy 节点。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> dummy<span class="token punctuation">,</span> dummy</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">while</span> fast <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> fast<span class="token punctuation">:</span> <span class="token keyword">break</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr></table></figure></li><li><p>中间值右侧：直接从 head 开始</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">,</span> head</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">while</span> fast <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">if</span> <span class="token keyword">not</span> fast<span class="token punctuation">:</span> <span class="token keyword">break</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr></table></figure></li></ul></div><h3 id="2095-删除链表的中间节点"><a class="anchor" href="#2095-删除链表的中间节点">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtdGhlLW1pZGRsZS1ub2RlLW9mLWEtbGlua2VkLWxpc3Qv">2095. 删除链表的中间节点</span></h3><p>给你一个链表的头节点 <code>head</code> 。<strong>删除</strong> 链表的 <strong>中间节点</strong> ，并返回修改后的链表的头节点 <code>head</code> 。</p><p>长度为 <code>n</code> 链表的中间节点是从头数起第 <code>⌊n / 2⌋</code> 个节点（下标从 <strong>0</strong> 开始），其中 <code>⌊x⌋</code> 表示小于或等于 <code>x</code> 的最大整数。</p><ul><li>对于 <code>n</code> = <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>4</code> 和 <code>5</code> 的情况，中间节点的下标分别是 <code>0</code> 、 <code>1</code> 、 <code>1</code> 、 <code>2</code> 和 <code>2</code> 。</li></ul><div class="note info no-icon"><p>本题可遍历计数先得到 n，再遍历一次删除指定节点即可，这很简单。本篇讲的是快慢指针这种方法。</p><p>我们令 fast 和 slow 这两个指针同时前进，fast 每次移动两格，slow 每次移动一格，在检测到 <code>fast.next == null</code> 或者 <code>fast.next.next == null</code> 时退出循环。</p><p>引入一个哑巴节点 dummy 便于处理，考虑循环停止时的场景。<br>为方便考虑，本篇题解认为原链表下标从 1 开始，需要删除第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">⌊\frac{n}{2}⌋+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-.345em"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.695392em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 个节点。</p><ul><li>如果 <em>n</em> 为偶数，如下所示。设 <em>n</em>=2<em>k</em>，fast 停在第 2<em>k</em> 个节点，slow 停在第 <em>k</em> 即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">⌊\frac{n}{2}⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-.345em"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.695392em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span> 个节点。</li></ul><p><img data-src="/2025/08/15/2025-08-15-Leetcode/2095-01.png" width="300"></p><ul><li>如果 <em>n</em> 为奇数，如下所示，设 <em>n</em>=2<em>k</em>+1。fast 停在第 2<em>k</em> 个节点，slow 停在第 <em>k</em> 即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">⌊\frac{n}{2}⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-.345em"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.695392em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span> 个节点。</li></ul><p><img data-src="/2025/08/15/2025-08-15-Leetcode/2095-02.png" width="300"></p><p>所以退出循环时 slow 一定停在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">⌊\frac{n}{2}⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-.345em"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.695392em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span> 个节点，令 <code>slow.next = slow.next.next</code> 即删除了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">⌊\frac{n}{2}⌋+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-.345em"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.695392em"><span style="top:-2.6550000000000002em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.345em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 个节点。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for singly-linked list.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class ListNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, val=0, next=None):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = val</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.next = next</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">deleteMiddle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        zero <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> zero<span class="token punctuation">,</span> zero</pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> fast <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> <span class="token keyword">not</span> fast<span class="token punctuation">:</span> <span class="token keyword">break</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        slow<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> zero<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr></table></figure><p>作者：Shawxing 精讲算法<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtdGhlLW1pZGRsZS1ub2RlLW9mLWEtbGlua2VkLWxpc3Qvc29sdXRpb25zLzI4NDQyMjkvamlhbi1taW5nLXlhbi1qaW4tZGUta3VhaS1tYW4temhpLXpoZW4tZi04NHN4Lw==">https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solutions/2844229/jian-ming-yan-jin-de-kuai-man-zhi-zhen-f-84sx/</span></p></div><h3 id="328-奇偶链表"><a class="anchor" href="#328-奇偶链表">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC8=">328. 奇偶链表</span></h3><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。</p><p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推。</p><p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p><p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。</p><div class="note info no-icon"><p>如果链表为空，则直接返回链表。</p><p>对于原始链表，每个节点都是奇数节点或偶数节点。头节点是奇数节点，头节点的后一个节点是偶数节点，相邻节点的奇偶性不同。因此可以将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。</p><p>原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead = head.next，则 evenHead 是偶数链表的头节点。</p><p>维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd = head，even = evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。</p><ul><li><p>更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next = even.next，然后令 odd = odd.next，此时 odd 变成 even 的后一个节点。</p></li><li><p>更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next = odd.next，然后令 even = even.next，此时 even 变成 odd 的后一个节点。</p></li></ul><p><img data-src="/2025/08/15/2025-08-15-Leetcode/328-01.png" width="400"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/328-02.png" width="400"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/328-03.png" width="400"></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/328-04.png" width="400"></p><p>在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。</p><p>最后令 odd.next = evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for singly-linked list.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class ListNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, val=0, next=None):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = val</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.next = next</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">oddEvenList</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> <span class="token keyword">not</span> head<span class="token punctuation">:</span> <span class="token keyword">return</span> head</pre></td></tr><tr><td data-num="9"></td><td><pre>        even_head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        odd<span class="token punctuation">,</span> even <span class="token operator">=</span> head<span class="token punctuation">,</span> even_head</pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> even <span class="token keyword">and</span> even<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            odd<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> even<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            odd <span class="token operator">=</span> odd<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            even<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> odd<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            even <span class="token operator">=</span> even<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        odd<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> even_head</pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> head</pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC9zb2x1dGlvbnMvNDgyNzM3L3FpLW91LWxpYW4tYmlhby1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=">https://leetcode.cn/problems/odd-even-linked-list/solutions/482737/qi-ou-lian-biao-by-leetcode-solution/</span></p></div><h3 id="2130-链表最大孪生和"><a class="anchor" href="#2130-链表最大孪生和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXR3aW4tc3VtLW9mLWEtbGlua2VkLWxpc3Qv">2130. 链表最大孪生和</span></h3><p>在一个大小为 <code>n</code> 且 <code>n</code> 为 <strong>偶数</strong> 的链表中，对于 <code>0 &lt;= i &lt;= (n / 2) - 1</code> 的 <code>i</code> ，第 <code>i</code> 个节点（下标从 <strong>0</strong> 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。</p><ul><li>比方说， <code>n = 4</code> 那么节点 <code>0</code> 是节点 <code>3</code> 的孪生节点，节点 <code>1</code> 是节点 <code>2</code> 的孪生节点。这是长度为 <code>n = 4</code> 的链表中所有的孪生节点。</li></ul><p><strong>孪生和</strong> 定义为一个节点和它孪生节点两者值之和。</p><p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 <strong>最大孪生和</strong> 。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/2130-01.png" width="300"></p><pre><code>输入：head = [5,4,2,1]
输出：6
解释：
节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。
链表中没有其他孪生节点。
所以，链表的最大孪生和是 6 。
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/2130-02.png" width="300"></p><pre><code>输入：head = [4,2,2,3]
输出：7
解释：
链表中的孪生节点为：
- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。
- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。
所以，最大孪生和为 max(7, 4) = 7 。
</code></pre></div></details><div class="note info no-icon"><p><strong>核心思想：寻找链表中间值</strong></p><p>以下两种方法的快慢指针有所不同，参见<a href="#%E9%93%BE%E8%A1%A8">链表</a>。</p><div class="tab" data-id="id3" data-title="快慢指针+反转链表"><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for singly-linked list.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class ListNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, val=0, next=None):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = val</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.next = next</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">pairSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        mid <span class="token operator">=</span> self<span class="token punctuation">.</span>middleNode<span class="token punctuation">(</span>head<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        head2 <span class="token operator">=</span> self<span class="token punctuation">.</span>reverseNode<span class="token punctuation">(</span>mid<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        result <span class="token operator">=</span> <span class="token operator">-</span>inf</pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">while</span> head2<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            result <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> head<span class="token punctuation">.</span>val <span class="token operator">+</span> head2<span class="token punctuation">.</span>val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            head <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            head2 <span class="token operator">=</span> head2<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> result</pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">reverseNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        cur<span class="token punctuation">,</span> pre <span class="token operator">=</span> head<span class="token punctuation">,</span> <span class="token boolean">None</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">while</span> cur<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            nxt <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            cur<span class="token punctuation">.</span><span class="token builtin">next</span> <span class="token operator">=</span> pre</pre></td></tr><tr><td data-num="22"></td><td><pre>            pre <span class="token operator">=</span> cur</pre></td></tr><tr><td data-num="23"></td><td><pre>            cur <span class="token operator">=</span> nxt</pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">return</span> pre</pre></td></tr><tr><td data-num="25"></td><td><pre>        </pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        slow <span class="token operator">=</span> fast <span class="token operator">=</span> head</pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token keyword">while</span> fast <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token keyword">return</span> slow</pre></td></tr></table></figure></div><div class="tab" data-id="id3" data-title="快慢指针+入栈"><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for singly-linked list.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class ListNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, val=0, next=None):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = val</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.next = next</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">pairSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>ListNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        dummy <span class="token operator">=</span> ListNode<span class="token punctuation">(</span><span class="token builtin">next</span><span class="token operator">=</span>head<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        slow<span class="token punctuation">,</span> fast <span class="token operator">=</span> dummy<span class="token punctuation">,</span> dummy</pre></td></tr><tr><td data-num="10"></td><td><pre>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        result <span class="token operator">=</span> <span class="token operator">-</span>inf</pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">while</span> fast <span class="token keyword">and</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">while</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            result <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token keyword">return</span> result</pre></td></tr></table></figure></div></div><h2 id="二叉树"><a class="anchor" href="#二叉树">#</a> 二叉树</h2><div class="note info no-icon"><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVVENHkxWTc2OS8/dmRfc291cmNlPTliMDUwMzdjNzdlYzk0MGRhZTNhZjhlNjk5NjllMGQ2">看到递归就晕？带你理解递归的本质！【基础算法精讲 09】_哔哩哔哩_bilibili</span></li></ol></div><h3 id="437-路径总和-iii"><a class="anchor" href="#437-路径总和-iii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkv">437. 路径总和 III</span>（与<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsv"> 560. 和为 K 的子数组</span>方法相似）</h3><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/437-01.png" width="300"></p><pre><code>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
</code></pre></div></details><div class="note info no-icon"><p>如果二叉树是一条链，本题就和 560. 和为 K 的子数组 完全一样了：统计有多少个非空连续子数组的元素和恰好等于 targetSum。所以你必须先弄明白 560 题（特殊情况），再来做本题（一般情况）。560 题的做法见 我的题解。</p><p>这两题的联系如下：</p><table><thead><tr><th>560 题</th><th>本题</th></tr></thead><tbody><tr><td>连续子数组</td><td>方向向下的路径</td></tr><tr><td>前缀</td><td>从根节点开始的路径</td></tr><tr><td>做法：枚举子数组右端点，统计有多少个左端点</td><td>做法：枚举路径的终点，统计有多少个起点 &lt;br/&gt; 我们要解决的问题是：DFS 遍历这棵树，遍历到节点 node 时，假设 node 是路径的终点，那么有多少个起点，满足起点到终点 node 的路径总和恰好等于 targetSum？</td></tr></tbody></table><p>和 560 题一样的套路：一边遍历二叉树，一边用哈希表 cnt 统计前缀和（从根节点开始的路径和）的出现次数。设从根到终点 node 的路径和为 s，那么起点的个数就是 cnt [s−targetSum]，加入答案。对比 560 题，我们在枚举子数组的右端点（终点），统计有多少个左端点（起点），做法完全一致。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for a binary tree node.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class TreeNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = val</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.left = left</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">#         self.right = right</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">pathSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">,</span> targetSum<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        ans <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        hp <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        hp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span> <span class="token keyword">return</span> </pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">nonlocal</span> ans</pre></td></tr><tr><td data-num="15"></td><td><pre>            s <span class="token operator">+=</span> node<span class="token punctuation">.</span>val</pre></td></tr><tr><td data-num="16"></td><td><pre>            ans <span class="token operator">+=</span> hp<span class="token punctuation">[</span>s <span class="token operator">-</span> targetSum<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>            hp<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>            dfs<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> s<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            hp<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> ans</pre></td></tr></table></figure><p>作者：灵茶山艾府<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkvc29sdXRpb25zLzI3ODQ4NTYvenVvLWZhLWhlLTU2MC10aS1zaGkteWkteWFuZy1kZS1weXRob25qYS1mbXpvLw==">https://leetcode.cn/problems/path-sum-iii/solutions/2784856/zuo-fa-he-560-ti-shi-yi-yang-de-pythonja-fmzo/</span></p></div><h3 id="1372-二叉树中的最长交错路径"><a class="anchor" href="#1372-二叉树中的最长交错路径">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXppZ3phZy1wYXRoLWluLWEtYmluYXJ5LXRyZWUv">1372. 二叉树中的最长交错路径</span></h3><p>给你一棵以 <code>root</code> 为根的二叉树，二叉树中的交错路径定义如下：</p><ul><li>选择二叉树中 <strong>任意</strong> 节点和一个方向（左或者右）。</li><li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li><li>改变前进方向：左变右或者右变左。</li><li>重复第二步和第三步，直到你在树中无法继续移动。</li></ul><p>交错路径的长度定义为：<strong>访问过的节点数目 - 1</strong>（单个节点的路径长度为 0 ）。</p><p>请你返回给定树中最长 <strong>交错路径</strong> 的长度。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/1372-01.png" width="100"></p><pre><code>输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
输出：3
解释：蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/1372-02.png" width="100"></p><pre><code>输入：root = [1,1,1,null,1,null,null,1,1,null,1]
输出：4
解释：蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。
</code></pre></div></details><div class="note info no-icon"><p>在 DFS 的过程中，每次我们都把当前点的 len 参数和答案 maxAns 打擂台，这样可以比出一个最大的。然后我们根据 dir 分类讨论。如果当前点应该向左且可以向左，那么就让他向左走一步，新的 len 是当前的 len 加一。如果的的点应该向左但是却没有左子树呢？很无奈那就只能向右了，这个时候 len 的值应该「重置」。</p><p>思考：「重置」为什么是把 len 变成 1 而不是 0？ 因为当前的点下传到它的子节点的时候已经走了一条长度为 1 的边。那么为什么 main 函数中传入的 len 值是 0 而不是 1 呢？ 因为 main 函数中的 root 是没有父亲节点的，所以当前已经走过的路为 0。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for a binary tree node.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class TreeNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = val</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.left = left</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">#         self.right = right</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">longestZigZag</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        result <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> mode<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token keyword">not</span> node<span class="token punctuation">:</span><span class="token keyword">return</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">nonlocal</span> result</pre></td></tr><tr><td data-num="13"></td><td><pre>            result <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> l<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">if</span> mode <span class="token operator">==</span> <span class="token string">'left'</span><span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="15"></td><td><pre>                search<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token string">'right'</span><span class="token punctuation">,</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                search<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token string">'left'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token keyword">elif</span> mode <span class="token operator">==</span> <span class="token string">'right'</span><span class="token punctuation">:</span> </pre></td></tr><tr><td data-num="18"></td><td><pre>                search<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token string">'left'</span><span class="token punctuation">,</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                search<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token string">'right'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        search<span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token string">'left'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        search<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token string">'right'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token keyword">return</span> result</pre></td></tr></table></figure><p>作者：力扣官方题解<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXppZ3phZy1wYXRoLWluLWEtYmluYXJ5LXRyZWUvc29sdXRpb25zLzE0NzQyNS9lci1jaGEtc2h1LXpob25nLWRlLXp1aS1jaGFuZy1qaWFvLWN1by1sdS1qaW5nLWItMi8=">https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/solutions/147425/er-cha-shu-zhong-de-zui-chang-jiao-cuo-lu-jing-b-2/</span></p></div><h3 id="236-二叉树的最近公共祖先"><a class="anchor" href="#236-二叉树的最近公共祖先">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv">236. 二叉树的最近公共祖先</span></h3><p>给定一个二叉树，找到该树中两个指定节点的最近公共祖先。</p><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODgvODkxODgzND9mcj1hbGFkZGlu">百度百科</span>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/236-01.png" width="200"></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
</code></pre><p><strong>示例 2：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/236-02.png" width="200"></p><pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
</code></pre></div></details><div class="note info no-icon"><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVc0NHkxWjdBUi8/dmRfc291cmNlPTliMDUwMzdjNzdlYzk0MGRhZTNhZjhlNjk5NjllMGQ2">二叉树的最近公共祖先【基础算法精讲 12】_哔哩哔哩_bilibili</span></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/236-03.png" width="500"></p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for a binary tree node.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class TreeNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, x):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = x</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.left = None</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">#         self.right = None</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> p<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">,</span> q<span class="token punctuation">:</span> <span class="token string">'TreeNode'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'TreeNode'</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">if</span> root <span class="token operator">==</span> <span class="token boolean">None</span> <span class="token keyword">or</span> root <span class="token operator">==</span> p <span class="token keyword">or</span> root <span class="token operator">==</span> q<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">return</span> root</pre></td></tr><tr><td data-num="12"></td><td><pre>        left <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        right <span class="token operator">=</span> self<span class="token punctuation">.</span>lowestCommonAncestor<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> right <span class="token keyword">and</span> left<span class="token punctuation">:</span> <span class="token keyword">return</span> root</pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token keyword">return</span> left <span class="token keyword">or</span> right</pre></td></tr></table></figure></div><h3 id="199-二叉树的右视图"><a class="anchor" href="#199-二叉树的右视图">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv">199. 二叉树的右视图</span></h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code> ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><details class="info"><summary>示例</summary><div><p><strong>示例 1：</strong></p><p><strong>输入：</strong> root = [1,2,3,null,5,null,4]</p><p><strong>输出：</strong>[1,3,4]</p><p><strong>解释：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/199-01.png" width="300"></p><p><strong>示例 2：</strong></p><p>** 输入：**root = [1,2,3,4,null,null,null,5]</p><p><strong>输出：</strong>[1,3,4,5]</p><p><strong>解释：</strong></p><p><img data-src="/2025/08/15/2025-08-15-Leetcode/199-02.png" width="300"></p><p><strong>示例 3：</strong></p><p>** 输入：**root = [1,null,3]</p><p><strong>输出：</strong>[1,3]</p></div></details><div class="note info no-icon"><div class="tab" data-id="id4" data-title="深度优先算法"><p><strong>视频讲解</strong>：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMThNNDExejdiYi8=">【基础算法精讲 10】</span></p><p><strong>思路</strong>：先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for a binary tree node.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class TreeNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = val</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.left = left</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">#         self.right = right</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> depth<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> </pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token keyword">if</span> depth <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            dfs<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">return</span> result</pre></td></tr></table></figure><p>作者：灵茶山艾府<br>链接：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcvc29sdXRpb25zLzIwMTUwNjEvcnUtaGUtbGluZy1odW8teXVuLXlvbmctZGktZ3VpLWxhaS1rYW4tcy1yMW5jLw==">https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/</span></p></div><div class="tab" data-id="id4" data-title="层序遍历"><p><strong>思路</strong>：将每层的元素加入队列，从右到左依序遍历每层。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># Definition for a binary tree node.</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment"># class TreeNode:</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">#     def __init__(self, val=0, left=None, right=None):</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">#         self.val = val</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">#         self.left = left</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">#         self.right = right</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">rightSideView</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> Optional<span class="token punctuation">[</span>TreeNode<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        que <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>que<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>que<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>que<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="15"></td><td><pre>                node <span class="token operator">=</span> que<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span> que<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span> que<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> result</pre></td></tr></table></figure></div></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-08-18 16:07:46" itemprop="dateModified" datetime="2025-08-18T16:07:46+08:00">2025-08-18</time> </span><span id="2025/08/15/2025-08-15-Leetcode/" class="item leancloud_visitors" data-flag-title="Leetcode刷题记录" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2025/07/17/2025-07-17-Tucker%E5%88%86%E8%A7%A3/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s1.imagehub.cc&#x2F;images&#x2F;2023&#x2F;11&#x2F;16&#x2F;f5aae732ff21e61e4758727176920d75.jpeg" title="Tucker分解"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 工具</span><h3>Tucker分解</h3></a></div><div class="item right"><a href="/2025/08/15/2025-08-15-Leetcode%20-%20%E5%89%AF%E6%9C%AC/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s1.imagehub.cc&#x2F;images&#x2F;2023&#x2F;11&#x2F;16&#x2F;e4b67af1a831d25041ba2dbaad974f93.jpeg" title="Leetcode刷题记录"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 技能工具</span><h3>Leetcode刷题记录</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode%E5%88%B7%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Leetcode 刷题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">数组 &#x2F; 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">1071. 字符串的最大公因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">605. 种花问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#334-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">334. 递增的三元子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1208-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">1208. 尽可能使字符串相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">424. 替换后的最长重复字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.3.</span> <span class="toc-text">前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E4%B8%8B%E6%A0%87"><span class="toc-number">1.3.1.</span> <span class="toc-text">724. 寻找数组的中心下标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2352-%E7%9B%B8%E7%AD%89%E8%A1%8C%E5%88%97%E5%AF%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">2352. 相等行列对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#735-%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E"><span class="toc-number">1.4.1.</span> <span class="toc-text">735. 小行星碰撞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">394. 字符串解码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#649-dota2-%E5%8F%82%E8%AE%AE%E9%99%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">649. Dota2 参议院</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2095-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="toc-number">1.5.1.</span> <span class="toc-text">2095. 删除链表的中间节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">328. 奇偶链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2130-%E9%93%BE%E8%A1%A8%E6%9C%80%E5%A4%A7%E5%AD%AA%E7%94%9F%E5%92%8C"><span class="toc-number">1.5.3.</span> <span class="toc-text">2130. 链表最大孪生和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.6.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii"><span class="toc-number">1.6.1.</span> <span class="toc-text">437. 路径总和 III（与 560. 和为 K 的子数组方法相似）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1372-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">1372. 二叉树中的最长交错路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">1.6.3.</span> <span class="toc-text">236. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">1.6.4.</span> <span class="toc-text">199. 二叉树的右视图</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2023/12/06/2023-12-06_%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="bookmark" title="特征图可视化">特征图可视化</a></li><li><a href="/2025/08/15/2025-08-15-Leetcode%20-%20%E5%89%AF%E6%9C%AC/" rel="bookmark" title="Leetcode刷题记录">Leetcode刷题记录</a></li><li class="active"><a href="/2025/08/15/2025-08-15-Leetcode/" rel="bookmark" title="Leetcode刷题记录">Leetcode刷题记录</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Hening" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Hening</p><div class="description" itemprop="description">终有弱水替沧海 再无相思寄巫山</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">17</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">10</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0hueTEyMTY=" title="https:&#x2F;&#x2F;github.com&#x2F;Hny1216"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmhlbmluZzI1QG1haWwyLnN5c3UuZWR1LmNu" title="mailto:hening25@mail2.sysu.edu.cn"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/amusement/" rel="section"><i class="ic i-magic"></i>摸鱼</a></li><li class="item"><a href="/logging/" rel="section"><i class="ic i-file"></i>日志</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2025/07/17/2025-07-17-Tucker%E5%88%86%E8%A7%A3/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2025/08/15/2025-08-15-Leetcode%20-%20%E5%89%AF%E6%9C%AC/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Hening @ Hening</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">196k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:58</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/08/15/2025-08-15-Leetcode/",favicon:{show:"Hening",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>