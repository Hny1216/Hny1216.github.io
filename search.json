[{"title":"3 状态方程的解","url":"/2023/10/29/现代控制理论/2023-10-29-状态方程的解/","content":"\n# 3 状态方程的解\n\n## 线性时不变系统奇次状态方程的解\n\n对于$n$维线性时不变系统状态方程：$\\bold{\\dot{x}}=\\bold{Ax}(t)+\\bold{Bu}(t)$，系统状态方程的解即为系统的运动。当控制输入为$0$时对应的奇次状态方程 $\\bold{\\dot{x}}=\\bold{Ax}(t)$ 的解为系统的自由运动。\n\n对于标量一阶微分方程的奇次方程 $\\dot{x}=ax(t)$，若初始时刻为$t_0$，则方程的解为$x(t)=e^{a(t-t_0)}x(t_0)$，其中指数函数展开为无穷级数：$e^{a(t-t_0)}=\\sum^{+\\infty}_{n=0}\\frac{1}{n!}a^n(t-t_0)^n$。\n\n拓展到矢量一阶微分方程的奇次方程 $\\bold{\\dot{x}}=\\bold{Ax}(t)$ ，解可以表示为$\\bold{x}(t)=e^{\\bold{A}(t-t_0)}\\bold{x}(t_0)$，其中$e^{\\bold{A}(t-t_0)}=\\sum^{+\\infty}_{n=0}\\frac{1}{n!}\\bold{A}^n(t-t_0)^n$，称为矩阵指数。\n\n## 矩阵指数\n\n矩阵指数函数表示为：$e^{\\bold{A}(t)}=\\sum^{+\\infty}_{n=0}\\frac{1}{n!}\\bold{A}^n(t)^n$，即输入为$0$时的解（零输入响应）。\n\n### 矩阵指数的性质\n\n1.矩阵指数的导数：$\\frac{d}{dt}e^{\\bold{A}t}=\\bold{A}e^{\\bold{A}t}=e^{\\bold{A}t}\\bold{A}$\n\n2.对于$n\\times{n}$阶方阵$\\bold{A}$和$\\bold{B}$，若$\\bold{A}\\bold{B}=\\bold{B}\\bold{A}$，则$e^{(\\bold{A}+\\bold{B})t}=e^{\\bold{A}t}e^{\\bold{B}t}$。\n\n3.若$t_1$与$t_2$为独立的自变量，则$e^{\\bold{A}(t_1+t_2)}=e^{\\bold{A}t_1}e^{\\bold{A}t_2}$。\n\n4.$e^{\\bold{A}*0}=\\bold{I}$。\n\n5.$e^{\\bold{A}t}e^{\\bold{-A}t}=\\bold{I}$。\n\n6.$e^{\\bold{P}^{-1}\\bold{A}\\bold{P}}=\\bold{P}^{-1}e^{\\bold{A}}\\bold{P}$。\n\n7.$lim_{t\\to0}e^{\\bold{A}t}=\\bold{I}$。\n\n8.若$\\bold{A}$为对角矩阵，即$\\bold{A}=\\begin{bmatrix} \\lambda_1&0&\\cdots&0\\\\ 0&\\lambda_2&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&\\lambda_n\\end{bmatrix}$，则$e^{\\bold{A}t}=\\begin{bmatrix} e^{\\lambda_1t}&0&\\cdots&0\\\\ 0&e^{\\lambda_2t}&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&e^{\\lambda_nt}\\end{bmatrix}$。\n\n+++ 证明\n\n$e^{\\bold{A}t}=\\bold{I}+\\bold{A}t+\\frac{1}{2!}\\bold{A}^2t^2+\\cdots$\n\n$=\\begin{bmatrix} 1&0&\\cdots&0\\\\ 0&1&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&1\\end{bmatrix}+\\begin{bmatrix} \\lambda_1&0&\\cdots&0\\\\ 0&\\lambda_2&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&\\lambda_n\\end{bmatrix}t+\\frac{1}{2!}\\begin{bmatrix} \\lambda_1^2&0&\\cdots&0\\\\ 0&\\lambda_2^2&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&\\lambda_n^2\\end{bmatrix}t^2+\\cdots$\n\n$=\\begin{bmatrix} \\sum^{+\\infty}_{n=0}\\frac{1}{n!}\\lambda_1^nt^n&0&\\cdots&0\\\\ 0&\\sum^{+\\infty}_{n=0}\\frac{1}{n!}\\lambda_2^nt^n&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&\\sum^{+\\infty}_{n=0}\\frac{1}{n!}\\lambda_n^nt^n\\end{bmatrix}=\\begin{bmatrix} e^{\\lambda_1t}&0&\\cdots&0\\\\ 0&e^{\\lambda_2t}&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&e^{\\lambda_nt}\\end{bmatrix}$\n\n+++\n\n9.若$\\bold{A}$为$m\\times{m}$的若尔当块，即$\\bold{A}=\\begin{bmatrix} \\lambda&1&0&\\cdots&0\\\\ 0&\\lambda&1&\\cdots&0\\\\  \\vdots&\\vdots&\\lambda&\\ddots&\\vdots\\\\0&0&\\cdots&\\lambda&1\\\\ 0&0&\\cdots&0&\\lambda\\end{bmatrix}_{m\\times{m}}$，则$e^{\\bold{A}t}=e^{\\lambda t}\\begin{bmatrix} 1&t&\\frac{t^{2}}{2!}&\\cdots&\\frac{t^{m-1}}{(m-1)!}\\\\ 0&1&t&\\cdots&\\frac{t^{m-2}}{(m-2)!}\\\\  \\vdots&\\vdots&\\ddots&\\ddots&\\vdots\\\\0&0&\\cdots&1&t\\\\ 0&0&\\cdots&0&1\\end{bmatrix}_{m\\times{m}}$。\n\n+++ 若尔当块\n\n形如$\\begin{bmatrix} \\lambda&1&0&\\cdots&0\\\\ 0&\\lambda&1&\\cdots&0\\\\  \\vdots&\\vdots&\\lambda&\\ddots&\\vdots\\\\0&0&\\cdots&\\lambda&1\\\\ 0&0&\\cdots&0&\\lambda\\end{bmatrix}_{m\\times{m}}$为$m$阶若尔当矩阵，1阶若尔当矩阵为$\\lambda$。\n\n+++\n\n10.若$\\bold{A}$为一个有多个若尔当块的若尔当矩阵（即若当标准型），即$\\bold{A}=\\begin{bmatrix} \\bold{A}_1&0&\\cdots&0\\\\ 0&\\bold{A}_2&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&\\bold{A}_n\\end{bmatrix}$，则$e^{\\bold{A}t}=\\begin{bmatrix} e^{\\bold{A}_1t}&0&\\cdots&0\\\\ 0&e^{\\bold{A}_2t}&\\cdots&0\\\\  \\vdots&\\vdots&\\ddots&\\vdots\\\\ 0&0&\\cdots&e^{\\bold{A}_nt}\\end{bmatrix}$。\n\n### 矩阵指数的计算\n\n1.定义计算：$e^{\\bold{A}t}=\\sum^{+\\infty}_{n=0}\\frac{1}{n!}\\bold{A}^n(t)^n$。该方法适用于计算机运算。\n\n+++info  例题\n\n;;;id1 例题1\n\n:::info \n\n已知$\\bold{A}=\\begin{bmatrix} 0&1\\\\-1&0\\end{bmatrix}$，求$e^{\\bold{A}t}$。\n\n:::\n\n由定义，$e^{\\bold{A}t}=\\bold{I}+\\bold{A}t+\\frac{1}{2!}+\\cdots=\\begin{bmatrix}1&0\\\\0&1\\end{bmatrix}+\\begin{bmatrix}0&t\\\\-t&0\\end{bmatrix}+\\frac{1}{2!}\\begin{bmatrix}-t^2&0\\\\0&-t^2\\end{bmatrix}+\\cdots=\\begin{bmatrix}1-\\frac{t^2}{2!}+\\cdots&t-\\frac{t^3}{3!}+\\cdots\\\\-t+\\frac{t^3}{3!}-\\cdots&1-\\frac{t^2}{2!}+\\cdots\\end{bmatrix}=\\begin{bmatrix} \\cos{t}&\\sin{t}\\\\-\\sin{t}&\\cos{t}\\end{bmatrix}$\n\n;;; \n\n+++\n\n2.拉氏变换法：利用拉氏变换在频域中求解齐次状态方程的解。\n\n设线性时不变齐次状态方程为 $\\bold{\\dot{x}}=\\bold{Ax}(t)$，$\\bold{x}(0)=\\bold{x}_0$，$t\\geq{t_0}$。作拉氏变换有 $s\\bold{X}(s)-\\bold{x}(0)=\\bold{AX}(s)$，即 $(s\\bold{I}-\\bold{A})\\bold{X}(s)=\\bold{x}(0)$，那么 $\\bold{X}(s) =(s\\bold{I}-\\bold{A})^{-1}\\bold{x}(0)$，取拉氏逆变换有 $\\bold{x}(0)=L^{-1}[(s\\bold{I}-\\bold{A})^{-1}\\bold{x}(0)]=L^{-1}[(s\\bold{I}-\\bold{A})^{-1}]\\bold{x}(0)$，因此 $e^{\\bold{A}t}=L^{-1}[(s\\bold{I}-\\bold{A})^{-1}]$。\n\n+++info 例题\n\n;;;id2 例题1\n\n:::info\n\n计算矩阵 $\\bold{A}=\\begin{bmatrix}0&1\\\\-2&-3\\end{bmatrix}$的矩阵指数。\n\n:::\n\n由拉氏变换法，$(s\\bold{I}-\\bold{A})=\\begin{bmatrix} s&-1\\\\2&s+3\\end{bmatrix}$，则$(s\\bold{I}-\\bold{A})^{-1}=\\begin{bmatrix}\\frac{s+3}{(s+1)(s+2)}&\\frac{1}{(s+1)(s+2)}\\\\\\frac{-2}{(s+1)(s+2)}&\\frac{s}{(s+1)(s+2)}\\end{bmatrix}$，\n\n则 $e^{\\bold{A}t}=L^{-1}\\begin{bmatrix}\\frac{s+3}{(s+1)(s+2)}&\\frac{1}{(s+1)(s+2)}\\\\\\frac{-2}{(s+1)(s+2)}&\\frac{s}{(s+1)(s+2)}\\end{bmatrix}=\\begin{bmatrix}2e^{-t}&e^{-t}-e^{-2t}\\\\-2e^{-t}+2e^{-2t}&-e^{-t}+2e^{-2t}\\end{bmatrix}$。\n\n;;;\n\n+++\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n+++ Tips\n\n中山大学\n\n+++\n\n\n\n+++primary 证明\n\n$\\dot{x}=ax(t)$，若初始时刻为\n\n+++\n\n\n\n+++info  蓝色 \n\n;;;id3 例题1\n\n这里是卡片 1 的内容 \n\n;;; \n\n;;;id3 例题2\n\n这里是卡片 2 的内容 \n\n;;; \n\n+++","categories":["现代控制理论"]},{"title":"Realistic fault detection of li-ion battery via dynamical deep learning","url":"/2023/10/21/论文文献阅读/2023-10-09 Realistic fault detection of li-ion battery via dynamical deep learning/","content":"\n# Realistic fault detection of li-ion battery via dynamical deep learning\n\nArticle link: [Realistic fault detection of li-ion battery via dynamical deep learning (nature.com)](https://www.nature.com/articles/s41467-023-41226-5.pdf)\n\nlocal link: [Realistic fault detection of li-ion battery via dynamical deep learning](/downloads/2023-10-09_Realistic-fault-detection-of-li-ion-battery-via-dynamical-deep-learning.pdf)\n\nDate: 2023-10-09\n\n## 1.论文主旨\n\n​\t文章针对当前电池动力电池数据的隐私以及成本问题，提出了一种现实可应用的深度学习框架模型（动态自编码异常检测，`Dynamical autoencoder for Anomaly Detection`, `DyAD` ），并且公布了347个电动汽车的690000个[锂电池充电片段数据](https://figshare.com/articles/dataset/Realistic_fault_detection_of_Li-ion_battery_via_dynamical_deep_learning_approach/23659323)。\n\n​\t此前研究面临的问题主要有：（1）传统的数据使用方法（温度、电压的方差等）难以辨认异常与正常汽车，数据关联性表现较弱，ROC在0.5左右；（2）数据直接上传容易泄露，用户隐私难以保护；为此，文章提出了一种可大规模使用的定制深度学习框架。\n\n### 1.1.模型建模\n\n​\t不直接上传用户的各项直接数据，而是将用户数据分为系统输入（电流，SOC）和系统响应（电压，温度）两部分，而后在充电站部署编码器，编码器学习系统输入到系统响应的映射关系，编码后的数据上传到云端经过解码后对电动汽车的异常是否做出检测。通过编码-解码架构避免了用户的隐私和厂商的模型细节泄露。\n\n### 1.2.建模细节\n\n​\t问题1：传统的深度学习方法通过研究数据分布来检测异常，对不常见的数据表现出较差的检测效果（如恒流充电数据，可能会被误判为正常电池）。\n\n​\t解决方法：在自编码-解码器中，编码器保持不变，编码器学习系统输入和系统响应的映射关系后得到潜在变量；而解码器不再仅仅利用潜在变量进行解码，而是通过潜在变量以及系统输入进行解码。具体理解如下：编码器学习到系统输入与系统响应的映射关系，那么可以用`y=f(x)`来表示这一过程，其中`y`是系统响应，`x`是系统输入，而编码器正是通过`x`和`y`学习到映射函数`f`。传统方法便是将`f`得到的潜在变量直接做出检测。然而本文构造了一个解码器`f1`来模型物理系统，通过系统输入`x`重构了系统响应`y1=f1(x)`,对比真实响应`y`和重构响应`y1`得到重构误差损失。其次通过里程进行弱监督从而引入辅助损失，引入KL正则化防止过拟合。三个损失函数共同影响模型的训练过程以及样本的异常情况。\n\n​\t模型包含了三组参数，分别是编码器参数$\\theta$，解码器参数$\\zeta$和多感知机头部参数$\\xi$，前两组参数均通过图卷积神经网络参数化得到。三个损失函数分别定义为：$l_{recon.}$，$l_{reg.}$，$l_{mileage}$。\n\n\n\n\n\n\n\n## 2.复现\n\n### 2.1.数据集\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["论文文献阅读"]},{"title":"My Article","url":"/2023/10/21/现代控制理论/My-new-Art/","content":"\n这是摘要部分。\n\n<!-- more -->\n\n# 这是全文内容。\n\n## 中山大学\n\n在那边\n\n\n\n```python\nimport numpy\n```\n\n\n\n```\n```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7 \nimport java.util.Scanner; \n... \nScanner in = new Scanner (System.in); // 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。 \nSystem.out.println (in.nextLine ()); System.out.println (\"Hello\" + \"world.\"); ```\n```\n\n```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7 import java.util.Scanner; ... Scanner in = new Scanner (System.in); // 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。 System.out.println (in.nextLine ()); System.out.println (\"Hello\" + \"world.\"); ```\n\n```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7\nimport java.util.Scanner; \n... \nScanner in = new Scanner (System.in); // 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。 \nSystem.out.println (in.nextLine ()); \nSystem.out.println (\"Hello\" + \"world.\"); ```\n```\n\n\n\n```java 行高亮 https://laoevil.gitee.io 参考链接 mark:1,6-7 import java.util.Scanner; ... Scanner in = new Scanner (System.in); // 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。 System.out.println (in.nextLine ()); System.out.println (\"Hello\" + \"world.\"); ```\n\n\n\n```markdown\n|             |          Grouping           || \nFirst Header  | Second Header | Third Header | \n------------ | :-----------: | -----------: | \nContent       |          *Long Cell*        || \nContent       |   **Cell**    |         Cell |     \n\nNew section   |     More      |         Data | \nAnd more      | With an escaped '\\\\|'       || \n[Prototype table]\n```\n\n1. 编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 {.quiz .true}\n\n2. 有基类 `SHAPE`，派生类 `CIRCLE`，声明如下变量：  {.quiz .multi}\n    ```cpp\n    SHAPE shape1,*p1;\n    CIRCLE circle1,*q1;\n    ```\n    下列哪些项是 “派生类对象替换基类对象”。\n    - `p1=&circle1;` {.correct}\n    - `q1=&shape1;`\n    - `shape1=circle1;` {.correct}\n    - `circle1=shape1;`\n    {.options}\n    > - :heavy_check_mark: 令基类对象的指针指向派生类对象\n    > - :x: 派生类指针指向基类的引用\n    > - :heavy_check_mark: 派生类对象给基类对象赋值\n    > - :x: 基类对象给派生类对象赋值\n    > {.options}\n\n3. 下列叙述正确的是 []{.gap} 。 {.quiz}\n    - 虚函数只能定义成无参函数\n    - 虚函数不能有返回值\n    - 能定义虚构造函数\n    - A、B、C 都不对 {.correct}\n    {.options}\n\n10. 如果定义 `int e=8; double f=6.4, g=8.9;`，则表达式 `f+int (e/3*int (f+g)/2)%4` 的值为 [9.4]{.gap}。 {.quiz .fill}\n    > 注意运算顺序和数据类型\n    > [8.4]{.mistake}\n","tags":["test"],"categories":["现代控制理论"]},{"title":"My Article","url":"/2023/10/21/自动控制原理/My-new-Art/","content":"\n这是摘要部分。\n\n<!-- more -->\n\n# 这是全文内容。\n\n## 中山大学\n\n在那边\n\n\n\n```python\nimport numpy\n```\n\n\n\n```\n```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7 \nimport java.util.Scanner; \n... \nScanner in = new Scanner (System.in); // 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。 \nSystem.out.println (in.nextLine ()); System.out.println (\"Hello\" + \"world.\"); ```\n```\n\n```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7 import java.util.Scanner; ... Scanner in = new Scanner (System.in); // 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。 System.out.println (in.nextLine ()); System.out.println (\"Hello\" + \"world.\"); ```\n\n```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7\nimport java.util.Scanner; \n... \nScanner in = new Scanner (System.in); // 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。 \nSystem.out.println (in.nextLine ()); \nSystem.out.println (\"Hello\" + \"world.\"); ```\n```\n\n\n\n```java 行高亮 https://laoevil.gitee.io 参考链接 mark:1,6-7 import java.util.Scanner; ... Scanner in = new Scanner (System.in); // 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。 System.out.println (in.nextLine ()); System.out.println (\"Hello\" + \"world.\"); ```\n\n\n\n```markdown\n|             |          Grouping           || \nFirst Header  | Second Header | Third Header | \n------------ | :-----------: | -----------: | \nContent       |          *Long Cell*        || \nContent       |   **Cell**    |         Cell |     \n\nNew section   |     More      |         Data | \nAnd more      | With an escaped '\\\\|'       || \n[Prototype table]\n```\n\n1. 编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 {.quiz .true}\n\n2. 有基类 `SHAPE`，派生类 `CIRCLE`，声明如下变量：  {.quiz .multi}\n    ```cpp\n    SHAPE shape1,*p1;\n    CIRCLE circle1,*q1;\n    ```\n    下列哪些项是 “派生类对象替换基类对象”。\n    - `p1=&circle1;` {.correct}\n    - `q1=&shape1;`\n    - `shape1=circle1;` {.correct}\n    - `circle1=shape1;`\n    {.options}\n    > - :heavy_check_mark: 令基类对象的指针指向派生类对象\n    > - :x: 派生类指针指向基类的引用\n    > - :heavy_check_mark: 派生类对象给基类对象赋值\n    > - :x: 基类对象给派生类对象赋值\n    > {.options}\n\n3. 下列叙述正确的是 []{.gap} 。 {.quiz}\n    - 虚函数只能定义成无参函数\n    - 虚函数不能有返回值\n    - 能定义虚构造函数\n    - A、B、C 都不对 {.correct}\n    {.options}\n\n10. 如果定义 `int e=8; double f=6.4, g=8.9;`，则表达式 `f+int (e/3*int (f+g)/2)%4` 的值为 [9.4]{.gap}。 {.quiz .fill}\n    > 注意运算顺序和数据类型\n    > [8.4]{.mistake}\n","tags":["test"],"categories":["自动控制原理"]}]