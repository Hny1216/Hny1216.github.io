[{"title":"Realistic fault detection of li-ion battery via dynamical deep learning","url":"/2023/10/21/2023-10-09_Realistic-fault-detection-of-li-ion-battery-via-dynamical-deep-learning/","content":"<p>基于动态自编码网络的电池故障检测</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Realistic-fault-detection-of-li-ion-battery-via-dynamical-deep-learning\"><a href=\"#Realistic-fault-detection-of-li-ion-battery-via-dynamical-deep-learning\" class=\"headerlink\" title=\"Realistic fault detection of li-ion battery via dynamical deep learning\"></a>Realistic fault detection of li-ion battery via dynamical deep learning</h1><p>Article link: <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubmF0dXJlLmNvbS9hcnRpY2xlcy9zNDE0NjctMDIzLTQxMjI2LTUucGRm\">Realistic fault detection of li-ion battery via dynamical deep learning (nature.com)</span></p>\n<p>local link: <a href=\"/downloads/2023-10-09_Realistic-fault-detection-of-li-ion-battery-via-dynamical-deep-learning.pdf\">Realistic fault detection of li-ion battery via dynamical deep learning</a></p>\n<p>Date: 2023-10-09</p>\n<h2 id=\"1-论文主旨\"><a href=\"#1-论文主旨\" class=\"headerlink\" title=\"1.论文主旨\"></a>1.论文主旨</h2><p>​\t文章针对当前电池动力电池数据的隐私以及成本问题，提出了一种现实可应用的深度学习框架模型（动态自编码异常检测，Dynamical autoencoder for Anomaly Detection, DyAD ），并且公布了347个电动汽车的690000个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9maWdzaGFyZS5jb20vYXJ0aWNsZXMvZGF0YXNldC9SZWFsaXN0aWNfZmF1bHRfZGV0ZWN0aW9uX29mX0xpLWlvbl9iYXR0ZXJ5X3ZpYV9keW5hbWljYWxfZGVlcF9sZWFybmluZ19hcHByb2FjaC8yMzY1OTMyMw==\">锂电池充电片段数据</span>。</p>\n<p>​\t此前研究面临的问题主要有：（1）传统的数据使用方法（温度、电压的方差等）难以辨认异常与正常汽车，数据关联性表现较弱，ROC在0.5左右；（2）数据直接上传容易泄露，用户隐私难以保护；为此，文章提出了一种可大规模使用的定制深度学习框架。</p>\n<h3 id=\"1-1-模型建模\"><a href=\"#1-1-模型建模\" class=\"headerlink\" title=\"1.1.模型建模\"></a>1.1.模型建模</h3><p>​\t不直接上传用户的各项直接数据，而是将用户数据分为系统输入（电流，SOC）和系统响应（电压，温度）两部分，而后在充电站部署编码器，编码器学习系统输入到系统响应的映射关系，编码后的数据上传到云端经过解码后对电动汽车的异常是否做出检测。通过编码-解码架构避免了用户的隐私和厂商的模型细节泄露。</p>\n<h3 id=\"1-2-建模细节\"><a href=\"#1-2-建模细节\" class=\"headerlink\" title=\"1.2.建模细节\"></a>1.2.建模细节</h3><p>​\t问题1：传统的深度学习方法通过研究数据分布来检测异常，对不常见的数据表现出较差的检测效果（如恒流充电数据，可能会被误判为正常电池）。</p>\n<p>​\t解决方法：在自编码-解码器中，编码器保持不变，编码器学习系统输入和系统响应的映射关系后得到潜在变量；而解码器不再仅仅利用潜在变量进行解码，而是通过潜在变量以及系统输入进行解码。具体理解如下：编码器学习到系统输入与系统响应的映射关系，那么可以用$y&#x3D;f(x)$来表示这一过程，其中$y$是系统响应，$x$是系统输入，而编码器正是通过$x$和$y$学习到映射函数$f$。传统方法便是将$f$得到的潜在变量直接做出检测。然而本文构造了一个解码器$f_1$来模型物理系统，通过系统输入$x$重构了系统响应$y_1&#x3D;f_1(x)$,对比真实响应$y$和重构响应$y_1$得到重构误差损失。其次通过里程进行弱监督从而引入辅助损失，引入KL正则化防止过拟合。三个损失函数共同影响模型的训练过程以及样本的异常情况。</p>\n<p>​\t模型包含了三组参数，分别是编码器参数$\\theta$，解码器参数$\\zeta$和多感知机头部参数$\\xi$，前两组参数均通过图卷积神经网络参数化得到。三个损失函数分别定义为：$l_{recon.}$，$l_{reg.}$，$l_{mileage}$。</p>\n<h2 id=\"2-复现\"><a href=\"#2-复现\" class=\"headerlink\" title=\"2.复现\"></a>2.复现</h2><p>数据集以及代码的连接如下：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kaXNrLnBrdS5lZHUuY24vIy9saW5rLzM3RDczM0RGNDA1RDhENzk5OEI4RjU3RTQ0ODc1MTVB\">Code with datasets</span></p>\n<h3 id=\"2-1-数据集\"><a href=\"#2-1-数据集\" class=\"headerlink\" title=\"2.1.数据集\"></a>2.1.数据集</h3><p>数据可视化处理过程代码<a href=\"/downloads/Code_2023-10-09_data-visualization.zip\">下载链接</a>。</p>\n<h3 id=\"2-2-模型\"><a href=\"#2-2-模型\" class=\"headerlink\" title=\"2.2 模型\"></a>2.2 模型</h3><h3 id=\"2-3-代码细节\"><a href=\"#2-3-代码细节\" class=\"headerlink\" title=\"2.3 代码细节\"></a>2.3 代码细节</h3><p>从代码角度来看，这个代码写的太牛辣。那我们就来好好欣赏一下这优雅的代码吧。</p>\n","categories":["论文文献阅读"]},{"title":"02 控制系统的状态空间描述","url":"/2023/10/21/2023-10-21-%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0/","content":"<p>现代控制理论——02 控制系统的状态空间描述</p>\n<span id=\"more\"></span>\n\n<h1 id=\"控制系统的状态空间描述\"><a href=\"#控制系统的状态空间描述\" class=\"headerlink\" title=\"控制系统的状态空间描述\"></a>控制系统的状态空间描述</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"系统的状态空间模型\"><a href=\"#系统的状态空间模型\" class=\"headerlink\" title=\"系统的状态空间模型\"></a>系统的状态空间模型</h3><ol>\n<li>线性时变系统的状态空间模型：系数矩阵与时间无关。</li>\n</ol>\n<p>$$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.   \\tag{1}$$</p>\n<p>其中，$u&#x3D;R^r$为输入向量；$y&#x3D;R^m$为输出向量；$x\\in R^n$为状态向量。$A,B,C,D$为系数矩阵。</p>\n<ol start=\"2\">\n<li>线性时不变系统的状态空间模型：系数矩阵与时间有关。</li>\n</ol>\n<p>$$\\left{ \\begin{matrix} \\dot{x}&#x3D;A(t)x+B(t)u\\y&#x3D;C(t)x+D(t)u\\\\end{matrix}\\right.   \\tag{2}$$</p>\n<ol start=\"3\">\n<li>离散线性系统的状态空间模型。</li>\n</ol>\n<p>$$\\left{ \\begin{matrix} x(k+1)&#x3D;A(k)x(k)+B(k)u(k)\\y(k)&#x3D;C(k)x(k)+D(k)u(k)\\\\end{matrix}\\right.   \\tag{3}$$</p>\n<h3 id=\"状态空间描述的特点\"><a href=\"#状态空间描述的特点\" class=\"headerlink\" title=\"状态空间描述的特点\"></a>状态空间描述的特点</h3><ol>\n<li>系统的状态变量的个数&#x3D;系统中包含的独立储能元件的个数&#x3D;系统的阶数。</li>\n<li>在给定的系统中，状态变量的选择不唯一，但是状态变量的个数是一致的。</li>\n<li>基于状态变量选取的不同，同一系统可以用不同的动态方程来描述。</li>\n</ol>\n<p>+++primary 证明</p>\n<p>对于一个状态方程$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx\\\\end{matrix}\\right.$，选择非奇异矩阵$P\\in R^{n\\times n}$作为变换阵，有$x&#x3D;P\\overline{x}$，那么此时状态方程可表示为：</p>\n<p>$$\\dot{\\overline{x}}&#x3D;P^{-1}\\dot{x}&#x3D;P^{-1}[Ax+Bu]&#x3D;P^{-1}AP\\overline{x}+P^{-1}Bu&#x3D;\\overline{A}\\overline{x}+\\overline{B}u   \\tag{4}$$</p>\n<p>$$y&#x3D;Cx&#x3D;CP\\overline{x}&#x3D;\\overline{C}\\overline{x}    \\tag{5}$$、】</p>\n<p>4</p>\n<p>其中，$\\overline{A}&#x3D;P^{-1}AP,\\overline{B}&#x3D;P^{-1}B,\\overline{C}&#x3D;CP$。</p>\n<p>因此当状态变量 $x$ 改变时，一定存在变换矩阵 $P$ 使得状态方程发生变化。</p>\n<p>+++</p>\n<h3 id=\"状态空间模型的建立步骤\"><a href=\"#状态空间模型的建立步骤\" class=\"headerlink\" title=\"状态空间模型的建立步骤\"></a>状态空间模型的建立步骤</h3><ol>\n<li>选择状态变量。</li>\n<li>根据物体或其他机理列写微分方程。</li>\n<li>转化为矩阵形式，得到状态空间模型。</li>\n</ol>\n<h3 id=\"状态空间表达式的系统方框图\"><a href=\"#状态空间表达式的系统方框图\" class=\"headerlink\" title=\"状态空间表达式的系统方框图\"></a>状态空间表达式的系统方框图</h3><p>公式（1）是线性时不变系统状态空间表达式的一般形式。其系统方框图可表示如下：</p>\n<img data-src=\"/2023/10/21/2023-10-21-%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0/01%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE.png\" class=\"\">\n\n<h3 id=\"状态空间表达式的状态变量图\"><a href=\"#状态空间表达式的状态变量图\" class=\"headerlink\" title=\"状态空间表达式的状态变量图\"></a>状态空间表达式的状态变量图</h3><ol>\n<li>状态变量图的基本元素符号</li>\n</ol>\n<img data-src=\"/2023/10/21/2023-10-21-%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0/02%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E5%8F%98%E9%87%8F%E5%9B%BE.png\" class=\"\">\n\n<ol start=\"2\">\n<li>绘制步骤</li>\n</ol>\n<ul>\n<li><strong>绘制积分器</strong>  积分器数量等于状态变量数目。</li>\n<li><strong>由状态方程和输出方程绘制加法器和放大器</strong></li>\n<li><strong>连接各元件</strong></li>\n</ul>\n<p>+++info 例题</p>\n<p>;;;id1 例题1</p>\n<p>:::info no-icon</p>\n<p>设有三阶系统状态空间表达式如下，试绘制其状态变量图。</p>\n<p>$$\\left{ \\begin{aligned}\\begin{matrix} \\dot{x}_1&#x3D;x_2\\\\dot{x}_2&#x3D;x_3\\\\dot{x}_3&#x3D;-6x_1-3x_2-2x_3+u\\y&#x3D;x_1+x_2\\end{matrix}\\end{aligned}\\right.$$</p>\n<p>:::</p>\n<p>其状态变量图可绘制如下：</p>\n<img data-src=\"/2023/10/21/2023-10-21-%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0/03%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E5%8F%98%E9%87%8F%E5%9B%BE.png\" class=\"\">\n\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"传递函数和传递函数矩阵\"><a href=\"#传递函数和传递函数矩阵\" class=\"headerlink\" title=\"传递函数和传递函数矩阵\"></a>传递函数和传递函数矩阵</h2><h3 id=\"单输入单输出系统\"><a href=\"#单输入单输出系统\" class=\"headerlink\" title=\"单输入单输出系统\"></a>单输入单输出系统</h3><p>对于单输入单输出系统$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.$，在零初始条件下其传递函数可表示为：</p>\n<p>$$g(s)&#x3D;\\frac{Y(s)}{U(s)}&#x3D;C(sI-A)^{-1}B+D    \\tag{6}$$</p>\n<p>+++primary 推导</p>\n<p>在系统$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.$ 中，在零初始条件下取拉氏变换有：$\\left{ \\begin{matrix} sX(s)&#x3D;AX(s)+BU(s)\\Y(s)&#x3D;CX(s)+DU(s)\\\\end{matrix}\\right.$，整理得到$\\left{ \\begin{matrix} X(s)&#x3D;(sI-A)^{-1}BU(s)\\Y(s)&#x3D;C(sI-A)^{-1}BU(s)+DU(s)\\\\end{matrix}\\right.$，故$g(s)&#x3D;\\frac{Y(s)}{U(s)}&#x3D;C(sI-A)^{-1}B+D$</p>\n<p>+++</p>\n<p>在 $D&#x3D;0$ 时，$g(s)&#x3D;\\frac{Y(s)}{U(s)}&#x3D;C(sI-A)^{-1}B&#x3D;\\frac{Cadj(sI-A)B}{|sI-A|}$，其中$adj(sI-A)$表示矩阵$sI-A$的伴随矩阵。</p>\n<p>对比自控原理中传递函数的表达式：$g(s)&#x3D;\\frac{b_0s^n+b_1s^{n-1}+\\cdots +b_{n-1}s+b_n}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n}$，可知：</p>\n<ol>\n<li>系统矩阵$A$的特征多项式等同于传递函数的分母多项式。</li>\n<li>传递函数的极点就是系统矩阵$A$的特征值。</li>\n<li><strong>传递函数的不变性</strong>  同一系统的状态空间描述不唯一，但传递函数是唯一的。</li>\n</ol>\n<p>+++primary 证明：同一系统的不同状态空间描述具有相同的特征值。</p>\n<p>对于同一系统，选择两个不同的状态向量 $x\\in{R^n}$ 和 $\\overline{x}\\in{R^n}$ 分别得到不同的状态空间描述：</p>\n<p>$$\\begin{matrix}\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.&amp;&amp;&amp;\\left{ \\begin{matrix} \\dot{\\overline{x}}&#x3D;\\overline{A}\\overline{x}+\\overline{B}u\\y&#x3D;\\overline{C}\\overline{x}+\\overline{D}u\\\\end{matrix}\\right.\\end{matrix}$$</p>\n<p>两种状态变量一定存在着可逆变化关系：$x&#x3D;P\\overline{x}$，故：</p>\n<p>$$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.\\Rightarrow \\left{ \\begin{matrix} P\\dot{\\overline{x}}&#x3D;AP\\overline{x}+Bu\\y&#x3D;CP\\overline{x}+Du\\\\end{matrix}\\right.\\Rightarrow \\left{ \\begin{matrix} \\dot{\\overline{x}}&#x3D;P^{-1}AP\\overline{x}+P^{-1}Bu\\y&#x3D;CP\\overline{x}+Du\\\\end{matrix}\\right.$$</p>\n<p>故 $\\overline{A}&#x3D;P^{-1}AP$，所以矩阵 $A$ 与矩阵 $\\overline{A}$ 相似，故特征值相同。</p>\n<p>:::info</p>\n<p>相似矩阵具体相同的特征值</p>\n<p>:::</p>\n<p>+++</p>\n<h3 id=\"多输入多输出系统\"><a href=\"#多输入多输出系统\" class=\"headerlink\" title=\"多输入多输出系统\"></a>多输入多输出系统</h3><p>对于多输入多输出系统，输入向量$u&#x3D;[u_1\\cdots u_p]^T$，输出向量$y&#x3D;[y_1\\dots y_q]^T$。我们把第$i$个输出$y_i$和第$j$个输入$u_j$间的传递函数定义为：$g_{ij}(s)&#x3D;\\frac{Y_i(s)}{U_j(s)}$。故系统的输入输出关系可表示为：</p>\n<p>$$\\begin{bmatrix}Y_1(s)\\Y_2(s)\\\\vdots\\Y_q(s)\\end{bmatrix}&#x3D;\\begin{bmatrix}g_{11}(s)&amp;g_{12}(s)&amp;\\cdots&amp;g_{1p}(s)\\g_{21}(s)&amp;g_{22}(s)&amp;\\cdots&amp;g_{2p}(s)\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\g_{q1}(s)&amp;g_{q2}(s)&amp;\\cdots&amp;g_{qp}(s)\\end{bmatrix}\\begin{bmatrix}U_1(s)\\U_2(s)\\\\vdots\\U_q(s)\\end{bmatrix}$$</p>\n<p>以矩阵的形式表示：$Y(s)&#x3D;G(s)U(s)$，其中 $G(s)$称为传递函数矩阵。</p>\n<p>对于多输入多输出系统$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.$，同样传递函数矩阵为：</p>\n<p>$$G(s)&#x3D;C(sI-A)^{-1}B+D&#x3D;\\frac{Cadj(sI-A)B+D|sI-A|}{|sI-A|}$$</p>\n<p>+++info 例题</p>\n<p>;;;id2 例题1</p>\n<p>:::info no-icon</p>\n<p>已知系统动态方程为$\\begin{bmatrix}\\dot{x}_1\\\\dot{x}_2\\end{bmatrix}&#x3D;\\begin{bmatrix}0&amp;1\\0&amp;-2\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\end{bmatrix}+\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}\\begin{bmatrix}u_1\\u_2\\end{bmatrix}$，$\\begin{bmatrix}y_1\\y_2\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\end{bmatrix}$，试求系统的传递函数矩阵。</p>\n<p>:::</p>\n<p>由题，$G(s)&#x3D;C(sI-A)^{-1}B+D&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}\\begin{bmatrix}\\frac{1}{s}&amp;\\frac{1}{s(s+2)}\\0&amp;\\frac{1}{s+2}\\end{bmatrix}\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}&#x3D;\\begin{bmatrix}\\frac{1}{s}&amp;\\frac{1}{s(s+2)}\\0&amp;\\frac{1}{s+2}\\end{bmatrix}$。</p>\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"建立状态空间表达式\"><a href=\"#建立状态空间表达式\" class=\"headerlink\" title=\"建立状态空间表达式\"></a>建立状态空间表达式</h2><h3 id=\"高阶微分方程化为状态空间描述\"><a href=\"#高阶微分方程化为状态空间描述\" class=\"headerlink\" title=\"高阶微分方程化为状态空间描述\"></a>高阶微分方程化为状态空间描述</h3><p>在单输入单输出线性时不变系统中，系统的输出与输入的关系可用如下高阶微分方程描述：</p>\n<p>$$y^{(n)}+a_1y^{(n-1)}+\\cdots +a_{n-1}\\dot{y}+a_ny&#x3D;b_0u^{(m)}+b_1u^{(m-1)}+\\cdots +b_{m-1}\\dot{u}+b_mu    \\tag{7}$$</p>\n<p>其中，$m\\leq n$。根据微分方程右侧是否含有输入函数的导数（即$m$是否等于0）分两种情况讨论。</p>\n<h4 id=\"常微分方程中不含输入函数的导数\"><a href=\"#常微分方程中不含输入函数的导数\" class=\"headerlink\" title=\"常微分方程中不含输入函数的导数\"></a>常微分方程中不含输入函数的导数</h4><p>若常微分方程中不含有输入函数的导数，即：$y^{(n)}+a_1y^{(n-1)}+\\cdots +a_{n-1}\\dot{y}+a_ny&#x3D;b_mu$。</p>\n<p>那么可以选取状态变量：</p>\n<p>$$x_1&#x3D;\\frac{1}{b_m}y,\\quad x_2&#x3D;\\frac{1}{b_m}\\dot{y},\\quad \\cdots \\quad  x_n&#x3D;\\frac{1}{b_m}y^{(n-1)}      \\tag{8}$$</p>\n<p>那么就可以得到状态方程（前$n-1$条通过求导获得，最后一条通过原微分方程获得）：</p>\n<p>$$\\left{ \\begin{matrix} \\dot{x}_1&#x3D;x_2\\\\dot{x}_2&#x3D;x_3\\\\vdots\\\\dot{x}<em>n&#x3D;y^{(n)}&#x3D;-a_nx_1-a</em>{n-1}x_2-\\cdots -a_1x_n+u\\end{matrix}\\right.$$</p>\n<p>输出方程为：$y&#x3D;b_mx_1$。</p>\n<p>以矩阵的形式可表示为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1&amp;\\cdots &amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;1\\-a_n&amp;-a_{n-1}&amp;\\cdots&amp;-a_1\\end{bmatrix}x+\\begin{bmatrix}0\\0\\\\vdots\\1\\end{bmatrix}u    \\tag{9}$$</p>\n<p>$$y&#x3D;\\begin{bmatrix}1&amp;0&amp;\\cdots&amp;0\\end{bmatrix}x     \\tag{10}$$</p>\n<p>+++primary 能控标准型</p>\n<p>形如公式（9）的状态空间模型称为能控标准型。即$A$与$b$可用以下形式表示：</p>\n<p>$$A&#x3D;\\begin{bmatrix}0&amp;1&amp;\\cdots &amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;1\\-a_n&amp;-a_{n-1}&amp;\\cdots&amp;-a_1\\end{bmatrix},\\quad b&#x3D;\\begin{bmatrix}0\\0\\\\vdots\\1\\end{bmatrix}$$</p>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id3 例题1</p>\n<p>:::info no-icon</p>\n<p>设系统的运动方程为：$y^{(3)}+5\\ddot{y}+8\\dot{y}+6y&#x3D;3u$，试求其状态空间表达式。</p>\n<p>:::</p>\n<p>选取状态变量$x_1&#x3D;y,\\quad x_2&#x3D;\\dot{y},\\quad x_3&#x3D;\\ddot{y}$，则有状态方程：</p>\n<p>$$\\left{ \\begin{matrix} \\dot{x}_1&#x3D;x_2\\\\dot{x}_2&#x3D;x_3\\\\dot{x}_3&#x3D;y^{(3)}&#x3D;-6x_1-8x_2 -5x_3+3u\\end{matrix}\\right.$$</p>\n<p>输出方程为$y&#x3D;x_1$。</p>\n<p>故状态空间表达式为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1 &amp;0\\0&amp;0&amp;1\\-6&amp;-8&amp;-5\\end{bmatrix}x+\\begin{bmatrix}0\\0\\3\\end{bmatrix}u $$</p>\n<p>$$y&#x3D;\\begin{bmatrix}1&amp;0&amp;0\\end{bmatrix}x$$</p>\n<p>;;;</p>\n<p>+++</p>\n<h4 id=\"常微分方程中含有输入函数的导数\"><a href=\"#常微分方程中含有输入函数的导数\" class=\"headerlink\" title=\"常微分方程中含有输入函数的导数\"></a>常微分方程中含有输入函数的导数</h4><p>若常微分方程中含有输入函数的导数，即：$y^{(n)}+a_1y^{(n-1)}+\\cdots +a_{n-1}\\dot{y}+a_ny&#x3D;b_0u^{(m)}+b_1u^{(m-1)}+\\cdots +b_{m-1}\\dot{u}+b_mu$。</p>\n<p>选择状态变量：</p>\n<p>$$\\left{ \\begin{matrix} x_1&#x3D;y-\\beta_0u\\x_2&#x3D;\\dot{x}<em>1-\\beta_1u&#x3D;\\dot{y}-\\beta_0\\dot{u}-\\beta_1u\\x_3&#x3D;\\dot{x}<em>2-\\beta_2u&#x3D;\\ddot{y}-\\beta_0\\ddot{u}-\\beta_1\\dot{u}-\\beta_2u\\\\vdots\\x_n&#x3D;\\dot{x}</em>{n-1}-\\beta</em>{n-1}u&#x3D;y^{(n)}-\\beta_0u^{(n-1)}-\\beta_1u^{(n-2)}-\\cdots -\\beta_{n-2}\\dot{u}-\\beta_{n-1}u\\end{matrix}\\right.   \\tag{11}$$</p>\n<p>其中参数$\\beta_0,\\beta_1,\\cdots,\\beta_n$由下式决定：</p>\n<p>$$\\begin{bmatrix}\\beta_0\\\\beta_1\\\\beta_2\\\\vdots\\\\beta_n\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0&amp;\\cdots&amp;0&amp;0\\a_1&amp;1&amp;\\cdots&amp;0&amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots\\a_{n-1}&amp;a_{n-2}&amp;\\cdots&amp;1&amp;0\\a_n&amp;a_{n-1}&amp;\\cdots&amp;a_1&amp;1\\end{bmatrix}\\begin{bmatrix}b_0\\b_1\\b_2\\\\vdots\\b_n\\end{bmatrix}    \\tag{12}$$</p>\n<p>由（11）可得到状态方程：$\\left{ \\begin{matrix} \\dot{x}<em>1&#x3D;x_2+\\beta_1u\\\\dot{x}<em>2&#x3D;x_3+\\beta_2u\\\\vdots\\\\dot{x}</em>{n-1}&#x3D;x_n+\\beta</em>{n-1}u\\\\begin{aligned}\\dot{x}<em>n&amp;&#x3D;y^{(n)}-\\beta_0u^{(u)}-\\beta_1u^{(n-1)}-\\cdots -\\beta</em>{n-2}\\ddot{u}-\\beta_{n-1}\\dot{u}\\&amp;&#x3D;-a_nx_1-a_{n-1}x_2-\\cdots -a_1x_n+\\beta_nu\\end{aligned} \\end{matrix}\\right.$。</p>\n<p>+++info 最后一个等式怎么化简得到的？</p>\n<p>+++</p>\n<p>因此，状态空间表达式为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1&amp;0&amp;\\cdots&amp;0\\0&amp;0&amp;1&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;0&amp;\\cdots&amp;1\\-a_n&amp;-a_{n-1}&amp;-a_{n-2}&amp;\\cdots&amp;-a_1\\end{bmatrix}x+\\begin{bmatrix}\\beta_0\\\\beta_1\\\\vdots\\\\beta_{n-1}\\\\beta_n\\end{bmatrix}u   \\tag{13}$$</p>\n<p>$$y&#x3D;[1\\quad 0\\quad \\cdots\\quad 0 ]x+\\beta_0u$$</p>\n<h3 id=\"通过传递函数建立状态空间描述\"><a href=\"#通过传递函数建立状态空间描述\" class=\"headerlink\" title=\"通过传递函数建立状态空间描述\"></a>通过传递函数建立状态空间描述</h3><p>后续的方法我们讨论的传递函数的分子多项式次数均小于分母多项式次数。因为对于实际系统，分子多项式次数总是小于或等于分母多项式次数，在次数相等时可以通过化简的方法转化为分子多项式次数小于分母多项式次数。</p>\n<p>+++primary 推导</p>\n<p>若传递函数的分子多项式次数等于分母多项式次数，即</p>\n<p>$$g(s)&#x3D;\\frac{b_0s^m+b_1s^{m-1}+\\cdots +b_{m-1}s+b_m}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n},m&#x3D;n$$</p>\n<p>它总是可以化简为：</p>\n<p>$$g(s)&#x3D;\\frac{b_1s^{m-1}+\\cdots +b_{m-1}s+b_m}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n}&#x3D;\\overline{g}(s)+b_0,m&#x3D;n$$</p>\n<p>其中 $\\overline{g}(s)$ 为分子多项式次数小于分母多项式次数的传递函数，$b_0$ 为常数，整体视为两者的并联结构。</p>\n<p>+++</p>\n<h4 id=\"直接分解法\"><a href=\"#直接分解法\" class=\"headerlink\" title=\"直接分解法\"></a>直接分解法</h4><p>对于$n$阶传递函数：$g(s)&#x3D;\\frac{Y(s)}{U(s)}&#x3D;\\frac{b_1s^{n-1}+\\cdots +b_{n-1}s+b_n}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n}$。</p>\n<p>同时除以$s^n$有：$Y(s)&#x3D;U(s)\\frac{b_1s^{-1}+\\cdots +b_{n-1}s^{-(n-1)}+b_ns^{-n}}{1+a_1s^{-1}+\\cdots +a_{n-1}s^{-(n-1)}+a_ns^{-n}}$。</p>\n<p>令中间变量$E(s)&#x3D;U(s)\\frac{1}{1+a_1s^{-1}+\\cdots +a_{n-1}s^{-(n-1)}+a_ns^{-n}}$，即$E(s)&#x3D;U(s)-a_1s^{-1}E(s)-\\cdots -a_{n-1}s^{-(n-1)}E(s)-a_ns^{-n}E(s)$。</p>\n<p>则输入$U(s)$、中间变量$E(s)$和输出$Y(s)$的关系流程图如下：</p>\n\n\n<p>则$Y(s)&#x3D;b_1s^{-1}E(s)+b_2s^{-2}E(s)+\\cdots +b_{n-1}s^{-(n-1)}E(s)+b_ns^{-n}E(s)$。</p>\n<p>令$x_n,x_{n-1},\\cdots,x_1$为$s^{-1}E(s),s^{-2}E(s),\\cdots,s^{-n}E(s)$的拉氏逆变换，那么就可以绘制状态变量图并得到系统的状态空间表达式（能控标准型）。</p>\n\n\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;1\\-a_n&amp;-a_{n-1}&amp;\\cdots&amp;-a_1\\end{bmatrix}x+\\begin{bmatrix}0\\\\vdots\\0\\1\\end{bmatrix}u   \\tag{14}$$</p>\n<p>$$y&#x3D;[b_n\\quad b_{n-1}\\quad \\cdots\\quad b_1 ]x$$</p>\n<p>+++info 补充</p>\n<p>如果该$n$阶系统传递函数的分子多项式次数等于分母多项式次数（在<a href=\"#%E9%80%9A%E8%BF%87%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%BB%BA%E7%AB%8B%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0\">通过传递函数建立状态空间描述</a>中讨论过该情况）即 $g(s)&#x3D;\\frac{b_1s^{m-1}+\\cdots +b_{m-1}s+b_m}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n}&#x3D;\\overline{g}(s)+b_0,m&#x3D;n$，那么先算出 $\\overline{g}(s)$ 后在输入到输出之间直接连接一个比例环节即可。</p>\n<p>+++</p>\n<h4 id=\"串联分解法\"><a href=\"#串联分解法\" class=\"headerlink\" title=\"串联分解法\"></a>串联分解法</h4><p>该方法适用于传递函数可分解为因式相乘的形式，即$g(s)&#x3D;\\frac{b_1(s-z_1)(s-z_2)\\cdots(s-z_{n-1})}{(s-p_1)(s-p_2)\\dots(s-p_n)}$。</p>\n<p>以一个三阶系统进行说明：$g(s)&#x3D;\\frac{b_1(s-z_1)(s-z_2)}{(s-p_1)(s-p_2)(s-p_3)}$。</p>\n<p>上式中可分为两种：$\\frac{1}{s-p}&#x3D;\\frac{\\frac{1}{s}}{1-\\frac{1}{s}p}$，$\\frac{s-z}{s-p}&#x3D;1+\\frac{p-z}{s-p}&#x3D;1+(p-z)\\frac{\\frac{1}{s}}{1-\\frac{1}{s}p}$。</p>\n<p>因此系统可视为三个一阶系统串联而成，结构图如下：</p>\n\n\n<p>取每个积分器的输出为状态变量，那么可以得到状态空间表达式如下：</p>\n<p>$$\\left{ \\begin{matrix} \\dot{x}_1&#x3D;p_1x_1+b_1u\\\\dot{x}_2&#x3D;x_1+p_2x_2\\\\dot{x}_3&#x3D;x_1+(p_2-z_2)x_2+p_3x_3\\y&#x3D;x_1+(p_2-z_2)x_2+(p_3-z_3)x_3\\end{matrix}\\right.$$</p>\n<p>写成向量的形式为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}p_1&amp;0&amp;0\\1&amp;p_2&amp;0\\1&amp;p_2-z_2&amp;p_3\\end{bmatrix}x+\\begin{bmatrix}b_1\\0\\0\\end{bmatrix}u   \\tag{15}$$</p>\n<p>$$y&#x3D;[1\\quad p_2-z_2\\quad \\quad p_3-z_3 ]x$$</p>\n<h4 id=\"并联分解法\"><a href=\"#并联分解法\" class=\"headerlink\" title=\"并联分解法\"></a>并联分解法</h4><ol>\n<li>若传递函数的极点两两相异。</li>\n</ol>\n<p>传递函数极点两两相异，则$g(s)&#x3D;\\frac{N(s)}{(s-p_1)(s-p_2)\\dots(s-p_n)}&#x3D;\\frac{c_1}{s-p_1}+\\frac{c_2}{s-p_2}+\\cdots+\\frac{c_n}{s-p_n}$，其中$c_i&#x3D;\\lim_{s\\to p_i}(s-p_i)g(s)$。</p>\n<p>选取状态变量 $x_i(s)&#x3D;\\frac{1}{s-p_i}U(s)$，即 $sx_i(s)&#x3D;p_ix_i(s)+u(s)$，做拉氏逆变换有：</p>\n<p>$$\\dot{x}_i(t)&#x3D;p_ix_i(t)+u(t)$$</p>\n<p>输出 $y(s)&#x3D;g(s)u(s)&#x3D;\\sum_{i&#x3D;1}^n\\frac{c_i}{s-p_i}u_i(s)&#x3D;\\sum_{i&#x3D;1}^nc_ix_i(s)$，做拉氏逆变换有：</p>\n<p>$$y(t)&#x3D;\\sum_{i&#x3D;1}^nc_ix_i(t)$$</p>\n<p>写成向量的形式为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}p_1&amp;0&amp;\\cdots&amp;0\\0&amp;p_2&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;0\\0&amp;0&amp;\\cdots&amp;p_n\\end{bmatrix}x+\\begin{bmatrix}1\\1\\\\vdots\\1\\end{bmatrix}u   \\tag{16}$$</p>\n<p>$$y&#x3D;[c_1\\quad c_2\\quad\\cdots \\quad c_n]x$$</p>\n<p>+++info 上式为对角标准型</p>\n<p>对于系统 $\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx\\\\end{matrix}\\right.$ ，若$A$为对角阵且各元素为传递函数的极点，$B$为全1矩阵，$C$内各元素为对应极点的留数，那么称该矩阵表达式为对角标准型。</p>\n<p>+++</p>\n<ol start=\"2\">\n<li>若传递函数具有重极点。</li>\n</ol>\n<p>先考虑只有一个重极点和若干个单极点，重数为$r$，$g(s)&#x3D;\\frac{c_{11}}{(s-p_1)^{r}}+\\frac{c_{12}}{(s-p_1)^{r-1}}+\\cdots+\\frac{c_{1r}}{(s-p_1)^{}}+\\frac{c_{r+1}}{s-p_{r+1}}+\\cdots+\\frac{c_n}{s-p_n}$，其中对于单极点仍有：$c_i&#x3D;\\lim_{s\\to p_i}(s-p_i)g(s)$，而对于重极点则有：$c_1j&#x3D;\\frac{1}{(j-1)!}\\lim_{s\\to p_1}\\frac{d^{j-1}}{ds^{j-1}}[(s-p_1)g(s)],\\quad j&#x3D;1,2,\\cdots,r$。</p>\n<p>选取状态变量，化简求拉氏逆变换得到状态方程：</p>\n<p>$$\\begin{matrix}\\left{ \\begin{matrix} x_1(s)&#x3D;\\frac{U(s)}{(s-p_1)^{r}}\\x_2(s)&#x3D;\\frac{U(s)}{(s-p_1)^{r-1}}\\\\vdots\\x_r(s)&#x3D;\\frac{U(s)}{(s-p_1)}\\x_{r+1}(s)&#x3D;\\frac{U(s)}{s-p_{r+1}}\\\\vdots\\x_{1}(s)&#x3D;\\frac{U(s)}{s-p_{n}}\\end{matrix}\\right.\\quad\\stackrel{}{\\Rightarrow}\\quad\\left{ \\begin{matrix} x_1(s)&#x3D;\\frac{1}{s-p_1}x_2(s)\\x_2(s)&#x3D;\\frac{1}{s-p_1}x_3(s)\\\\vdots\\x_r(s)&#x3D;\\frac{1}{s-p_1}U(s)\\x_{r+1}(s)&#x3D;\\frac{1}{s-p_{r+1}}U(s)\\\\vdots\\x_n(s)&#x3D;\\frac{1}{s-p_n}U(s)\\end{matrix}\\right.\\quad\\stackrel{L^{-1}}{\\Rightarrow}\\quad \\left{ \\begin{matrix} \\dot{x}<em>1(t)&#x3D;p_1x_1+x_2\\\\dot{x}<em>2(t)&#x3D;p_1x_2+x_3\\\\vdots\\\\dot{x}<em>r(t)&#x3D;p_1x_r+u\\\\dot{x}</em>{r+1}(t)&#x3D;p</em>{r+1}x</em>{x+1}+u\\\\vdots\\\\dot{x}_n(t)&#x3D;p_nx_n+u\\end{matrix}\\right.     \\end{matrix}$$</p>\n<p>输出方程的拉氏变换为：</p>\n<p>$$Y(s)&#x3D;c_{11}x_1(s)+c_{12}x_2(s)+\\cdots+c_{1r}x_r(s)+c_{r+1}x_{r+1}(s)+\\cdots+c_{nx_n(s)}$$</p>\n<p>求拉氏逆变换有：</p>\n<p>$$y(t)&#x3D;c_{11}x_1(t)+c_{12}x_2(t)+\\cdots+c_{1r}x_r(t)+c_{r+1}x_{r+1}(t)+\\cdots+c_{nx_n(t)}$$</p>\n<p>得到状态空间表达式为：</p>\n<p>$$\\begin{bmatrix}\\dot{x_1}\\\\dot{x_2}\\\\vdots\\\\dot{x_r}\\\\dot{x_{r+1}}\\\\vdots\\\\dot{x_n}\\end{bmatrix}&#x3D;\\begin{bmatrix}p_1&amp;1&amp;&amp;&amp;&amp;&amp;\\&amp;p_1&amp;\\ddots&amp;&amp;&amp;\\bold{0}&amp;\\&amp;&amp;\\ddots&amp;1\\&amp;&amp;&amp;p_1\\&amp;&amp;&amp;&amp;p_{r+1}&amp;&amp;\\&amp;\\bold{0}&amp;&amp;&amp;&amp;\\ddots&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;p_n\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\\\vdots\\x_r\\x_{r+1}\\\\vdots\\x_n\\end{bmatrix}+\\begin{bmatrix}0\\0\\\\vdots\\1\\1\\\\vdots\\1\\end{bmatrix}u   \\tag{17}$$</p>\n<p>$$y&#x3D;\\begin{bmatrix}c_{11}&amp; c_{12}&amp;\\cdots&amp; c_{1r}&amp;c_{r+1}&amp;\\cdots&amp;c_{n}\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\\\vdots\\x_r\\x_{r+1}\\\\vdots\\x_n\\end{bmatrix}$$</p>\n<p>对于重根部分，矩阵$A$中对应的是若尔当块，$B$中为一个只有末行是1其余行为0的矩阵，$C$中对应元素为$r$重极点对应的留数。而对于其中的单极点部分，形式与<a href=\"#%E5%B9%B6%E8%81%94%E5%88%86%E8%A7%A3%E6%B3%95\">无重根</a>时一致。</p>\n<p>拓展到具有多个重极点的情况。矩阵$A$中在对角上补充对应的若尔当块，$B$中对应补充只有末行是1其余行为0的矩阵，$C$中补充对应元素为$r$重极点对应的留数。</p>\n<h2 id=\"组合系统\"><a href=\"#组合系统\" class=\"headerlink\" title=\"组合系统\"></a>组合系统</h2><h3 id=\"并联联结\"><a href=\"#并联联结\" class=\"headerlink\" title=\"并联联结\"></a>并联联结</h3><p>在$n$个子系统并联的并联系统中，组合系统的传递函数矩阵等于子系统传递函数矩阵的和。</p>\n<p>$$G(s)&#x3D;G_1(s)+G_2(s)+\\cdots+G_n(s)   \\tag{18}$$</p>\n<h3 id=\"串联联结\"><a href=\"#串联联结\" class=\"headerlink\" title=\"串联联结\"></a>串联联结</h3><p>在$n$个子系统串联的串联系统中，组合系统的传递函数矩阵等于子系统传递函数矩阵的积。</p>\n<p>$$G(s)&#x3D;G_n(s)\\cdots G_2(s)G_1(s)   \\tag{19}$$</p>\n<p>:::info </p>\n<p>注：子系统传递函数矩阵的积遵循左乘原则。</p>\n<p>:::</p>\n<h3 id=\"反馈联结\"><a href=\"#反馈联结\" class=\"headerlink\" title=\"反馈联结\"></a>反馈联结</h3><p>对于系统 $G_1(s)$，若添加反馈环节（动态反馈$G_2(s)$或常数反馈$H$），则可得到组合系统的传递函数矩阵：</p>\n<ol>\n<li><strong>动态反馈</strong> 反馈子系统为动态系统$G_2(s)$。</li>\n</ol>\n<p>组合系统的传递函数矩阵为：</p>\n<p>$$G(s)&#x3D;[I+G_2(s)G_1(s)]^{-1}G_1(s)   \\tag{20}$$</p>\n<ol start=\"2\">\n<li><strong>常数反馈</strong>  反馈环节为常数矩阵$H$。</li>\n</ol>\n<p>组合系统的传递函数矩阵为：</p>\n<p>$$G(s)&#x3D;[I+HG_1(s)]^{-1}G_1(s)   \\tag{21}$$</p>\n<h2 id=\"线性变换\"><a href=\"#线性变换\" class=\"headerlink\" title=\"线性变换\"></a>线性变换</h2><h3 id=\"系统状态的线性变换\"><a href=\"#系统状态的线性变换\" class=\"headerlink\" title=\"系统状态的线性变换\"></a>系统状态的线性变换</h3><p>对于一个状态方程$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.$，选择非奇异矩阵$P\\in R^{n\\times n}$作为变换阵，有$x&#x3D;P\\overline{x}$，那么此时状态方程可表示为：</p>\n<p>$$\\dot{\\overline{x}}&#x3D;P^{-1}\\dot{x}&#x3D;P^{-1}[Ax+Bu]&#x3D;P^{-1}AP\\overline{x}+P^{-1}Bu&#x3D;\\overline{A}\\overline{x}+\\overline{B}u   \\tag{22}$$</p>\n<p>$$y&#x3D;Cx&#x3D;CP\\overline{x}&#x3D;\\overline{C}\\overline{x}    \\tag{23}$$</p>\n<p>其中，$\\overline{A}&#x3D;P^{-1}AP,\\overline{B}&#x3D;P^{-1}B,\\overline{C}&#x3D;CP,\\overline{D}&#x3D;D$。</p>\n<p>:::info</p>\n<p>该方法通常用于将非对角阵$A$转化为对角阵$\\overline{A}$，从而实现状态变量的解耦。</p>\n<p>:::</p>\n<p>:::danger no-icon</p>\n<p>线性定常系统的系统矩阵A的特征值是表征系统的动力学特性的重要参量。系统的状态方程可通过适当的线性非奇异变换化为由特征值表征的标准形，对分析系统的结构特性非常直观。 </p>\n<ol>\n<li>特征值互异时，标准形为对角阵。</li>\n<li>特征值非互异时，标准形一般为约当阵。</li>\n</ol>\n<p>:::</p>\n<h3 id=\"状态方程转化为对角标准型\"><a href=\"#状态方程转化为对角标准型\" class=\"headerlink\" title=\"状态方程转化为对角标准型\"></a>状态方程转化为对角标准型</h3><h3 id=\"状态方程转化为若尔当标准型\"><a href=\"#状态方程转化为若尔当标准型\" class=\"headerlink\" title=\"状态方程转化为若尔当标准型\"></a>状态方程转化为若尔当标准型</h3><h3 id=\"状态变换后特征值及传递函数矩阵的不变形\"><a href=\"#状态变换后特征值及传递函数矩阵的不变形\" class=\"headerlink\" title=\"状态变换后特征值及传递函数矩阵的不变形\"></a>状态变换后特征值及传递函数矩阵的不变形</h3>","categories":["现代控制理论"],"tags":["状态空间描述"]},{"title":"03 状态方程的解","url":"/2023/10/28/2023-10-29-%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B%E7%9A%84%E8%A7%A3/","content":"<p>现代控制理论——03 状态方程的解</p>\n<span id=\"more\"></span>\n\n<h1 id=\"状态方程的解\"><a href=\"#状态方程的解\" class=\"headerlink\" title=\"状态方程的解\"></a>状态方程的解</h1><h2 id=\"线性时不变系统齐次状态方程的解\"><a href=\"#线性时不变系统齐次状态方程的解\" class=\"headerlink\" title=\"线性时不变系统齐次状态方程的解\"></a>线性时不变系统齐次状态方程的解</h2><p>对于$n$维线性时不变系统状态方程：$\\bold{\\dot{x}}&#x3D;\\bold{Ax}(t)+\\bold{Bu}(t)$，系统状态方程的解即为系统的运动。当控制输入为$0$时对应的齐次状态方程 $\\bold{\\dot{x}}&#x3D;\\bold{Ax}(t)$ 的解为系统的自由运动。</p>\n<p>对于标量一阶微分方程的齐次方程 $\\dot{x}&#x3D;ax(t)$，若初始时刻为$t_0$，则方程的解为$x(t)&#x3D;e^{a(t-t_0)}x(t_0)$，其中指数函数展开为无穷级数：$e^{a(t-t_0)}&#x3D;\\sum^{+\\infty}_{n&#x3D;0}\\frac{1}{n!}a^n(t-t_0)^n$。</p>\n<p>拓展到矢量一阶微分方程的齐次方程 $\\bold{\\dot{x}}&#x3D;\\bold{Ax}(t)$ ，解可以表示为</p>\n<p>$$\\bold{x}(t)&#x3D;e^{\\bold{A}(t-t_0)}\\bold{x}(t_0)     \\tag{1}$$</p>\n<p>其中$e^{\\bold{A}(t-t_0)}&#x3D;\\sum^{+\\infty}_{n&#x3D;0}\\frac{1}{n!}\\bold{A}^n(t-t_0)^n$，称为矩阵指数。</p>\n<h2 id=\"矩阵指数\"><a href=\"#矩阵指数\" class=\"headerlink\" title=\"矩阵指数\"></a>矩阵指数</h2><p>矩阵指数函数表示为：$e^{\\bold{A}(t)}&#x3D;\\sum^{+\\infty}_{n&#x3D;0}\\frac{1}{n!}\\bold{A}^n(t)^n$，即输入为$0$时的解（零输入响应）。</p>\n<h3 id=\"矩阵指数的性质\"><a href=\"#矩阵指数的性质\" class=\"headerlink\" title=\"矩阵指数的性质\"></a>矩阵指数的性质</h3><ol>\n<li><p>矩阵指数的导数：$\\frac{d}{dt}e^{\\bold{A}t}&#x3D;\\bold{A}e^{\\bold{A}t}&#x3D;e^{\\bold{A}t}\\bold{A}$。</p>\n</li>\n<li><p>对于$n\\times{n}$阶方阵$\\bold{A}$和$\\bold{B}$，若$\\bold{A}\\bold{B}&#x3D;\\bold{B}\\bold{A}$，则$e^{(\\bold{A}+\\bold{B})t}&#x3D;e^{\\bold{A}t}e^{\\bold{B}t}$。</p>\n</li>\n<li><p>若$t_1$与$t_2$为独立的自变量，则$e^{\\bold{A}(t_1+t_2)}&#x3D;e^{\\bold{A}t_1}e^{\\bold{A}t_2}$。</p>\n</li>\n<li><p>$e^{\\bold{A}*0}&#x3D;\\bold{I}$。</p>\n</li>\n<li><p>$e^{\\bold{A}t}e^{\\bold{-A}t}&#x3D;\\bold{I}$。</p>\n</li>\n<li><p>$e^{\\bold{P}^{-1}\\bold{A}\\bold{P}}&#x3D;\\bold{P}^{-1}e^{\\bold{A}}\\bold{P}$。</p>\n</li>\n<li><p>$lim_{t\\to0}e^{\\bold{A}t}&#x3D;\\bold{I}$。</p>\n</li>\n<li><p>若$\\bold{A}$为对角矩阵，即$\\bold{A}&#x3D;\\begin{bmatrix} \\lambda_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n\\end{bmatrix}$，则$e^{\\bold{A}t}&#x3D;\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}$。</p>\n</li>\n</ol>\n<p>+++primary  证明</p>\n<p>$e^{\\bold{A}t}&#x3D;\\bold{I}+\\bold{A}t+\\frac{1}{2!}\\bold{A}^2t^2+\\cdots$</p>\n<p>$&#x3D;\\begin{bmatrix} 1&amp;0&amp;\\cdots&amp;0\\ 0&amp;1&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;1\\end{bmatrix}+\\begin{bmatrix} \\lambda_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n\\end{bmatrix}t+\\frac{1}{2!}\\begin{bmatrix} \\lambda_1^2&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2^2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n^2\\end{bmatrix}t^2+\\cdots$</p>\n<p>$&#x3D;\\begin{bmatrix} \\sum^{+\\infty}<em>{n&#x3D;0}\\frac{1}{n!}\\lambda_1^nt^n&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\sum^{+\\infty}</em>{n&#x3D;0}\\frac{1}{n!}\\lambda_2^nt^n&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\sum^{+\\infty}_{n&#x3D;0}\\frac{1}{n!}\\lambda_n^nt^n\\end{bmatrix}&#x3D;\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}$。</p>\n<p>+++</p>\n<ol start=\"9\">\n<li>若$\\bold{A}$为$m\\times{m}$的若尔当块，即$\\bold{A}&#x3D;\\begin{bmatrix} \\lambda&amp;1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda&amp;1&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\lambda&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;\\lambda&amp;1\\ 0&amp;0&amp;\\cdots&amp;0&amp;\\lambda\\end{bmatrix}<em>{m\\times{m}}$，则$e^{\\bold{A}t}&#x3D;e^{\\lambda t}\\begin{bmatrix} 1&amp;t&amp;\\frac{t^{2}}{2!}&amp;\\cdots&amp;\\frac{t^{m-1}}{(m-1)!}\\ 0&amp;1&amp;t&amp;\\cdots&amp;\\frac{t^{m-2}}{(m-2)!}\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;1&amp;t\\ 0&amp;0&amp;\\cdots&amp;0&amp;1\\end{bmatrix}</em>{m\\times{m}}$。</li>\n</ol>\n<p>+++primary 若尔当块</p>\n<p>形如$\\begin{bmatrix} \\lambda&amp;1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda&amp;1&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\lambda&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;\\lambda&amp;1\\ 0&amp;0&amp;\\cdots&amp;0&amp;\\lambda\\end{bmatrix}_{m\\times{m}}$为$m$阶若尔当矩阵，1阶若尔当矩阵为$\\lambda$。</p>\n<p>+++</p>\n<ol start=\"10\">\n<li>若$\\bold{A}$为一个有多个若尔当块的若尔当矩阵（即若当标准型），即$\\bold{A}&#x3D;\\begin{bmatrix} \\bold{A}_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\bold{A}_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\bold{A}_n\\end{bmatrix}$，则$e^{\\bold{A}t}&#x3D;\\begin{bmatrix} e^{\\bold{A}_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\bold{A}_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\bold{A}_nt}\\end{bmatrix}$。</li>\n</ol>\n<h3 id=\"矩阵指数的计算\"><a href=\"#矩阵指数的计算\" class=\"headerlink\" title=\"矩阵指数的计算\"></a>矩阵指数的计算</h3><ol>\n<li>定义计算：$e^{\\bold{A}t}&#x3D;\\sum^{+\\infty}_{n&#x3D;0}\\frac{1}{n!}\\bold{A}^n(t)^n$。该方法适用于计算机运算。</li>\n</ol>\n<p>+++info  例题</p>\n<p>;;;id1 例题1</p>\n<p>:::info </p>\n<p>已知$\\bold{A}&#x3D;\\begin{bmatrix} 0&amp;1\\-1&amp;0\\end{bmatrix}$，求$e^{\\bold{A}t}$。</p>\n<p>:::</p>\n<p>由定义，</p>\n<p>$\\begin{aligned}e^{\\bold{A}t}&amp;&#x3D;\\bold{I}+\\bold{A}t+\\frac{1}{2!}+\\cdots&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}+\\begin{bmatrix}0&amp;t\\-t&amp;0\\end{bmatrix}+\\frac{1}{2!}\\begin{bmatrix}-t^2&amp;0\\0&amp;-t^2\\end{bmatrix}+\\cdots\\&amp;&#x3D;\\begin{bmatrix}1-\\frac{t^2}{2!}+\\cdots&amp;t-\\frac{t^3}{3!}+\\cdots\\-t+\\frac{t^3}{3!}-\\cdots&amp;1-\\frac{t^2}{2!}+\\cdots\\end{bmatrix}&#x3D;\\begin{bmatrix} \\cos{t}&amp;\\sin{t}\\-\\sin{t}&amp;\\cos{t}\\end{bmatrix}\\end{aligned}$.</p>\n<p>;;; </p>\n<p>+++</p>\n<ol start=\"2\">\n<li>拉氏变换法：利用拉氏变换在频域中求解齐次状态方程的解。</li>\n</ol>\n<p>设线性时不变齐次状态方程为 $\\bold{\\dot{x}}&#x3D;\\bold{Ax}(t)$，$\\bold{x}(0)&#x3D;\\bold{x}_0$，$t\\geq{t_0}$。</p>\n<p>作拉氏变换有 $s\\bold{X}(s)-\\bold{x}(0)&#x3D;\\bold{AX}(s)$，即 $(s\\bold{I}-\\bold{A})\\bold{X}(s)&#x3D;\\bold{x}(0)$，那么 </p>\n<p>$$\\bold{X}(s) &#x3D;(s\\bold{I}-\\bold{A})^{-1}\\bold{x}(0)$$</p>\n<p>取拉氏逆变换有 $\\bold{x}(0)&#x3D;L^{-1}[(s\\bold{I}-\\bold{A})^{-1}\\bold{x}(0)]&#x3D;L^{-1}[(s\\bold{I}-\\bold{A})^{-1}]\\bold{x}(0)$，因此 </p>\n<p>$$e^{\\bold{A}t}&#x3D;L^{-1}[(s\\bold{I}-\\bold{A})^{-1}]     \\tag{2}$$</p>\n<p>+++info 例题</p>\n<p>;;;id2 例题1</p>\n<p>:::info</p>\n<p>计算矩阵 $\\bold{A}&#x3D;\\begin{bmatrix}0&amp;1\\-2&amp;-3\\end{bmatrix}$的矩阵指数。</p>\n<p>:::</p>\n<p>由拉氏变换法，$(s\\bold{I}-\\bold{A})&#x3D;\\begin{bmatrix} s&amp;-1\\2&amp;s+3\\end{bmatrix}$，则$(s\\bold{I}-\\bold{A})^{-1}&#x3D;\\begin{bmatrix}\\frac{s+3}{(s+1)(s+2)}&amp;\\frac{1}{(s+1)(s+2)}\\\\frac{-2}{(s+1)(s+2)}&amp;\\frac{s}{(s+1)(s+2)}\\end{bmatrix}$，</p>\n<p>则 $e^{\\bold{A}t}&#x3D;L^{-1}\\begin{bmatrix}\\frac{s+3}{(s+1)(s+2)}&amp;\\frac{1}{(s+1)(s+2)}\\\\frac{-2}{(s+1)(s+2)}&amp;\\frac{s}{(s+1)(s+2)}\\end{bmatrix}&#x3D;\\begin{bmatrix}2e^{-t}&amp;e^{-t}-e^{-2t}\\-2e^{-t}+2e^{-2t}&amp;-e^{-t}+2e^{-2t}\\end{bmatrix}$。</p>\n<p>;;;</p>\n<p>+++</p>\n<ol start=\"3\">\n<li>将矩阵化为对角标准型或若尔当标准型。</li>\n</ol>\n<p>若$\\bold{A}&#x3D;\\begin{bmatrix} \\lambda_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n\\end{bmatrix}$为对角矩阵，则$e^{\\bold{A}t}$也为对角矩阵（<a href=\"#%E7%9F%A9%E9%98%B5%E6%8C%87%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8\">性质8</a>），即$e^{\\bold{A}t}&#x3D;\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}$。</p>\n<p>（1）当矩阵$\\bold{A}$的 $n$ 个特征值 $\\lambda_1,\\lambda_2\\dots\\lambda_n$ 均两两互异时，则可确定变换阵 $\\bold{P}$ 及其逆矩阵 $\\bold{P}^{-1}$ ，使得矩阵$\\bold{A}$对角化：$\\bold{A} &#x3D; \\bold{P}\\begin{bmatrix}\\lambda_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n\\end{bmatrix}\\bold{P}^{-1}$，则有 </p>\n<p>$$e^{\\bold{A}t}&#x3D;\\bold{P}\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}\\bold{P}^{-1}   \\tag{3}$$</p>\n<p>+++primary 解题步骤</p>\n<ol>\n<li>求解系统矩阵$\\bold{A}$的特征值 $\\lambda_1,\\lambda_2\\dots\\lambda_n$ 。（特征值两两互异）</li>\n<li>求解特征值对应的特征向量$p_1,p_2\\dots p_n$，构造变换阵 $\\bold{P}$ 并求解其逆矩阵 $\\bold{P}^{-1}$ 。</li>\n<li>求解矩阵指数 $e^{\\bold{A}t}&#x3D;\\bold{P}\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}\\bold{P}^{-1}$。</li>\n</ol>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id3 例题1</p>\n<p>:::info </p>\n<p>试用化为对角标准型法求解矩阵$\\bold{A}&#x3D;\\begin{bmatrix}0&amp;1\\-2&amp;-3\\end{bmatrix}$的矩阵指数 $e^{\\bold{A}t}$。</p>\n<p>:::</p>\n<p>求解特征值$|\\lambda\\bold{I}-\\bold{A}|&#x3D;\\begin{vmatrix}\\lambda&amp;-1\\2&amp;\\lambda+3\\end{vmatrix}&#x3D;(\\lambda+1)(\\lambda+2)$，得到特征值为$\\lambda_1&#x3D;-1$，$\\lambda_2&#x3D;-2$。继而求解特征向量$p_1&#x3D;\\begin{bmatrix}1\\-1\\end{bmatrix}$，$p_2&#x3D;\\begin{bmatrix}1\\-2\\end{bmatrix}$。</p>\n<p>故变换矩阵 $\\bold{P}&#x3D;\\begin{bmatrix}1&amp;1\\-1&amp;-2\\end{bmatrix}$，求逆有 $\\bold{P}^{-1}&#x3D;\\begin{bmatrix}2&amp;1\\-1&amp;-1\\end{bmatrix}$。</p>\n<p>则矩阵指数为 $e^{\\bold{A}t}&#x3D;\\bold{P}\\begin{bmatrix} e^{-t}&amp;0\\ 0&amp;e^{-2t}\\end{bmatrix}\\bold{P}^{-1}&#x3D;\\begin{bmatrix} 2e^{-t}-e^{-2t}&amp;e^{-t}-e^{-2t}\\ -2e^{-t}+2e^{-2t}&amp;-e^{-t}+2e^{-2t}\\end{bmatrix}$。</p>\n<p>;;;</p>\n<p>;;;id3 例题2</p>\n<p>:::info </p>\n<p>试用化为对角标准型法求解矩阵$\\bold{A}&#x3D;\\begin{bmatrix}0&amp;1&amp;-1\\-6&amp;-11&amp;6\\-6&amp;-11&amp;5\\end{bmatrix}$的矩阵指数 $e^{\\bold{A}t}$。</p>\n<p>:::</p>\n<p>求解特征值$|\\lambda\\bold{I}-\\bold{A}|&#x3D;\\begin{vmatrix}\\lambda&amp;-1&amp;1\\6&amp;\\lambda+11&amp;-6\\6&amp;11&amp;\\lambda-5\\end{vmatrix}&#x3D;(\\lambda+1)(\\lambda+2)(\\lambda+3)$，得到特征值为$\\lambda_1&#x3D;-1$，$\\lambda_2&#x3D;-2$，$\\lambda_3&#x3D;-3$。继而求解特征向量$p_1&#x3D;\\begin{bmatrix}1\\0\\1\\end{bmatrix}$，$p_2&#x3D;\\begin{bmatrix}1\\2\\4\\end{bmatrix}$，$p_3&#x3D;\\begin{bmatrix}1\\6\\9\\end{bmatrix}$。</p>\n<p>故变换矩阵 $\\bold{P}&#x3D;\\begin{bmatrix}1&amp;1&amp;1\\0&amp;2&amp;6\\1&amp;4&amp;9\\end{bmatrix}$，求逆有 $\\bold{P}^{-1}&#x3D;\\begin{bmatrix}3&amp;\\frac{5}{2}&amp;-2\\-3&amp;-4&amp;3\\1&amp;\\frac{3}{2}&amp;-1\\end{bmatrix}$。</p>\n<p>则矩阵指数为 </p>\n<p>$\\begin{aligned}e^{\\bold{A}t}&amp;&#x3D;\\bold{P}\\begin{bmatrix} e^{-t}&amp;0&amp;0\\ 0&amp;e^{-2t}&amp;0\\0&amp;0&amp;e^{-3t}\\end{bmatrix}\\bold{P}^{-1}&#x3D;\\begin{bmatrix}1&amp;1&amp;1\\0&amp;2&amp;6\\1&amp;4&amp;9\\end{bmatrix}\\begin{bmatrix} e^{-t}&amp;0&amp;0\\ 0&amp;e^{-2t}&amp;0\\0&amp;0&amp;e^{-3t}\\end{bmatrix}\\begin{bmatrix}3&amp;\\frac{5}{2}&amp;-2\\-3&amp;-4&amp;3\\1&amp;\\frac{3}{2}&amp;-1\\end{bmatrix}\\&amp;&#x3D;\\begin{bmatrix} 3e^{-t}-3e^{-2t}+e^{-3t}&amp;\\frac{5}{2}e^{-t}-4e^{-2t}+\\frac{3}{2}e^{-3t}&amp;-2e^{-t}+3e^{-2t}-e^{-3t}\\ -6e^{-t}+6e^{-3t}&amp;-8e^{-2t}+9e^{-3t}&amp;6e^{-2t}-6e^{-3t}\\3e^{-t}-12e^{-2t}+9e^{-3t}&amp;\\frac{5}{2}e^{-t}-16e^{-2t}+\\frac{27}{2}e^{-3t}&amp;-2e^{-t}+12e^{-2t}-9e^{-3t}\\end{bmatrix}\\end{aligned}$。</p>\n<p>;;;</p>\n<p>+++</p>\n<p>（2）当 $n\\times{n}$ 矩阵$\\bold{A}$有$n$重特征根时，存在线性非奇异变换 $\\bold{P}$ 及其逆矩阵 $\\bold{P}^{-1}$ ，将矩阵 $\\bold{A}$ 转化为若尔当标准型：$\\bold{A} &#x3D; \\bold{P}\\begin{bmatrix}\\lambda&amp;1&amp;\\cdots&amp;0\\ 0&amp;\\lambda&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;1\\ 0&amp;0&amp;\\cdots&amp;\\lambda\\end{bmatrix}_{n\\times{n}}\\bold{P}^{-1}$，则有 </p>\n<p>$$e^{\\bold{A}t}&#x3D;\\bold{P}e^{\\lambda t}\\begin{bmatrix} 1&amp;t&amp;\\frac{t^2}{2!}&amp;\\cdots&amp;\\frac{t^{n-1}}{(n-1)!}\\ 0&amp;1&amp;t&amp;\\cdots&amp;\\frac{t^{n-2}}{(n-2)!}\\  \\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;0&amp;\\cdots&amp;t\\ 0&amp;0&amp;0&amp;\\cdots&amp;1\\end{bmatrix}_{n\\times{n}}\\bold{P}^{-1}   \\tag{4}$$</p>\n<p>拓展到一般情况，矩阵$\\bold{A}$同时存在重特征根和单特征根时,以有三重根$\\lambda_1$、两重根$\\lambda_2$和单根$\\lambda_3$的矩阵$\\bold{A}$为例，若存在变换阵 $\\bold{P}$ 及其逆矩阵 $\\bold{P}^{-1}$ ，将矩阵 $\\bold{A}$ 转化为若尔当标准型：$\\bold{A} &#x3D; \\bold{P}\\begin{bmatrix}\\lambda_1&amp;1&amp;&amp;&amp;&amp;\\bold{0}\\ &amp;\\lambda_1&amp;1&amp;&amp;&amp;\\  &amp;&amp;\\lambda_1&amp;&amp;&amp;\\&amp;&amp;&amp;\\lambda_2&amp;1&amp;\\&amp;&amp;&amp;&amp;\\lambda_2&amp;\\\\bold{0}&amp;&amp;&amp;&amp;&amp;\\lambda_1\\end{bmatrix}\\bold{P}^{-1}$，则有 </p>\n<p>$$e^{\\bold{A}t}&#x3D;\\bold{P}\\begin{bmatrix}e^{\\lambda_1t}&amp;te^{\\lambda_1t}&amp;\\frac{1}{2}t^2e^{\\lambda_1t}&amp;0&amp;0&amp;0\\ 0&amp;e^{\\lambda_1t}&amp;te^{\\lambda_1t}&amp;0&amp;0&amp;0\\  0&amp;0&amp;e^{\\lambda_1t}&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;e^{\\lambda_2t}&amp;te^{\\lambda_2t}&amp;0\\0&amp;0&amp;0&amp;0&amp;e^{\\lambda_2t}&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;e^{\\lambda_3t}\\end{bmatrix}\\bold{P}^{-1}     \\tag{5}$$</p>\n<p>+++info 例题</p>\n<p>;;;id4 例题1</p>\n<p>:::info </p>\n<p>试求矩阵$\\bold{A}&#x3D;\\begin{bmatrix}0&amp;6&amp;-5\\1&amp;0&amp;2\\3&amp;2&amp;4\\end{bmatrix}$的矩阵指数。</p>\n<p>:::</p>\n<p>求解特征值$|\\lambda\\bold{I}-\\bold{A}|&#x3D;\\begin{vmatrix}\\lambda&amp;-6&amp;5\\-1&amp;\\lambda&amp;-2\\-3&amp;-2&amp;\\lambda-4\\end{vmatrix}&#x3D;(\\lambda-1)^2(\\lambda-2)$，得到特征值为$\\lambda_1&#x3D;\\lambda_2&#x3D;1$，$\\lambda_3&#x3D;2$。继而求解特征向量和广义特征向量$p_1&#x3D;\\begin{bmatrix}1\\-\\frac{3}{7}\\-\\frac{5}{7}\\end{bmatrix}$，$p_2&#x3D;\\begin{bmatrix}1\\-\\frac{22}{49}\\-\\frac{46}{49}\\end{bmatrix}$，$p_3&#x3D;\\begin{bmatrix}2\\-1\\-2\\end{bmatrix}$。</p>\n<p>故变换矩阵 $\\bold{P}&#x3D;\\begin{bmatrix}1&amp;1&amp;2\\-\\frac{3}{7}&amp;-\\frac{22}{49}&amp;-1\\-\\frac{5}{7}&amp;-\\frac{46}{49}&amp;-2\\end{bmatrix}$，求逆有 $\\bold{P}^{-1}&#x3D;\\begin{bmatrix}2&amp;-6&amp;5\\7&amp;28&amp;-7\\-4&amp;-11&amp;1\\end{bmatrix}$。</p>\n<p>则矩阵指数为</p>\n<p> $\\begin{aligned}e^{\\bold{A}t}&amp;&#x3D;\\bold{P}\\begin{bmatrix} e^{-t}&amp;te^{-t}&amp;0\\ 0&amp;e^{t}&amp;0\\0&amp;0&amp;e^{2t}\\end{bmatrix}\\bold{P}^{-1}\\&amp;&#x3D;\\begin{bmatrix} 9e^{t}+7te^{t}-8e^{2t}&amp;22e^{t}+28te^{t}+-22e^{2t}&amp;-2e^{t}-7te^{t}+2e^{2t}\\ -4e^{t}-3te^{t}+4e^{2t}&amp;-10e^{t}-12te^{t}+11e^{2t}&amp;e^{t}+3te^{t}-e^{2t}\\-8e^{t}-5te^{t}+8e^{2t}&amp;-22e^{t}-20te^{t}-22e^{2t}&amp;3e^{t}+5te^{t}-2e^{2t}\\end{bmatrix}\\end{aligned}$。</p>\n<p>;;;</p>\n<p>+++</p>\n<ol start=\"4\">\n<li>化矩阵指数为矩阵$\\bold{A}$的有限项。</li>\n</ol>\n<p>该方法将矩阵指数表示为$e^{\\bold{A}t}&#x3D;a_0(t)\\bold{I}+a_1(t)\\bold{A}+\\cdots+a_{n-1}\\bold{A}^{n-1}$。</p>\n<p>当特征值两两互异时，</p>\n<p>$$\\begin{bmatrix}a_0(t)\\a_1(t)\\\\vdots\\a_{n-1}(t)\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;\\lambda_1&amp;\\cdots&amp;\\lambda_1^{n-1}\\1&amp;\\lambda_2&amp;\\cdots&amp;\\lambda_2^{n-1}\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\1&amp;\\lambda_n&amp;\\cdots&amp;\\lambda_n^{n-1}\\end{bmatrix}^{-1}\\begin{bmatrix}e^{\\lambda_1t}\\e^{\\lambda_2t}\\\\vdots\\e^{\\lambda_nt}\\end{bmatrix}    \\tag{6}$$</p>\n<p>当存在重特征值时（以三重根$\\lambda_1$和二重根$\\lambda_2$，其余根为单根为例），</p>\n<p>$$\\begin{bmatrix}a_0(t)\\a_1(t)\\a_2(t)\\a_3(t)\\a_4(t)\\a_5(t)\\\\vdots\\a_{n-1}(t)\\end{bmatrix}&#x3D;\\begin{bmatrix}0&amp;0&amp;1&amp;3\\lambda_1&amp;\\cdots&amp;\\frac{(n-1)(n-2)}{2!}\\lambda_1^{n-3}\\0&amp;1&amp;2\\lambda_1&amp;3\\lambda_1^2&amp;\\cdots&amp;\\frac{(n-1)}{1!}\\lambda_1^{n-2}\\1&amp;\\lambda_1&amp;\\lambda_1^2&amp;\\lambda_1^3&amp;\\cdots&amp;\\lambda_1^{n-1}\\0&amp;1&amp;2\\lambda_2&amp;3\\lambda_2^2&amp;\\cdots&amp;\\frac{(n-1)}{1!}\\lambda_2^{n-2}\\1&amp;\\lambda_2&amp;\\lambda_2^2&amp;\\lambda_2^3&amp;\\cdots&amp;\\lambda_2^{n-1}\\1&amp;\\lambda_3&amp;\\lambda_3^2&amp;\\lambda_3^3&amp;\\cdots&amp;\\lambda_3^{n-1}\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\1&amp;\\lambda_n&amp;\\lambda_n^2&amp;\\lambda_n^3&amp;\\cdots&amp;\\lambda_n^{n-1}\\end{bmatrix}^{-1}\\begin{bmatrix}\\frac{1}{2!}t^2e^{\\lambda_1t}\\\\frac{1}{1!}te^{\\lambda_1t}\\e^{\\lambda_1t}\\\\frac{1}{1!}te^{\\lambda_2t}\\e^{\\lambda_2t}\\e^{\\lambda_3t}\\\\vdots\\e^{\\lambda_{n-3}t}\\end{bmatrix}     \\tag{7}$$</p>\n<p>+++primary 证明：Cayley-Hamilton定理</p>\n<p>+++</p>\n<p>+++primary 解题步骤</p>\n<ol>\n<li><p>求解系统矩阵$\\bold{A}$的特征值 $\\lambda_1,\\lambda_2\\dots\\lambda_n$ 。</p>\n</li>\n<li><p>求解有限项，根据特征值的互异性分情况分析：</p>\n<ul>\n<li>当特征值两两互异时，直接根据$\\begin{bmatrix}a_0(t)\\a_1(t)\\\\vdots\\a_{n-1}(t)\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;\\lambda_1&amp;\\cdots&amp;\\lambda_1^{n-1}\\1&amp;\\lambda_2&amp;\\cdots&amp;\\lambda_2^{n-1}\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\1&amp;\\lambda_n&amp;\\cdots&amp;\\lambda_n^{n-1}\\end{bmatrix}^{-1}\\begin{bmatrix}e^{\\lambda_1t}\\e^{\\lambda_2t}\\\\vdots\\e^{\\lambda_nt}\\end{bmatrix}$求解有限项。</li>\n<li>当特征值存在重根时，对于单根部分列写方程：</li>\n</ul>\n</li>\n</ol>\n<p>$$e^{\\lambda_it}&#x3D;a_0(t)+a_1(t)\\lambda_i+\\cdots+a_{n-1}(t)\\lambda_i^{n-1}$$</p>\n<p>而对于$k$重根部分在列写方程$e^{\\lambda_it}&#x3D;a_0(t)+a_1(t)\\lambda_i+\\cdots+a_{k-1}(t)\\lambda_i^{k-1}$外还需要补充方程：</p>\n<p>$$\\left{ \\begin{matrix} te^{\\lambda_it}&#x3D;a_1(t)+2a_2(t)\\lambda_i+\\cdots+(k-1)a_{k-1}(t)\\lambda_i^{k-2}\\t^2e^{\\lambda_it}&#x3D;2a_2(t)+6a_3(t)\\lambda_i+\\cdots+(k-1)(k-2)a_{k-1}(t)\\lambda_i^{k-3} \\\\vdots\\t^{k-1}e^{\\lambda_it}&#x3D;(k-1)!a_{k-1}(t) \\\\end{matrix}\\right.$$</p>\n<p>联立$n$条方程求解有限项</p>\n<ol start=\"3\">\n<li>代入求解矩阵指数：</li>\n</ol>\n<p>$$e^{\\bold{A}t}&#x3D;a_0(t)\\bold{I}+a_1(t)\\bold{A}+\\cdots+a_{n-1}\\bold{A}^{n-1}$$</p>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id5 例题1</p>\n<p>:::info </p>\n<p>试求矩阵$\\bold{A}&#x3D;\\begin{bmatrix}0&amp;1&amp;0\\0&amp;0&amp;1\\2&amp;3&amp;0\\end{bmatrix}$的矩阵指数，利用化为有限项法求解。</p>\n<p>:::</p>\n<p>求解特征值$|\\lambda\\bold{I}-\\bold{A}|&#x3D;\\begin{vmatrix}\\lambda&amp;-1&amp;0\\0&amp;\\lambda&amp;-1\\-2&amp;-3&amp;\\lambda\\end{vmatrix}&#x3D;(\\lambda+1)^2(\\lambda-2)$，得到特征值为$\\lambda_{1,2}&#x3D;-1$，$\\lambda_3&#x3D;2$。</p>\n<p>对于单根 $\\lambda_3&#x3D;2$，有 $e^{2t}&#x3D;a_0(t)+2a_1(t)+4a_2(t)$，</p>\n<p>对于二重根$\\lambda_{1,2}&#x3D;-1$，有 $e^{-t}&#x3D;a_0(t)-a_1(t)+a_2(t)$，还需要补充方程：</p>\n<p>$$ te^{-t}&#x3D;a_1(t)-2a_2(t)$$</p>\n<p>联立三组方程解得：</p>\n<p>$$\\left{ \\begin{matrix} a_0(t)&#x3D;\\frac{1}{9}(e^{2t}+8e^{-t}+6te^{-t})\\ a_1(t)&#x3D;\\frac{1}{9}(2e^{2t}-2e^{-t}+3te^{-t}) \\ a_3(t)&#x3D;\\frac{1}{9}(e^{2t}-e^{-t}-3te^{-t}) \\\\end{matrix}\\right.$$</p>\n<p> $$\\begin{aligned}e^{\\bold{A}t}&amp;&#x3D;a_0(t)\\bold{I}+a_1(t)\\bold{A}+\\cdots+a_{n-1}\\bold{A}^{n-1}\\&amp;&#x3D;\\frac{1}{9}\\begin{bmatrix} e^{2t}+(8+6t)e^{-t}&amp;e^{2t}-(2-3t)e^{-t}&amp;e^{2t}-(1+3t)e^{-t}\\ 2e^{2t}-(2+6t)e^{-t}&amp;4e^{2t}+(5-3t)e^{-t}&amp;2e^{2t}-(2-3t)e^{-t}\\4e^{2t}+(6-4t)e^{-t}&amp;8e^{2t}+(3-8t)e^{-t}&amp;4e^{2t}+(5-3t)e^{-t}\\end{bmatrix}\\end{aligned}$$</p>\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"线性时不变系统非齐次状态方程的解\"><a href=\"#线性时不变系统非齐次状态方程的解\" class=\"headerlink\" title=\"线性时不变系统非齐次状态方程的解\"></a>线性时不变系统非齐次状态方程的解</h2><p>动态系统在控制的作用下的运动称为受控运动。线性时不变系统非齐次状态方程的解即为线性时不变系统的受控运动。考虑系统 $\\dot{x}(t)&#x3D;Ax(t)+Bu(t),x(0),t\\geq0$，其动态响应形式为：</p>\n<p>$$x(t)&#x3D;e^{A(t-t_0)}x(t_0)+\\int_{t_0}^te^{A(t-\\tau)}Bu(\\tau),d\\tau,  t\\geq0   \\tag{8}$$</p>\n<p>可理解为由两部分组成：一部分是由初始状态引起的系统自由运动，即零输入响应；另外一部分是由控制输入所产生的受控运动，即零状态响应。</p>\n<p>+++primary 推导过程</p>\n<p>对于系统$\\dot{x}(t)&#x3D;Ax(t)+Bu(t),x(0),t\\geq0$，左乘$e^{-At}$后求导可得：</p>\n<p>$$\\frac{d}{dt}[e^{-At}x(t)]&#x3D;e^{-At}[\\dot{x}(t)-Ax(t)]&#x3D;e^{-At}Bu(t)$$</p>\n<p>两边积分得：</p>\n<p>$$\\int_0^t{\\frac{d}{dt}[e^{-At}x(t)]}d\\tau&#x3D;\\int_0^te^{-At}Bu(t)d\\tau$$</p>\n<p>$$e^{-At}x(t)-x(0)I&#x3D;\\int_0^te^{-At}Bu(t)d\\tau$$</p>\n<p>$$x(t)&#x3D;e^{A(t-t_0)}x(t_0)+\\int_{t_0}^te^{A(t-\\tau)}Bu(\\tau),d\\tau,  t\\geq0$$</p>\n<p>+++</p>\n<h2 id=\"线性时不变系统的状态转移矩阵\"><a href=\"#线性时不变系统的状态转移矩阵\" class=\"headerlink\" title=\"线性时不变系统的状态转移矩阵\"></a>线性时不变系统的状态转移矩阵</h2><p>在线性时不变系统解 $x(t)&#x3D;e^{A(t-t_0)}x(t_0)+\\int_{t_0}^te^{A(t-\\tau)}Bu(\\tau),d\\tau,  t\\geq0$ 中，定义状态转移矩阵$\\Phi(t,t_0)&#x3D;e^{A(t-t_0)}$。</p>\n<p>+++ 注</p>\n<ol>\n<li>线性时不变系统的状态转移矩阵可记为：$\\Phi(t,t_0)&#x3D;\\Phi{(t-t_0)}$。</li>\n<li>$x(t)$是由初始值引起的零输入解和控制产生的零状态解的叠加。</li>\n<li>解的结构显示了从$x(t_0)$到$x(t)$的一种变换关系。</li>\n</ol>\n<p>+++</p>\n<p>+++ 线性连续系统的状态转移矩阵</p>\n<ol>\n<li>定义</li>\n</ol>\n<p>对于线性连续系统的状态方程：$\\dot{x}(t)&#x3D;A(t)x(t)+B(t)u(t),x(t_0)&#x3D;x_0,A(t)\\in{R^{n\\times{n}}}$，那么称满足以下矩阵方程的解$\\Phi(t,t_0)$为系统的状态转移矩阵。</p>\n<p>$$\\dot{\\Phi}(t,t_0)&#x3D;A(t)\\Phi(t,t_0),\\Phi(t_0,t_0)&#x3D;I,t\\geq{t_0}    \\tag{9}$$</p>\n<ol start=\"2\">\n<li>状态转移矩阵的性质</li>\n</ol>\n<ul>\n<li>$\\frac{d\\Phi(t,t_0)}{dt}&#x3D;A(t)\\Phi(t,t_0),\\Phi(t_0,t_0)&#x3D;I$</li>\n</ul>\n<ul>\n<li>$\\Phi(t_2,t_1)\\Phi(t_1,t_0)&#x3D;\\Phi(t_2,t_0)$</li>\n</ul>\n<ul>\n<li>$\\Phi(mt)&#x3D;\\Phi(t+t+\\cdots+t)&#x3D;[\\Phi(t)]^m$</li>\n</ul>\n<p>+++</p>\n<h2 id=\"线性时变系统状态方程的解\"><a href=\"#线性时变系统状态方程的解\" class=\"headerlink\" title=\"线性时变系统状态方程的解*\"></a>线性时变系统状态方程的解*</h2><h3 id=\"线性时变系统齐次状态方程的解\"><a href=\"#线性时变系统齐次状态方程的解\" class=\"headerlink\" title=\"线性时变系统齐次状态方程的解\"></a>线性时变系统齐次状态方程的解</h3><h3 id=\"线性时变系统的状态转移矩阵\"><a href=\"#线性时变系统的状态转移矩阵\" class=\"headerlink\" title=\"线性时变系统的状态转移矩阵\"></a>线性时变系统的状态转移矩阵</h3><h3 id=\"线性时变系统非齐次状态方程的解\"><a href=\"#线性时变系统非齐次状态方程的解\" class=\"headerlink\" title=\"线性时变系统非齐次状态方程的解\"></a>线性时变系统非齐次状态方程的解</h3><h2 id=\"线性连续系统的时间离散化\"><a href=\"#线性连续系统的时间离散化\" class=\"headerlink\" title=\"线性连续系统的时间离散化\"></a>线性连续系统的时间离散化</h2><p>线性连续系统的时间离散化问题本质上就是在一定的采样方式和保持方式下，由系统的连续时间状态空间描述来得到对应的离散时间状态空间描述，并建立两者的系数矩阵间的关系式。</p>\n<h3 id=\"近似离散化\"><a href=\"#近似离散化\" class=\"headerlink\" title=\"近似离散化\"></a>近似离散化</h3><p>考虑以下线性时变系统：$\\dot{x}(t)&#x3D;A(t)x(t)+B(t)u(t)$，当采样周期$T$较小且精度要求不高时，可将其离散化为：</p>\n<p>$$\\dot{x}(kT)\\approx \\frac{1}{T}[x((k+1)T)-x(kT)]    \\tag{10}$$</p>\n<p>令$t&#x3D;kT$，有</p>\n<p>$$\\frac{1}{T}[x((k+1)T)-x(kT)]&#x3D;A(kT)x(kT)+B(kT)u(kT)$$</p>\n<p>$$\\begin{aligned}x[(k+1)T]&amp;&#x3D;[I+TA(kT)]x(kT)+TB(kT)u(kT)\\&amp;&#x3D;G(kT)x(kT)+H(kT)u(kT)\\end{aligned}$$</p>\n<p>其中，$G(kT)&#x3D;I+TA(kT)$，$H(kT)&#x3D;TB(kT)$。</p>\n<p>:::info</p>\n<p>注：一般而言，当采样周期为系统最小时间系数的$\\frac{1}{10}$左右，近似度已经足够。</p>\n<p>:::</p>\n<p>+++info 例题</p>\n<p>;;;id6 例题1</p>\n<p>:::info </p>\n<p>系统的状态方程为$\\dot{x}(t)&#x3D;A(t)x(t)+B(t)u(t)$，其中$A(t)&#x3D;\\begin{bmatrix}0&amp;5(1-e^{-5t})\\0&amp;5(e^{-5t}-1)\\end{bmatrix}$，$B(t)&#x3D;\\begin{bmatrix}5&amp;5e^{-5t}\\0&amp;5(1-e^{-5t})\\end{bmatrix}$。试求采样周期为$T&#x3D;0.2s$时的离散状态方程。</p>\n<p>:::</p>\n<p>直接代入公式有：</p>\n<p>$$G(kT)&#x3D;I+TA(kT)&#x3D;\\begin{bmatrix}1&amp;1-e^{-k}\\0&amp;e^{-k}\\end{bmatrix}$$</p>\n<p>$$H(kT)&#x3D;TB(kT)&#x3D;\\begin{bmatrix}1&amp;e^{-k}\\0&amp;1-e^{-k}\\end{bmatrix}$$</p>\n<p>那么，离散状态方程为：$x[(k+1)T]&#x3D;G(kT)x(kT)+H(kT)u(kT)$</p>\n<p>;;;</p>\n<p>;;;id6 例题2</p>\n<p>:::info</p>\n<p>将状态方程$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1\\-2&amp;-3\\end{bmatrix}x+\\begin{bmatrix}0\\1\\end{bmatrix}u$ 近似离散化，$T&#x3D;0.2s$。</p>\n<p>:::</p>\n<p>由题：$G&#x3D;I+TA&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}+0.2\\begin{bmatrix}0&amp;1\\-2&amp;-3\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0.2\\-0.4&amp;0.4\\end{bmatrix}$，$H&#x3D;0.2\\begin{bmatrix}0\\1\\end{bmatrix}&#x3D;\\begin{bmatrix}0\\0.2\\end{bmatrix}$。</p>\n<p>故离散状态方程为：</p>\n<p>$$$x[0.2(k+1)]&#x3D;\\begin{bmatrix}1&amp;0.2\\-0.4&amp;0.4\\end{bmatrix}x(0.2k)+\\begin{bmatrix}0\\0.2\\end{bmatrix}u(0.2k)$$$</p>\n<p>;;;</p>\n<p>+++</p>\n<h3 id=\"线性时不变系统状态方程的离散化\"><a href=\"#线性时不变系统状态方程的离散化\" class=\"headerlink\" title=\"线性时不变系统状态方程的离散化\"></a>线性时不变系统状态方程的离散化</h3><p>在线性时不变系统中，$\\dot{x}(t)&#x3D;A(x)+B(u)$，其时间离散化状态方程为：</p>\n<p>$$x[(k+1)T]&#x3D;Gx(kT)+Hu(kT)    \\tag{11}$$</p>\n<p>其中$G&#x3D;e^{AT}$，$H&#x3D;(\\int_0^Te^{AT}dt)B$。假设条件为：(1)等采样周期$T$；(2)$u(t)\\equiv u(kT),kT\\leq t\\leq (k+1)T$。</p>\n<p>+++primary 推导证明</p>\n<p>对于线性时不变系统 $\\dot{x}(t)&#x3D;A(x)+B(u)$，其状态方程的解为：</p>\n<p>$$x(t)&#x3D;e^{A(t-t_0)}x(t_0)+\\int e^{A(t-\\tau)}Bu(\\tau)d\\tau    \\tag{12}$$</p>\n<p>假设：(1)等采样周期$T$；(2)$x(k)&#x3D;[x(t)]<em>{t&#x3D;kT}$，$u(k)&#x3D;[u(t)]</em>{t&#x3D;kT}$</p>\n<p>那么令 $t&#x3D;(k+1)T$，$t_0&#x3D;kT$，有：</p>\n<p>$$\\begin{aligned}x[(k+1)T]&amp;&#x3D;e^{AT}x(kT)+\\int_{kT}^{(k+1)T}e^{A[(k+1)T-\\tau]}Bu(\\tau)d\\tau\\&amp;&#x3D;e^{AT}x(kT)+\\int_{kT}^{(k+1)T}e^{A[(k+1)T-\\tau]}Bd\\tau \\cdot u(kT)\\end{aligned}$$</p>\n<p>令 $t&#x3D;(k+1)T-\\tau$，$d\\tau &#x3D;-dt$，有：</p>\n<p>$$\\begin{aligned}x[(k+1)T]&amp;&#x3D;e^{AT}x(kT)+\\int_{0}^{\\tau}e^{A(t)}Bdt\\cdot u(kT)\\&amp;&#x3D;e^{AT}x(kT)+\\int_{0}^{\\tau}e^{A(t)}dt\\cdot Bu(kT)\\end{aligned}$$</p>\n<p>令$G&#x3D;e^{AT}$，$H&#x3D;(\\int_0^Te^{AT}dt)B$，有线性时不变系统的离散状态方程为：</p>\n<p>$$x[(k+1)T]&#x3D;Gx(kT)+Hu(kT)$$</p>\n<p>+++</p>\n<p>+++primary 解题步骤</p>\n<ol>\n<li>求解矩阵指数，方法见<a href=\"#%E7%9F%A9%E9%98%B5%E6%8C%87%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97\">矩阵指数的计算</a>。</li>\n<li>求解系数矩阵：$G&#x3D;e^{AT}$，$H&#x3D;(\\int_0^Te^{AT}dt)B$。</li>\n<li>列写时间离散化状态方程：$x[(k+1)T]&#x3D;Gx(kT)+Hu(kT)$</li>\n</ol>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id7 例题1</p>\n<p>:::info</p>\n<p>将状态方程$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1\\0&amp;-2\\end{bmatrix}x+\\begin{bmatrix}0\\1\\end{bmatrix}u$ 离散化，$T&#x3D;0.1s$。</p>\n<p>:::</p>\n<p>利用拉氏变换法求解矩阵指数函数。取拉氏变换有：</p>\n<p>$$[sI-A]^{-1}&#x3D;\\begin{bmatrix}s&amp;-1\\0&amp;s+2\\end{bmatrix}^{-1}&#x3D;\\begin{bmatrix}\\frac{1}{s}&amp;\\frac{1}{s(s+2)}\\0&amp;\\frac{1}{s+2}\\end{bmatrix}$$</p>\n<p>取拉氏逆变换得到矩阵指数函数：</p>\n<p>$$e^{At}&#x3D;L^{-1}[sI-A]^{-1}&#x3D;\\begin{bmatrix}1&amp;0.5(1-e^{-2T})\\0&amp;e^{-2T}\\end{bmatrix}$$</p>\n<p>进而求解系数矩阵：</p>\n<p>$$G&#x3D;e^{AT}&#x3D;\\begin{bmatrix}1&amp;0.5(1-e^{-2T})\\0&amp;e^{-2T}\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0.091\\0&amp;0.819\\end{bmatrix}$$</p>\n<p>$$\\begin{aligned}H&amp;&#x3D;(\\int_0^Te^{AT}dt)B&#x3D;\\Bigg[\\int_0^T\\begin{bmatrix}1&amp;0.5(1-e^{-2T})\\0&amp;e^{-2T}\\end{bmatrix}dt\\Bigg]\\begin{bmatrix}0\\1\\end{bmatrix}\\&amp;&#x3D;\\begin{bmatrix}T&amp;0.5T+0.25e^{-2T}-0.25\\0&amp;-0.5e^{-2T}+0.5\\end{bmatrix}\\begin{bmatrix}0\\1\\end{bmatrix}&#x3D;\\begin{bmatrix}0.005\\0.091\\end{bmatrix}\\end{aligned}$$</p>\n<p>故时间离散化状态方程为：</p>\n<p>$x[0.1(k+1)]&#x3D;\\begin{bmatrix}1&amp;0.091\\0&amp;0.819\\end{bmatrix}x(0.1k)+\\begin{bmatrix}0.005\\0.091\\end{bmatrix}u(0.1k)$</p>\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"线性离散系统状态方程的解\"><a href=\"#线性离散系统状态方程的解\" class=\"headerlink\" title=\"线性离散系统状态方程的解\"></a>线性离散系统状态方程的解</h2><p>离散系统的差分方程形状态方程有两种解法：递推法和z变换法。其中递推法在时变系统和时不变系统中都适用，而z变换法只适用于时不变系统。</p>\n<h3 id=\"递推法\"><a href=\"#递推法\" class=\"headerlink\" title=\"递推法\"></a>递推法</h3><ol>\n<li>在线性时变系统中，$x(k+1)&#x3D;G(k)x(k)+H(k)u(k)$，有：</li>\n</ol>\n<p>$$\\left{ \\begin{matrix} x(1)&#x3D;G(0)x(0)+H(0)u(0)\\ x(2)&#x3D;G(1)x(1)+H(1)u(1) \\ x(3)&#x3D;G(2)x(2)+H(2)u(2) \\\\vdots \\end{matrix}\\right.$$</p>\n<p>给定初始条件$x(0)$和输入序列$u(0),u(1),\\cdots$后即可求解$x(k)$。</p>\n<ol start=\"2\">\n<li>在线性时不变系统中，$x(k+1)&#x3D;Gx(k)+Hu(k)$，其中$G,H$均为常数矩阵，因此：</li>\n</ol>\n<p>$$x(k)&#x3D;G^kx(0)+\\sum_{i&#x3D;0}^{k-1}G^{k-1-i}Hu(i)    \\tag{13}$$</p>\n<p>上式称为线性时不变离散系统的状态转移方程，其中$\\Phi(k)&#x3D;G^k$称为线性时不变离散系统的状态转移矩阵。</p>\n<p>状态转移矩阵的性质：</p>\n<ol>\n<li>$\\Phi(k+1)&#x3D;G\\Phi{k},\\Phi(0)&#x3D;I$</li>\n<li>$\\Phi(k_2-k_0)&#x3D;\\Phi(k_2-k_1)\\Phi(k_1-k_0)$</li>\n<li>$\\Phi^{-1}(k)&#x3D;\\Phi(-k)$</li>\n</ol>\n<h3 id=\"z-变换法\"><a href=\"#z-变换法\" class=\"headerlink\" title=\"z 变换法\"></a>z 变换法</h3><p>考虑时不变离散系统：$x(k+1)&#x3D;Gx(k)+Hu(k)$，取z变换有：</p>\n<p>$$zx(z)-zx(0)&#x3D;Gx(z)+Hu(z)$$</p>\n<p>$$z(z)&#x3D;(zI-G)^{-1}zx(0)+(zI-G)^{-1}Hu(z)   \\tag{14}$$</p>\n<p>取z逆变换有：</p>\n<p>$$x(k)&#x3D;z^{-1}\\Big[(zI-G)^{-1}z\\Big]x(0)+z^{-1}\\Big[(zI-G)^{-1}Hu(z)\\Big]    \\tag{15} $$</p>\n<p>对比公式（13）和公式（15），由解的唯一性可知，</p>\n<p>$$z^{-1}\\Big[(zI-G)^{-1}z\\Big]&#x3D;G^k    \\tag{16}$$</p>\n<p>$$z^{-1}\\Big[(zI-G)^{-1}Hu(z)\\Big]&#x3D;\\sum_{i&#x3D;0}^{k-1}G^{k-1-i}Hu(i)   \\tag{17}$$</p>\n<p>+++info 例题</p>\n<p>;;;id8 例题1</p>\n<p>:::info </p>\n<p>考虑离散系统：$x(k+1)&#x3D;Gx(k)+Hu(k)$，其中$G&#x3D;\\begin{bmatrix}0&amp;1\\-0.16&amp;-1\\end{bmatrix}$，$H&#x3D;\\begin{bmatrix}1\\1\\end{bmatrix}$，初始条件为$x(0)&#x3D;\\begin{bmatrix}1\\-1\\end{bmatrix}$，试求当$u(k)&#x3D;1$时状态方程的解。</p>\n<p>:::</p>\n<p>用z变换法求解，先计算$(zI-G)^{-1}$，有</p>\n<p>$$\\begin{aligned}(zI-G)^{-1}&amp;&#x3D;\\begin{bmatrix}z&amp;-1\\0.16&amp;z+1\\end{bmatrix}^{-1}&#x3D;\\frac{1}{(z+0.2)(z+0.8)}\\begin{bmatrix}z+1&amp;1\\-0.16&amp;z\\end{bmatrix}\\&amp;&#x3D;\\begin{bmatrix}\\frac{4}{3}\\times \\frac{1}{z+0.2}-\\frac{1}{3}\\times \\frac{1}{z+0.8}&amp;\\frac{5}{3}\\times \\frac{1}{z+0.2}-\\frac{5}{3}\\times \\frac{1}{z+0.8}\\-\\frac{0.8}{3}\\times \\frac{1}{z+0.2}+\\frac{0.8}{3}\\times \\frac{1}{z+0.8}&amp;-\\frac{1}{3}\\times \\frac{1}{z+0.2}+\\frac{4}{3}\\times \\frac{1}{z+0.8}\\end{bmatrix}\\end{aligned}$$</p>\n<p>由于$u(k)&#x3D;1$，则$u(z)&#x3D;\\frac{z}{z-1}$，故$zx(0)+Hu(z)&#x3D;\\begin{bmatrix}z\\-z\\end{bmatrix}+\\begin{bmatrix}\\frac{z}{z-1}\\\\frac{z}{z-1}\\end{bmatrix}&#x3D;\\begin{bmatrix}\\frac{z^2}{z-1}\\\\frac{-z^2+2z}{z-1}\\end{bmatrix}$。</p>\n<p>那么代入公式（15）有：</p>\n<p>$$\\begin{aligned}x(z)&amp;&#x3D;(zI-G)^{-1}[zx(0)+Hu(z)]\\&amp;&#x3D;\\begin{bmatrix}-\\frac{17}{6}\\times \\frac{z}{z+0.2}+\\frac{22}{9}\\times \\frac{z}{z+0.8}+\\frac{25}{18}\\times \\frac{z}{z-1}\\\\frac{3.4}{6}\\times \\frac{z}{z+0.2}-\\frac{17.6}{9}\\times \\frac{z}{z+0.8}+\\frac{7}{18}\\times \\frac{z}{z-1}\\end{bmatrix}\\end{aligned}$$</p>\n<p>求z逆变换有：</p>\n<p>$$x(k)&#x3D;\\begin{bmatrix}-\\frac{17}{6}(-0.2)^k+\\frac{22}{9}(-0.8)^k+\\frac{25}{18}\\\\frac{3.4}{6}(-0.2)^k-\\frac{17.6}{9}(-0.2)^k+\\frac{7}{18}\\end{bmatrix}$$</p>\n<p>;;;</p>\n<p>+++</p>\n","categories":["现代控制理论"],"tags":["状态方程的解","矩阵指数","状态转移矩阵","离散化"]},{"title":"test","url":"/2023/10/28/2023-10-29-test/","content":"<p>现代控制理论——03 状态方程的解</p>\n<span id=\"more\"></span>\n\n<p>+++primary 证明</p>\n<p>test</p>\n<p>+++</p>\n<p>+++primary  证明</p>\n<p>$e^{\\bold{A}t}&#x3D;\\bold{I}+\\bold{A}t+\\frac{1}{2!}\\bold{A}^2t^2+\\cdots$</p>\n<p>$&#x3D;\\begin{bmatrix} 1&amp;0&amp;\\cdots&amp;0\\ 0&amp;1&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;1\\end{bmatrix}+\\begin{bmatrix} \\lambda_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n\\end{bmatrix}t+\\frac{1}{2!}\\begin{bmatrix} \\lambda_1^2&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2^2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n^2\\end{bmatrix}t^2+\\cdots$</p>\n<p>$&#x3D;\\begin{bmatrix} \\sum^{+\\infty}<em>{n&#x3D;0}\\frac{1}{n!}\\lambda_1^nt^n&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\sum^{+\\infty}</em>{n&#x3D;0}\\frac{1}{n!}\\lambda_2^nt^n&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\sum^{+\\infty}_{n&#x3D;0}\\frac{1}{n!}\\lambda_n^nt^n\\end{bmatrix}&#x3D;\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}$。</p>\n<p>+++</p>\n<ol start=\"9\">\n<li>若$\\bold{A}$为$m\\times{m}$的若尔当块，即$\\bold{A}&#x3D;\\begin{bmatrix} \\lambda&amp;1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda&amp;1&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\lambda&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;\\lambda&amp;1\\ 0&amp;0&amp;\\cdots&amp;0&amp;\\lambda\\end{bmatrix}<em>{m\\times{m}}$，则$e^{\\bold{A}t}&#x3D;e^{\\lambda t}\\begin{bmatrix} 1&amp;t&amp;\\frac{t^{2}}{2!}&amp;\\cdots&amp;\\frac{t^{m-1}}{(m-1)!}\\ 0&amp;1&amp;t&amp;\\cdots&amp;\\frac{t^{m-2}}{(m-2)!}\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;1&amp;t\\ 0&amp;0&amp;\\cdots&amp;0&amp;1\\end{bmatrix}</em>{m\\times{m}}$。</li>\n</ol>\n<p>+++primary 若尔当块</p>\n<p>形如$\\begin{bmatrix} \\lambda&amp;1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda&amp;1&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\lambda&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;\\lambda&amp;1\\ 0&amp;0&amp;\\cdots&amp;0&amp;\\lambda\\end{bmatrix}_{m\\times{m}}$为$m$阶若尔当矩阵，1阶若尔当矩阵为$\\lambda$。</p>\n<p>+++</p>\n<ol start=\"10\">\n<li>若$\\bold{A}$为一个有多个若尔当块的若尔当矩阵（即若当标准型），即$\\bold{A}&#x3D;\\begin{bmatrix} \\bold{A}_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\bold{A}_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\bold{A}_n\\end{bmatrix}$，则$e^{\\bold{A}t}&#x3D;\\begin{bmatrix} e^{\\bold{A}_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\bold{A}_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\bold{A}_nt}\\end{bmatrix}$。</li>\n</ol>\n<h3 id=\"矩阵指数的计算\"><a href=\"#矩阵指数的计算\" class=\"headerlink\" title=\"矩阵指数的计算\"></a>矩阵指数的计算</h3><ol>\n<li>定义计算：$e^{\\bold{A}t}&#x3D;\\sum^{+\\infty}_{n&#x3D;0}\\frac{1}{n!}\\bold{A}^n(t)^n$。该方法适用于计算机运算。</li>\n</ol>\n<p>+++info  例题</p>\n<p>;;;id1 例题1</p>\n<p>:::info </p>\n<p>已知$\\bold{A}&#x3D;\\begin{bmatrix} 0&amp;1\\-1&amp;0\\end{bmatrix}$，求$e^{\\bold{A}t}$。</p>\n<p>:::</p>\n<p>由定义，</p>\n<p>$\\begin{aligned}e^{\\bold{A}t}&amp;&#x3D;\\bold{I}+\\bold{A}t+\\frac{1}{2!}+\\cdots&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}+\\begin{bmatrix}0&amp;t\\-t&amp;0\\end{bmatrix}+\\frac{1}{2!}\\begin{bmatrix}-t^2&amp;0\\0&amp;-t^2\\end{bmatrix}+\\cdots\\&amp;&#x3D;\\begin{bmatrix}1-\\frac{t^2}{2!}+\\cdots&amp;t-\\frac{t^3}{3!}+\\cdots\\-t+\\frac{t^3}{3!}-\\cdots&amp;1-\\frac{t^2}{2!}+\\cdots\\end{bmatrix}&#x3D;\\begin{bmatrix} \\cos{t}&amp;\\sin{t}\\-\\sin{t}&amp;\\cos{t}\\end{bmatrix}\\end{aligned}$.</p>\n<p>;;; </p>\n<p>+++</p>\n<ol start=\"2\">\n<li>拉氏变换法：利用拉氏变换在频域中求解齐次状态方程的解。</li>\n</ol>\n<p>设线性时不变齐次状态方程为 $\\bold{\\dot{x}}&#x3D;\\bold{Ax}(t)$，$\\bold{x}(0)&#x3D;\\bold{x}_0$，$t\\geq{t_0}$。</p>\n<p>作拉氏变换有 $s\\bold{X}(s)-\\bold{x}(0)&#x3D;\\bold{AX}(s)$，即 $(s\\bold{I}-\\bold{A})\\bold{X}(s)&#x3D;\\bold{x}(0)$，那么 </p>\n<p>$$\\bold{X}(s) &#x3D;(s\\bold{I}-\\bold{A})^{-1}\\bold{x}(0)$$</p>\n<p>取拉氏逆变换有 $\\bold{x}(0)&#x3D;L^{-1}[(s\\bold{I}-\\bold{A})^{-1}\\bold{x}(0)]&#x3D;L^{-1}[(s\\bold{I}-\\bold{A})^{-1}]\\bold{x}(0)$，因此 </p>\n<p>$$e^{\\bold{A}t}&#x3D;L^{-1}[(s\\bold{I}-\\bold{A})^{-1}]     \\tag{2}$$</p>\n<p>+++info 例题</p>\n<p>;;;id2 例题1</p>\n<p>:::info</p>\n<p>计算矩阵 $\\bold{A}&#x3D;\\begin{bmatrix}0&amp;1\\-2&amp;-3\\end{bmatrix}$的矩阵指数。</p>\n<p>:::</p>\n<p>由拉氏变换法，$(s\\bold{I}-\\bold{A})&#x3D;\\begin{bmatrix} s&amp;-1\\2&amp;s+3\\end{bmatrix}$，则$(s\\bold{I}-\\bold{A})^{-1}&#x3D;\\begin{bmatrix}\\frac{s+3}{(s+1)(s+2)}&amp;\\frac{1}{(s+1)(s+2)}\\\\frac{-2}{(s+1)(s+2)}&amp;\\frac{s}{(s+1)(s+2)}\\end{bmatrix}$，</p>\n<p>则 $e^{\\bold{A}t}&#x3D;L^{-1}\\begin{bmatrix}\\frac{s+3}{(s+1)(s+2)}&amp;\\frac{1}{(s+1)(s+2)}\\\\frac{-2}{(s+1)(s+2)}&amp;\\frac{s}{(s+1)(s+2)}\\end{bmatrix}&#x3D;\\begin{bmatrix}2e^{-t}&amp;e^{-t}-e^{-2t}\\-2e^{-t}+2e^{-2t}&amp;-e^{-t}+2e^{-2t}\\end{bmatrix}$。</p>\n<p>;;;</p>\n<p>+++</p>\n<ol start=\"3\">\n<li>将矩阵化为对角标准型或若尔当标准型。</li>\n</ol>\n<p>若$\\bold{A}&#x3D;\\begin{bmatrix} \\lambda_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n\\end{bmatrix}$为对角矩阵，则$e^{\\bold{A}t}$也为对角矩阵（<a href=\"#%E7%9F%A9%E9%98%B5%E6%8C%87%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8\">性质8</a>），即$e^{\\bold{A}t}&#x3D;\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}$。</p>\n<p>（1）当矩阵$\\bold{A}$的 $n$ 个特征值 $\\lambda_1,\\lambda_2\\dots\\lambda_n$ 均两两互异时，则可确定变换阵 $\\bold{P}$ 及其逆矩阵 $\\bold{P}^{-1}$ ，使得矩阵$\\bold{A}$对角化：$\\bold{A} &#x3D; \\bold{P}\\begin{bmatrix}\\lambda_1&amp;0&amp;\\cdots&amp;0\\ 0&amp;\\lambda_2&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;\\lambda_n\\end{bmatrix}\\bold{P}^{-1}$，则有 </p>\n<p>$$e^{\\bold{A}t}&#x3D;\\bold{P}\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}\\bold{P}^{-1}   \\tag{3}$$</p>\n<p>+++primary 解题步骤</p>\n<ol>\n<li>求解系统矩阵$\\bold{A}$的特征值 $\\lambda_1,\\lambda_2\\dots\\lambda_n$ 。（特征值两两互异）</li>\n<li>求解特征值对应的特征向量$p_1,p_2\\dots p_n$，构造变换阵 $\\bold{P}$ 并求解其逆矩阵 $\\bold{P}^{-1}$ 。</li>\n<li>求解矩阵指数 $e^{\\bold{A}t}&#x3D;\\bold{P}\\begin{bmatrix} e^{\\lambda_1t}&amp;0&amp;\\cdots&amp;0\\ 0&amp;e^{\\lambda_2t}&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\ 0&amp;0&amp;\\cdots&amp;e^{\\lambda_nt}\\end{bmatrix}\\bold{P}^{-1}$。</li>\n</ol>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id3 例题1</p>\n<p>:::info </p>\n<p>试用化为对角标准型法求解矩阵$\\bold{A}&#x3D;\\begin{bmatrix}0&amp;1\\-2&amp;-3\\end{bmatrix}$的矩阵指数 $e^{\\bold{A}t}$。</p>\n<p>:::</p>\n<p>求解特征值$|\\lambda\\bold{I}-\\bold{A}|&#x3D;\\begin{vmatrix}\\lambda&amp;-1\\2&amp;\\lambda+3\\end{vmatrix}&#x3D;(\\lambda+1)(\\lambda+2)$，得到特征值为$\\lambda_1&#x3D;-1$，$\\lambda_2&#x3D;-2$。继而求解特征向量$p_1&#x3D;\\begin{bmatrix}1\\-1\\end{bmatrix}$，$p_2&#x3D;\\begin{bmatrix}1\\-2\\end{bmatrix}$。</p>\n<p>故变换矩阵 $\\bold{P}&#x3D;\\begin{bmatrix}1&amp;1\\-1&amp;-2\\end{bmatrix}$，求逆有 $\\bold{P}^{-1}&#x3D;\\begin{bmatrix}2&amp;1\\-1&amp;-1\\end{bmatrix}$。</p>\n<p>则矩阵指数为 $e^{\\bold{A}t}&#x3D;\\bold{P}\\begin{bmatrix} e^{-t}&amp;0\\ 0&amp;e^{-2t}\\end{bmatrix}\\bold{P}^{-1}&#x3D;\\begin{bmatrix} 2e^{-t}-e^{-2t}&amp;e^{-t}-e^{-2t}\\ -2e^{-t}+2e^{-2t}&amp;-e^{-t}+2e^{-2t}\\end{bmatrix}$。</p>\n<p>;;;</p>\n<p>;;;id3 例题2</p>\n<p>:::info </p>\n<p>试用化为对角标准型法求解矩阵$\\bold{A}&#x3D;\\begin{bmatrix}0&amp;1&amp;-1\\-6&amp;-11&amp;6\\-6&amp;-11&amp;5\\end{bmatrix}$的矩阵指数 $e^{\\bold{A}t}$。</p>\n<p>:::</p>\n<p>求解特征值$|\\lambda\\bold{I}-\\bold{A}|&#x3D;\\begin{vmatrix}\\lambda&amp;-1&amp;1\\6&amp;\\lambda+11&amp;-6\\6&amp;11&amp;\\lambda-5\\end{vmatrix}&#x3D;(\\lambda+1)(\\lambda+2)(\\lambda+3)$，得到特征值为$\\lambda_1&#x3D;-1$，$\\lambda_2&#x3D;-2$，$\\lambda_3&#x3D;-3$。继而求解特征向量$p_1&#x3D;\\begin{bmatrix}1\\0\\1\\end{bmatrix}$，$p_2&#x3D;\\begin{bmatrix}1\\2\\4\\end{bmatrix}$，$p_3&#x3D;\\begin{bmatrix}1\\6\\9\\end{bmatrix}$。</p>\n<p>故变换矩阵 $\\bold{P}&#x3D;\\begin{bmatrix}1&amp;1&amp;1\\0&amp;2&amp;6\\1&amp;4&amp;9\\end{bmatrix}$，求逆有 $\\bold{P}^{-1}&#x3D;\\begin{bmatrix}3&amp;\\frac{5}{2}&amp;-2\\-3&amp;-4&amp;3\\1&amp;\\frac{3}{2}&amp;-1\\end{bmatrix}$。</p>\n<p>则矩阵指数为 </p>\n<p>$\\begin{aligned}e^{\\bold{A}t}&amp;&#x3D;\\bold{P}\\begin{bmatrix} e^{-t}&amp;0&amp;0\\ 0&amp;e^{-2t}&amp;0\\0&amp;0&amp;e^{-3t}\\end{bmatrix}\\bold{P}^{-1}&#x3D;\\begin{bmatrix}1&amp;1&amp;1\\0&amp;2&amp;6\\1&amp;4&amp;9\\end{bmatrix}\\begin{bmatrix} e^{-t}&amp;0&amp;0\\ 0&amp;e^{-2t}&amp;0\\0&amp;0&amp;e^{-3t}\\end{bmatrix}\\begin{bmatrix}3&amp;\\frac{5}{2}&amp;-2\\-3&amp;-4&amp;3\\1&amp;\\frac{3}{2}&amp;-1\\end{bmatrix}\\&amp;&#x3D;\\begin{bmatrix} 3e^{-t}-3e^{-2t}+e^{-3t}&amp;\\frac{5}{2}e^{-t}-4e^{-2t}+\\frac{3}{2}e^{-3t}&amp;-2e^{-t}+3e^{-2t}-e^{-3t}\\ -6e^{-t}+6e^{-3t}&amp;-8e^{-2t}+9e^{-3t}&amp;6e^{-2t}-6e^{-3t}\\3e^{-t}-12e^{-2t}+9e^{-3t}&amp;\\frac{5}{2}e^{-t}-16e^{-2t}+\\frac{27}{2}e^{-3t}&amp;-2e^{-t}+12e^{-2t}-9e^{-3t}\\end{bmatrix}\\end{aligned}$。</p>\n<p>;;;</p>\n<p>+++</p>\n<p>（2）当 $n\\times{n}$ 矩阵$\\bold{A}$有$n$重特征根时，存在线性非奇异变换 $\\bold{P}$ 及其逆矩阵 $\\bold{P}^{-1}$ ，将矩阵 $\\bold{A}$ 转化为若尔当标准型：$\\bold{A} &#x3D; \\bold{P}\\begin{bmatrix}\\lambda&amp;1&amp;\\cdots&amp;0\\ 0&amp;\\lambda&amp;\\cdots&amp;0\\  \\vdots&amp;\\vdots&amp;\\ddots&amp;1\\ 0&amp;0&amp;\\cdots&amp;\\lambda\\end{bmatrix}_{n\\times{n}}\\bold{P}^{-1}$，则有 </p>\n<p>$$e^{\\bold{A}t}&#x3D;\\bold{P}e^{\\lambda t}\\begin{bmatrix} 1&amp;t&amp;\\frac{t^2}{2!}&amp;\\cdots&amp;\\frac{t^{n-1}}{(n-1)!}\\ 0&amp;1&amp;t&amp;\\cdots&amp;\\frac{t^{n-2}}{(n-2)!}\\  \\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;0&amp;\\cdots&amp;t\\ 0&amp;0&amp;0&amp;\\cdots&amp;1\\end{bmatrix}_{n\\times{n}}\\bold{P}^{-1}   \\tag{4}$$</p>\n<p>拓展到一般情况，矩阵$\\bold{A}$同时存在重特征根和单特征根时,以有三重根$\\lambda_1$、两重根$\\lambda_2$和单根$\\lambda_3$的矩阵$\\bold{A}$为例，若存在变换阵 $\\bold{P}$ 及其逆矩阵 $\\bold{P}^{-1}$ ，将矩阵 $\\bold{A}$ 转化为若尔当标准型：$\\bold{A} &#x3D; \\bold{P}\\begin{bmatrix}\\lambda_1&amp;1&amp;&amp;&amp;&amp;\\bold{0}\\ &amp;\\lambda_1&amp;1&amp;&amp;&amp;\\  &amp;&amp;\\lambda_1&amp;&amp;&amp;\\&amp;&amp;&amp;\\lambda_2&amp;1&amp;\\&amp;&amp;&amp;&amp;\\lambda_2&amp;\\\\bold{0}&amp;&amp;&amp;&amp;&amp;\\lambda_1\\end{bmatrix}\\bold{P}^{-1}$，则有 </p>\n<p>$$e^{\\bold{A}t}&#x3D;\\bold{P}\\begin{bmatrix}e^{\\lambda_1t}&amp;te^{\\lambda_1t}&amp;\\frac{1}{2}t^2e^{\\lambda_1t}&amp;0&amp;0&amp;0\\ 0&amp;e^{\\lambda_1t}&amp;te^{\\lambda_1t}&amp;0&amp;0&amp;0\\  0&amp;0&amp;e^{\\lambda_1t}&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;e^{\\lambda_2t}&amp;te^{\\lambda_2t}&amp;0\\0&amp;0&amp;0&amp;0&amp;e^{\\lambda_2t}&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;e^{\\lambda_3t}\\end{bmatrix}\\bold{P}^{-1}     \\tag{5}$$</p>\n<p>+++info 例题</p>\n<p>;;;id4 例题1</p>\n<p>:::info </p>\n<p>试求矩阵$\\bold{A}&#x3D;\\begin{bmatrix}0&amp;6&amp;-5\\1&amp;0&amp;2\\3&amp;2&amp;4\\end{bmatrix}$的矩阵指数。</p>\n<p>:::</p>\n<p>求解特征值$|\\lambda\\bold{I}-\\bold{A}|&#x3D;\\begin{vmatrix}\\lambda&amp;-6&amp;5\\-1&amp;\\lambda&amp;-2\\-3&amp;-2&amp;\\lambda-4\\end{vmatrix}&#x3D;(\\lambda-1)^2(\\lambda-2)$，得到特征值为$\\lambda_1&#x3D;\\lambda_2&#x3D;1$，$\\lambda_3&#x3D;2$。继而求解特征向量和广义特征向量$p_1&#x3D;\\begin{bmatrix}1\\-\\frac{3}{7}\\-\\frac{5}{7}\\end{bmatrix}$，$p_2&#x3D;\\begin{bmatrix}1\\-\\frac{22}{49}\\-\\frac{46}{49}\\end{bmatrix}$，$p_3&#x3D;\\begin{bmatrix}2\\-1\\-2\\end{bmatrix}$。</p>\n<p>故变换矩阵 $\\bold{P}&#x3D;\\begin{bmatrix}1&amp;1&amp;2\\-\\frac{3}{7}&amp;-\\frac{22}{49}&amp;-1\\-\\frac{5}{7}&amp;-\\frac{46}{49}&amp;-2\\end{bmatrix}$，求逆有 $\\bold{P}^{-1}&#x3D;\\begin{bmatrix}2&amp;-6&amp;5\\7&amp;28&amp;-7\\-4&amp;-11&amp;1\\end{bmatrix}$。</p>\n<p>则矩阵指数为</p>\n<p> $\\begin{aligned}e^{\\bold{A}t}&amp;&#x3D;\\bold{P}\\begin{bmatrix} e^{-t}&amp;te^{-t}&amp;0\\ 0&amp;e^{t}&amp;0\\0&amp;0&amp;e^{2t}\\end{bmatrix}\\bold{P}^{-1}\\&amp;&#x3D;\\begin{bmatrix} 9e^{t}+7te^{t}-8e^{2t}&amp;22e^{t}+28te^{t}+-22e^{2t}&amp;-2e^{t}-7te^{t}+2e^{2t}\\ -4e^{t}-3te^{t}+4e^{2t}&amp;-10e^{t}-12te^{t}+11e^{2t}&amp;e^{t}+3te^{t}-e^{2t}\\-8e^{t}-5te^{t}+8e^{2t}&amp;-22e^{t}-20te^{t}-22e^{2t}&amp;3e^{t}+5te^{t}-2e^{2t}\\end{bmatrix}\\end{aligned}$。</p>\n<p>;;;</p>\n<p>+++</p>\n<ol start=\"4\">\n<li>化矩阵指数为矩阵$\\bold{A}$的有限项。</li>\n</ol>\n<p>该方法将矩阵指数表示为$e^{\\bold{A}t}&#x3D;a_0(t)\\bold{I}+a_1(t)\\bold{A}+\\cdots+a_{n-1}\\bold{A}^{n-1}$。</p>\n<p>当特征值两两互异时，</p>\n<p>$$\\begin{bmatrix}a_0(t)\\a_1(t)\\\\vdots\\a_{n-1}(t)\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;\\lambda_1&amp;\\cdots&amp;\\lambda_1^{n-1}\\1&amp;\\lambda_2&amp;\\cdots&amp;\\lambda_2^{n-1}\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\1&amp;\\lambda_n&amp;\\cdots&amp;\\lambda_n^{n-1}\\end{bmatrix}^{-1}\\begin{bmatrix}e^{\\lambda_1t}\\e^{\\lambda_2t}\\\\vdots\\e^{\\lambda_nt}\\end{bmatrix}    \\tag{6}$$</p>\n<p>当存在重特征值时（以三重根$\\lambda_1$和二重根$\\lambda_2$，其余根为单根为例），</p>\n<p>$$\\begin{bmatrix}a_0(t)\\a_1(t)\\a_2(t)\\a_3(t)\\a_4(t)\\a_5(t)\\\\vdots\\a_{n-1}(t)\\end{bmatrix}&#x3D;\\begin{bmatrix}0&amp;0&amp;1&amp;3\\lambda_1&amp;\\cdots&amp;\\frac{(n-1)(n-2)}{2!}\\lambda_1^{n-3}\\0&amp;1&amp;2\\lambda_1&amp;3\\lambda_1^2&amp;\\cdots&amp;\\frac{(n-1)}{1!}\\lambda_1^{n-2}\\1&amp;\\lambda_1&amp;\\lambda_1^2&amp;\\lambda_1^3&amp;\\cdots&amp;\\lambda_1^{n-1}\\0&amp;1&amp;2\\lambda_2&amp;3\\lambda_2^2&amp;\\cdots&amp;\\frac{(n-1)}{1!}\\lambda_2^{n-2}\\1&amp;\\lambda_2&amp;\\lambda_2^2&amp;\\lambda_2^3&amp;\\cdots&amp;\\lambda_2^{n-1}\\1&amp;\\lambda_3&amp;\\lambda_3^2&amp;\\lambda_3^3&amp;\\cdots&amp;\\lambda_3^{n-1}\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\1&amp;\\lambda_n&amp;\\lambda_n^2&amp;\\lambda_n^3&amp;\\cdots&amp;\\lambda_n^{n-1}\\end{bmatrix}^{-1}\\begin{bmatrix}\\frac{1}{2!}t^2e^{\\lambda_1t}\\\\frac{1}{1!}te^{\\lambda_1t}\\e^{\\lambda_1t}\\\\frac{1}{1!}te^{\\lambda_2t}\\e^{\\lambda_2t}\\e^{\\lambda_3t}\\\\vdots\\e^{\\lambda_{n-3}t}\\end{bmatrix}     \\tag{7}$$</p>\n<p>+++primary 证明：Cayley-Hamilton定理</p>\n<p>+++</p>\n<p>+++primary 解题步骤</p>\n<ol>\n<li><p>求解系统矩阵$\\bold{A}$的特征值 $\\lambda_1,\\lambda_2\\dots\\lambda_n$ 。</p>\n</li>\n<li><p>求解有限项，根据特征值的互异性分情况分析：</p>\n<ul>\n<li>当特征值两两互异时，直接根据$\\begin{bmatrix}a_0(t)\\a_1(t)\\\\vdots\\a_{n-1}(t)\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;\\lambda_1&amp;\\cdots&amp;\\lambda_1^{n-1}\\1&amp;\\lambda_2&amp;\\cdots&amp;\\lambda_2^{n-1}\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\1&amp;\\lambda_n&amp;\\cdots&amp;\\lambda_n^{n-1}\\end{bmatrix}^{-1}\\begin{bmatrix}e^{\\lambda_1t}\\e^{\\lambda_2t}\\\\vdots\\e^{\\lambda_nt}\\end{bmatrix}$求解有限项。</li>\n<li>当特征值存在重根时，对于单根部分列写方程：</li>\n</ul>\n</li>\n</ol>\n<p>$$e^{\\lambda_it}&#x3D;a_0(t)+a_1(t)\\lambda_i+\\cdots+a_{n-1}(t)\\lambda_i^{n-1}$$</p>\n<p>而对于$k$重根部分在列写方程$e^{\\lambda_it}&#x3D;a_0(t)+a_1(t)\\lambda_i+\\cdots+a_{k-1}(t)\\lambda_i^{k-1}$外还需要补充方程：</p>\n<p>$$\\left{ \\begin{matrix} te^{\\lambda_it}&#x3D;a_1(t)+2a_2(t)\\lambda_i+\\cdots+(k-1)a_{k-1}(t)\\lambda_i^{k-2}\\t^2e^{\\lambda_it}&#x3D;2a_2(t)+6a_3(t)\\lambda_i+\\cdots+(k-1)(k-2)a_{k-1}(t)\\lambda_i^{k-3} \\\\vdots\\t^{k-1}e^{\\lambda_it}&#x3D;(k-1)!a_{k-1}(t) \\\\end{matrix}\\right.$$</p>\n<p>联立$n$条方程求解有限项</p>\n<ol start=\"3\">\n<li>代入求解矩阵指数：</li>\n</ol>\n<p>$$e^{\\bold{A}t}&#x3D;a_0(t)\\bold{I}+a_1(t)\\bold{A}+\\cdots+a_{n-1}\\bold{A}^{n-1}$$</p>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id5 例题1</p>\n<p>:::info </p>\n<p>试求矩阵$\\bold{A}&#x3D;\\begin{bmatrix}0&amp;1&amp;0\\0&amp;0&amp;1\\2&amp;3&amp;0\\end{bmatrix}$的矩阵指数，利用化为有限项法求解。</p>\n<p>:::</p>\n<p>求解特征值$|\\lambda\\bold{I}-\\bold{A}|&#x3D;\\begin{vmatrix}\\lambda&amp;-1&amp;0\\0&amp;\\lambda&amp;-1\\-2&amp;-3&amp;\\lambda\\end{vmatrix}&#x3D;(\\lambda+1)^2(\\lambda-2)$，得到特征值为$\\lambda_{1,2}&#x3D;-1$，$\\lambda_3&#x3D;2$。</p>\n<p>对于单根 $\\lambda_3&#x3D;2$，有 $e^{2t}&#x3D;a_0(t)+2a_1(t)+4a_2(t)$，</p>\n<p>对于二重根$\\lambda_{1,2}&#x3D;-1$，有 $e^{-t}&#x3D;a_0(t)-a_1(t)+a_2(t)$，还需要补充方程：</p>\n<p>$$ te^{-t}&#x3D;a_1(t)-2a_2(t)$$</p>\n<p>联立三组方程解得：</p>\n<p>$$\\left{ \\begin{matrix} a_0(t)&#x3D;\\frac{1}{9}(e^{2t}+8e^{-t}+6te^{-t})\\ a_1(t)&#x3D;\\frac{1}{9}(2e^{2t}-2e^{-t}+3te^{-t}) \\ a_3(t)&#x3D;\\frac{1}{9}(e^{2t}-e^{-t}-3te^{-t}) \\\\end{matrix}\\right.$$</p>\n<p> $$\\begin{aligned}e^{\\bold{A}t}&amp;&#x3D;a_0(t)\\bold{I}+a_1(t)\\bold{A}+\\cdots+a_{n-1}\\bold{A}^{n-1}\\&amp;&#x3D;\\frac{1}{9}\\begin{bmatrix} e^{2t}+(8+6t)e^{-t}&amp;e^{2t}-(2-3t)e^{-t}&amp;e^{2t}-(1+3t)e^{-t}\\ 2e^{2t}-(2+6t)e^{-t}&amp;4e^{2t}+(5-3t)e^{-t}&amp;2e^{2t}-(2-3t)e^{-t}\\4e^{2t}+(6-4t)e^{-t}&amp;8e^{2t}+(3-8t)e^{-t}&amp;4e^{2t}+(5-3t)e^{-t}\\end{bmatrix}\\end{aligned}$$</p>\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"线性时不变系统非齐次状态方程的解\"><a href=\"#线性时不变系统非齐次状态方程的解\" class=\"headerlink\" title=\"线性时不变系统非齐次状态方程的解\"></a>线性时不变系统非齐次状态方程的解</h2><p>动态系统在控制的作用下的运动称为受控运动。线性时不变系统非齐次状态方程的解即为线性时不变系统的受控运动。考虑系统 $\\dot{x}(t)&#x3D;Ax(t)+Bu(t),x(0),t\\geq0$，其动态响应形式为：</p>\n<p>$$x(t)&#x3D;e^{A(t-t_0)}x(t_0)+\\int_{t_0}^te^{A(t-\\tau)}Bu(\\tau),d\\tau,  t\\geq0   \\tag{8}$$</p>\n<p>可理解为由两部分组成：一部分是由初始状态引起的系统自由运动，即零输入响应；另外一部分是由控制输入所产生的受控运动，即零状态响应。</p>\n<p>+++primary 推导过程</p>\n<p>对于系统$\\dot{x}(t)&#x3D;Ax(t)+Bu(t),x(0),t\\geq0$，左乘$e^{-At}$后求导可得：</p>\n<p>$$\\frac{d}{dt}[e^{-At}x(t)]&#x3D;e^{-At}[\\dot{x}(t)-Ax(t)]&#x3D;e^{-At}Bu(t)$$</p>\n<p>两边积分得：</p>\n<p>$$\\int_0^t{\\frac{d}{dt}[e^{-At}x(t)]}d\\tau&#x3D;\\int_0^te^{-At}Bu(t)d\\tau$$</p>\n<p>$$e^{-At}x(t)-x(0)I&#x3D;\\int_0^te^{-At}Bu(t)d\\tau$$</p>\n<p>$$x(t)&#x3D;e^{A(t-t_0)}x(t_0)+\\int_{t_0}^te^{A(t-\\tau)}Bu(\\tau),d\\tau,  t\\geq0$$</p>\n<p>+++</p>\n<h2 id=\"线性时不变系统的状态转移矩阵\"><a href=\"#线性时不变系统的状态转移矩阵\" class=\"headerlink\" title=\"线性时不变系统的状态转移矩阵\"></a>线性时不变系统的状态转移矩阵</h2><p>在线性时不变系统解 $x(t)&#x3D;e^{A(t-t_0)}x(t_0)+\\int_{t_0}^te^{A(t-\\tau)}Bu(\\tau),d\\tau,  t\\geq0$ 中，定义状态转移矩阵$\\Phi(t,t_0)&#x3D;e^{A(t-t_0)}$。</p>\n<p>+++ 注</p>\n<ol>\n<li>线性时不变系统的状态转移矩阵可记为：$\\Phi(t,t_0)&#x3D;\\Phi{(t-t_0)}$。</li>\n<li>$x(t)$是由初始值引起的零输入解和控制产生的零状态解的叠加。</li>\n<li>解的结构显示了从$x(t_0)$到$x(t)$的一种变换关系。</li>\n</ol>\n<p>+++</p>\n<p>+++ 线性连续系统的状态转移矩阵</p>\n<ol>\n<li>定义</li>\n</ol>\n<p>对于线性连续系统的状态方程：$\\dot{x}(t)&#x3D;A(t)x(t)+B(t)u(t),x(t_0)&#x3D;x_0,A(t)\\in{R^{n\\times{n}}}$，那么称满足以下矩阵方程的解$\\Phi(t,t_0)$为系统的状态转移矩阵。</p>\n<p>$$\\dot{\\Phi}(t,t_0)&#x3D;A(t)\\Phi(t,t_0),\\Phi(t_0,t_0)&#x3D;I,t\\geq{t_0}    \\tag{9}$$</p>\n<ol start=\"2\">\n<li>状态转移矩阵的性质</li>\n</ol>\n<ul>\n<li>$\\frac{d\\Phi(t,t_0)}{dt}&#x3D;A(t)\\Phi(t,t_0),\\Phi(t_0,t_0)&#x3D;I$</li>\n</ul>\n<ul>\n<li>$\\Phi(t_2,t_1)\\Phi(t_1,t_0)&#x3D;\\Phi(t_2,t_0)$</li>\n</ul>\n<ul>\n<li>$\\Phi(mt)&#x3D;\\Phi(t+t+\\cdots+t)&#x3D;[\\Phi(t)]^m$</li>\n</ul>\n<p>+++</p>\n<h2 id=\"线性时变系统状态方程的解\"><a href=\"#线性时变系统状态方程的解\" class=\"headerlink\" title=\"线性时变系统状态方程的解*\"></a>线性时变系统状态方程的解*</h2><h3 id=\"线性时变系统齐次状态方程的解\"><a href=\"#线性时变系统齐次状态方程的解\" class=\"headerlink\" title=\"线性时变系统齐次状态方程的解\"></a>线性时变系统齐次状态方程的解</h3><h3 id=\"线性时变系统的状态转移矩阵\"><a href=\"#线性时变系统的状态转移矩阵\" class=\"headerlink\" title=\"线性时变系统的状态转移矩阵\"></a>线性时变系统的状态转移矩阵</h3><h3 id=\"线性时变系统非齐次状态方程的解\"><a href=\"#线性时变系统非齐次状态方程的解\" class=\"headerlink\" title=\"线性时变系统非齐次状态方程的解\"></a>线性时变系统非齐次状态方程的解</h3><h2 id=\"线性连续系统的时间离散化\"><a href=\"#线性连续系统的时间离散化\" class=\"headerlink\" title=\"线性连续系统的时间离散化\"></a>线性连续系统的时间离散化</h2><p>线性连续系统的时间离散化问题本质上就是在一定的采样方式和保持方式下，由系统的连续时间状态空间描述来得到对应的离散时间状态空间描述，并建立两者的系数矩阵间的关系式。</p>\n<h3 id=\"近似离散化\"><a href=\"#近似离散化\" class=\"headerlink\" title=\"近似离散化\"></a>近似离散化</h3><p>考虑以下线性时变系统：$\\dot{x}(t)&#x3D;A(t)x(t)+B(t)u(t)$，当采样周期$T$较小且精度要求不高时，可将其离散化为：</p>\n<p>$$\\dot{x}(kT)\\approx \\frac{1}{T}[x((k+1)T)-x(kT)]    \\tag{10}$$</p>\n<p>令$t&#x3D;kT$，有</p>\n<p>$$\\frac{1}{T}[x((k+1)T)-x(kT)]&#x3D;A(kT)x(kT)+B(kT)u(kT)$$</p>\n<p>$$\\begin{aligned}x[(k+1)T]&amp;&#x3D;[I+TA(kT)]x(kT)+TB(kT)u(kT)\\&amp;&#x3D;G(kT)x(kT)+H(kT)u(kT)\\end{aligned}$$</p>\n<p>其中，$G(kT)&#x3D;I+TA(kT)$，$H(kT)&#x3D;TB(kT)$。</p>\n<p>:::info</p>\n<p>注：一般而言，当采样周期为系统最小时间系数的$\\frac{1}{10}$左右，近似度已经足够。</p>\n<p>:::</p>\n<p>+++info 例题</p>\n<p>;;;id6 例题1</p>\n<p>:::info </p>\n<p>系统的状态方程为$\\dot{x}(t)&#x3D;A(t)x(t)+B(t)u(t)$，其中$A(t)&#x3D;\\begin{bmatrix}0&amp;5(1-e^{-5t})\\0&amp;5(e^{-5t}-1)\\end{bmatrix}$，$B(t)&#x3D;\\begin{bmatrix}5&amp;5e^{-5t}\\0&amp;5(1-e^{-5t})\\end{bmatrix}$。试求采样周期为$T&#x3D;0.2s$时的离散状态方程。</p>\n<p>:::</p>\n<p>直接代入公式有：</p>\n<p>$$G(kT)&#x3D;I+TA(kT)&#x3D;\\begin{bmatrix}1&amp;1-e^{-k}\\0&amp;e^{-k}\\end{bmatrix}$$</p>\n<p>$$H(kT)&#x3D;TB(kT)&#x3D;\\begin{bmatrix}1&amp;e^{-k}\\0&amp;1-e^{-k}\\end{bmatrix}$$</p>\n<p>那么，离散状态方程为：$x[(k+1)T]&#x3D;G(kT)x(kT)+H(kT)u(kT)$</p>\n<p>;;;</p>\n<p>;;;id6 例题2</p>\n<p>:::info</p>\n<p>将状态方程$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1\\-2&amp;-3\\end{bmatrix}x+\\begin{bmatrix}0\\1\\end{bmatrix}u$ 近似离散化，$T&#x3D;0.2s$。</p>\n<p>:::</p>\n<p>由题：$G&#x3D;I+TA&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}+0.2\\begin{bmatrix}0&amp;1\\-2&amp;-3\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0.2\\-0.4&amp;0.4\\end{bmatrix}$，$H&#x3D;0.2\\begin{bmatrix}0\\1\\end{bmatrix}&#x3D;\\begin{bmatrix}0\\0.2\\end{bmatrix}$。</p>\n<p>故离散状态方程为：</p>\n<p>$$$x[0.2(k+1)]&#x3D;\\begin{bmatrix}1&amp;0.2\\-0.4&amp;0.4\\end{bmatrix}x(0.2k)+\\begin{bmatrix}0\\0.2\\end{bmatrix}u(0.2k)$$$</p>\n<p>;;;</p>\n<p>+++</p>\n<h3 id=\"线性时不变系统状态方程的离散化\"><a href=\"#线性时不变系统状态方程的离散化\" class=\"headerlink\" title=\"线性时不变系统状态方程的离散化\"></a>线性时不变系统状态方程的离散化</h3><p>在线性时不变系统中，$\\dot{x}(t)&#x3D;A(x)+B(u)$，其时间离散化状态方程为：</p>\n<p>$$x[(k+1)T]&#x3D;Gx(kT)+Hu(kT)    \\tag{11}$$</p>\n<p>其中$G&#x3D;e^{AT}$，$H&#x3D;(\\int_0^Te^{AT}dt)B$。假设条件为：(1)等采样周期$T$；(2)$u(t)\\equiv u(kT),kT\\leq t\\leq (k+1)T$。</p>\n<p>+++primary 推导证明</p>\n<p>对于线性时不变系统 $\\dot{x}(t)&#x3D;A(x)+B(u)$，其状态方程的解为：</p>\n<p>$$x(t)&#x3D;e^{A(t-t_0)}x(t_0)+\\int e^{A(t-\\tau)}Bu(\\tau)d\\tau    \\tag{12}$$</p>\n<p>假设：(1)等采样周期$T$；(2)$x(k)&#x3D;[x(t)]<em>{t&#x3D;kT}$，$u(k)&#x3D;[u(t)]</em>{t&#x3D;kT}$</p>\n<p>那么令 $t&#x3D;(k+1)T$，$t_0&#x3D;kT$，有：</p>\n<p>$$\\begin{aligned}x[(k+1)T]&amp;&#x3D;e^{AT}x(kT)+\\int_{kT}^{(k+1)T}e^{A[(k+1)T-\\tau]}Bu(\\tau)d\\tau\\&amp;&#x3D;e^{AT}x(kT)+\\int_{kT}^{(k+1)T}e^{A[(k+1)T-\\tau]}Bd\\tau \\cdot u(kT)\\end{aligned}$$</p>\n<p>令 $t&#x3D;(k+1)T-\\tau$，$d\\tau &#x3D;-dt$，有：</p>\n<p>$$\\begin{aligned}x[(k+1)T]&amp;&#x3D;e^{AT}x(kT)+\\int_{0}^{\\tau}e^{A(t)}Bdt\\cdot u(kT)\\&amp;&#x3D;e^{AT}x(kT)+\\int_{0}^{\\tau}e^{A(t)}dt\\cdot Bu(kT)\\end{aligned}$$</p>\n<p>令$G&#x3D;e^{AT}$，$H&#x3D;(\\int_0^Te^{AT}dt)B$，有线性时不变系统的离散状态方程为：</p>\n<p>$$x[(k+1)T]&#x3D;Gx(kT)+Hu(kT)$$</p>\n<p>+++</p>\n<p>+++primary 解题步骤</p>\n<ol>\n<li>求解矩阵指数，方法见<a href=\"#%E7%9F%A9%E9%98%B5%E6%8C%87%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97\">矩阵指数的计算</a>。</li>\n<li>求解系数矩阵：$G&#x3D;e^{AT}$，$H&#x3D;(\\int_0^Te^{AT}dt)B$。</li>\n<li>列写时间离散化状态方程：$x[(k+1)T]&#x3D;Gx(kT)+Hu(kT)$</li>\n</ol>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id7 例题1</p>\n<p>:::info</p>\n<p>将状态方程$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1\\0&amp;-2\\end{bmatrix}x+\\begin{bmatrix}0\\1\\end{bmatrix}u$ 离散化，$T&#x3D;0.1s$。</p>\n<p>:::</p>\n<p>利用拉氏变换法求解矩阵指数函数。取拉氏变换有：</p>\n<p>$$[sI-A]^{-1}&#x3D;\\begin{bmatrix}s&amp;-1\\0&amp;s+2\\end{bmatrix}^{-1}&#x3D;\\begin{bmatrix}\\frac{1}{s}&amp;\\frac{1}{s(s+2)}\\0&amp;\\frac{1}{s+2}\\end{bmatrix}$$</p>\n<p>取拉氏逆变换得到矩阵指数函数：</p>\n<p>$$e^{At}&#x3D;L^{-1}[sI-A]^{-1}&#x3D;\\begin{bmatrix}1&amp;0.5(1-e^{-2T})\\0&amp;e^{-2T}\\end{bmatrix}$$</p>\n<p>进而求解系数矩阵：</p>\n<p>$$G&#x3D;e^{AT}&#x3D;\\begin{bmatrix}1&amp;0.5(1-e^{-2T})\\0&amp;e^{-2T}\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0.091\\0&amp;0.819\\end{bmatrix}$$</p>\n<p>$$\\begin{aligned}H&amp;&#x3D;(\\int_0^Te^{AT}dt)B&#x3D;\\Bigg[\\int_0^T\\begin{bmatrix}1&amp;0.5(1-e^{-2T})\\0&amp;e^{-2T}\\end{bmatrix}dt\\Bigg]\\begin{bmatrix}0\\1\\end{bmatrix}\\&amp;&#x3D;\\begin{bmatrix}T&amp;0.5T+0.25e^{-2T}-0.25\\0&amp;-0.5e^{-2T}+0.5\\end{bmatrix}\\begin{bmatrix}0\\1\\end{bmatrix}&#x3D;\\begin{bmatrix}0.005\\0.091\\end{bmatrix}\\end{aligned}$$</p>\n<p>故时间离散化状态方程为：</p>\n<p>$x[0.1(k+1)]&#x3D;\\begin{bmatrix}1&amp;0.091\\0&amp;0.819\\end{bmatrix}x(0.1k)+\\begin{bmatrix}0.005\\0.091\\end{bmatrix}u(0.1k)$</p>\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"线性离散系统状态方程的解\"><a href=\"#线性离散系统状态方程的解\" class=\"headerlink\" title=\"线性离散系统状态方程的解\"></a>线性离散系统状态方程的解</h2><p>离散系统的差分方程形状态方程有两种解法：递推法和z变换法。其中递推法在时变系统和时不变系统中都适用，而z变换法只适用于时不变系统。</p>\n<h3 id=\"递推法\"><a href=\"#递推法\" class=\"headerlink\" title=\"递推法\"></a>递推法</h3><ol>\n<li>在线性时变系统中，$x(k+1)&#x3D;G(k)x(k)+H(k)u(k)$，有：</li>\n</ol>\n<p>$$\\left{ \\begin{matrix} x(1)&#x3D;G(0)x(0)+H(0)u(0)\\ x(2)&#x3D;G(1)x(1)+H(1)u(1) \\ x(3)&#x3D;G(2)x(2)+H(2)u(2) \\\\vdots \\end{matrix}\\right.$$</p>\n<p>给定初始条件$x(0)$和输入序列$u(0),u(1),\\cdots$后即可求解$x(k)$。</p>\n<ol start=\"2\">\n<li>在线性时不变系统中，$x(k+1)&#x3D;Gx(k)+Hu(k)$，其中$G,H$均为常数矩阵，因此：</li>\n</ol>\n<p>$$x(k)&#x3D;G^kx(0)+\\sum_{i&#x3D;0}^{k-1}G^{k-1-i}Hu(i)    \\tag{13}$$</p>\n<p>上式称为线性时不变离散系统的状态转移方程，其中$\\Phi(k)&#x3D;G^k$称为线性时不变离散系统的状态转移矩阵。</p>\n<p>状态转移矩阵的性质：</p>\n<ol>\n<li>$\\Phi(k+1)&#x3D;G\\Phi{k},\\Phi(0)&#x3D;I$</li>\n<li>$\\Phi(k_2-k_0)&#x3D;\\Phi(k_2-k_1)\\Phi(k_1-k_0)$</li>\n<li>$\\Phi^{-1}(k)&#x3D;\\Phi(-k)$</li>\n</ol>\n<h3 id=\"z-变换法\"><a href=\"#z-变换法\" class=\"headerlink\" title=\"z 变换法\"></a>z 变换法</h3><p>考虑时不变离散系统：$x(k+1)&#x3D;Gx(k)+Hu(k)$，取z变换有：</p>\n<p>$$zx(z)-zx(0)&#x3D;Gx(z)+Hu(z)$$</p>\n<p>$$z(z)&#x3D;(zI-G)^{-1}zx(0)+(zI-G)^{-1}Hu(z)   \\tag{14}$$</p>\n<p>取z逆变换有：</p>\n<p>$$x(k)&#x3D;z^{-1}\\Big[(zI-G)^{-1}z\\Big]x(0)+z^{-1}\\Big[(zI-G)^{-1}Hu(z)\\Big]    \\tag{15} $$</p>\n<p>对比公式（13）和公式（15），由解的唯一性可知，</p>\n<p>$$z^{-1}\\Big[(zI-G)^{-1}z\\Big]&#x3D;G^k    \\tag{16}$$</p>\n<p>$$z^{-1}\\Big[(zI-G)^{-1}Hu(z)\\Big]&#x3D;\\sum_{i&#x3D;0}^{k-1}G^{k-1-i}Hu(i)   \\tag{17}$$</p>\n<p>+++info 例题</p>\n<p>;;;id8 例题1</p>\n<p>:::info </p>\n<p>考虑离散系统：$x(k+1)&#x3D;Gx(k)+Hu(k)$，其中$G&#x3D;\\begin{bmatrix}0&amp;1\\-0.16&amp;-1\\end{bmatrix}$，$H&#x3D;\\begin{bmatrix}1\\1\\end{bmatrix}$，初始条件为$x(0)&#x3D;\\begin{bmatrix}1\\-1\\end{bmatrix}$，试求当$u(k)&#x3D;1$时状态方程的解。</p>\n<p>:::</p>\n<p>用z变换法求解，先计算$(zI-G)^{-1}$，有</p>\n<p>$$\\begin{aligned}(zI-G)^{-1}&amp;&#x3D;\\begin{bmatrix}z&amp;-1\\0.16&amp;z+1\\end{bmatrix}^{-1}&#x3D;\\frac{1}{(z+0.2)(z+0.8)}\\begin{bmatrix}z+1&amp;1\\-0.16&amp;z\\end{bmatrix}\\&amp;&#x3D;\\begin{bmatrix}\\frac{4}{3}\\times \\frac{1}{z+0.2}-\\frac{1}{3}\\times \\frac{1}{z+0.8}&amp;\\frac{5}{3}\\times \\frac{1}{z+0.2}-\\frac{5}{3}\\times \\frac{1}{z+0.8}\\-\\frac{0.8}{3}\\times \\frac{1}{z+0.2}+\\frac{0.8}{3}\\times \\frac{1}{z+0.8}&amp;-\\frac{1}{3}\\times \\frac{1}{z+0.2}+\\frac{4}{3}\\times \\frac{1}{z+0.8}\\end{bmatrix}\\end{aligned}$$</p>\n<p>由于$u(k)&#x3D;1$，则$u(z)&#x3D;\\frac{z}{z-1}$，故$zx(0)+Hu(z)&#x3D;\\begin{bmatrix}z\\-z\\end{bmatrix}+\\begin{bmatrix}\\frac{z}{z-1}\\\\frac{z}{z-1}\\end{bmatrix}&#x3D;\\begin{bmatrix}\\frac{z^2}{z-1}\\\\frac{-z^2+2z}{z-1}\\end{bmatrix}$。</p>\n<p>那么代入公式（15）有：</p>\n<p>$$\\begin{aligned}x(z)&amp;&#x3D;(zI-G)^{-1}[zx(0)+Hu(z)]\\&amp;&#x3D;\\begin{bmatrix}-\\frac{17}{6}\\times \\frac{z}{z+0.2}+\\frac{22}{9}\\times \\frac{z}{z+0.8}+\\frac{25}{18}\\times \\frac{z}{z-1}\\\\frac{3.4}{6}\\times \\frac{z}{z+0.2}-\\frac{17.6}{9}\\times \\frac{z}{z+0.8}+\\frac{7}{18}\\times \\frac{z}{z-1}\\end{bmatrix}\\end{aligned}$$</p>\n<p>求z逆变换有：</p>\n<p>$$x(k)&#x3D;\\begin{bmatrix}-\\frac{17}{6}(-0.2)^k+\\frac{22}{9}(-0.8)^k+\\frac{25}{18}\\\\frac{3.4}{6}(-0.2)^k-\\frac{17.6}{9}(-0.2)^k+\\frac{7}{18}\\end{bmatrix}$$</p>\n<p>;;;</p>\n<p>+++</p>\n","categories":["现代控制理论"],"tags":["状态方程的解","矩阵指数","状态转移矩阵","离散化"]},{"title":"04 线性系统的能控性和能观测性","url":"/2023/12/06/2023-12-06-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%B5%8B%E6%80%A7/","content":"<p>现代控制理论——04 线性系统的能控性和能观测性</p>\n<span id=\"more\"></span>\n\n<h1 id=\"线性系统的能控性和能观测性\"><a href=\"#线性系统的能控性和能观测性\" class=\"headerlink\" title=\"线性系统的能控性和能观测性\"></a>线性系统的能控性和能观测性</h1><h2 id=\"能控性\"><a href=\"#能控性\" class=\"headerlink\" title=\"能控性\"></a>能控性</h2><p>能控性的简单理解为输入能够控制系统的状态变量 $x(t)$ 和输出变量 $y(t)$）。</p>\n<p>+++info 例子</p>\n<p>以下图结构图系统为例，输入 $u$ 只能影响 $x_1$ 而不能影响 $x_2$ ，因此可以说该系统中 $x_2$ 不可控， $x_1$ 可控，系统整体不可控。</p>\n<img data-src=\"/2023/12/06/2023-12-06-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%B5%8B%E6%80%A7/01%E8%83%BD%E6%8E%A7%E6%80%A7%E4%BE%8B%E5%AD%90.png\" class=\"\">{height=\"100px\" width=\"400px\"}\n\n<p>+++</p>\n<h3 id=\"线性定常系统的能控性定义\"><a href=\"#线性定常系统的能控性定义\" class=\"headerlink\" title=\"线性定常系统的能控性定义\"></a>线性定常系统的能控性定义</h3><p>对于线性定常系统： </p>\n<p>$$\\dot{x}&#x3D;Ax+Bu     \\tag{1}$$</p>\n<p> 如果存在输入控制 $u(t)$ 在有限的时间 $[t_0,t_1]$ 内能将系统从初始状态 $x(t_0)$ 转移到任意的状态 $x(t_1)$ 。</p>\n<h3 id=\"线性定常系统的能控性判据\"><a href=\"#线性定常系统的能控性判据\" class=\"headerlink\" title=\"线性定常系统的能控性判据\"></a>线性定常系统的能控性判据</h3><ol>\n<li>判据1（PHB判据）：对于式（1），系统，该系统完全能控的充要条件为能控性矩阵</li>\n</ol>\n<p>$$U_c&#x3D;\\begin{bmatrix}B&amp;AB&amp;\\cdots&amp;A^{n-1}B\\end{bmatrix}   \\tag{2}$$</p>\n<p>的秩为 $n$ ，即 $rankU_c &#x3D;n$。</p>\n<ul>\n<li>对于线性系统，经过线性非奇异变换后，状态能控性不变。（即能控性与系统有关，与状态变量的选取无关）</li>\n</ul>\n<pre><code class=\"language-matlab\">A = [1,2,1;0,1,0;1,0,3];   % A矩阵必须为n*n矩阵\nB = [1,0;0,1;0,0];         % B矩阵必须为n*k矩阵\n[n, ~] = size(A);          % 获取状态变量维数\nUc = [B]; temp = B;\nfor i = 1:n-1\n    temp = A*temp;\n    Uc = [Uc,temp];    % 能控矩阵\nend\ndisp(rank(Uc)==n);     % 判断状态变量维数是否与能控矩阵的秩一致\n</code></pre>\n<p>+++info 例题</p>\n<p>;;;id1 例题1</p>\n<p>:::info no-icon</p>\n<p>考察以下系统的能控性。</p>\n<p>$$\\begin{bmatrix}\\dot{x}_1\\\\dot{x}_2\\\\dot{x}_3\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;2&amp;1\\0&amp;1&amp;0\\1&amp;0&amp;3\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\x_3\\end{bmatrix}+\\begin{bmatrix}1&amp;0\\0&amp;1\\0&amp;0\\end{bmatrix}\\begin{bmatrix}u_1\\u_2\\end{bmatrix}$$</p>\n<p>:::</p>\n<p>由题 $B&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\0&amp;0\\end{bmatrix}$， $AB&#x3D;\\begin{bmatrix}1&amp;2&amp;1\\0&amp;1&amp;0\\1&amp;0&amp;3\\end{bmatrix}\\begin{bmatrix}1&amp;0\\0&amp;1\\0&amp;0\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;2\\0&amp;1\\1&amp;0\\end{bmatrix}$，$A^2B&#x3D;\\begin{bmatrix}1&amp;2&amp;1\\0&amp;1&amp;0\\1&amp;0&amp;3\\end{bmatrix}\\begin{bmatrix}1&amp;2\\0&amp;1\\1&amp;0\\end{bmatrix}&#x3D;\\begin{bmatrix}2&amp;4\\0&amp;1\\4&amp;2\\end{bmatrix}$。</p>\n<p>故 $U_c&#x3D;\\begin{bmatrix}1&amp;0&amp;1&amp;2&amp;2&amp;4\\0&amp;1&amp;0&amp;1&amp;0&amp;1\\0&amp;0&amp;1&amp;0&amp;4&amp;2\\end{bmatrix}$，其秩为3，故该系统可控。</p>\n<p>;;;</p>\n<p>+++</p>\n<ol start=\"2\">\n<li>判据2：对于式（1）系统，若系统矩阵 $A$ 具有互不相同的特征值，则系统状态可控的充要条件是，系统经过线性非奇异变换后，矩阵 $A$ 转换为对角标准型，状态方程为 $\\dot{\\hat{x}}&#x3D;\\begin{bmatrix}\\lambda_1&amp;&amp;0\\&amp;\\ddots&amp;\\0&amp;&amp;\\lambda_n\\end{bmatrix}\\hat{x}+\\hat{B}u$，其中 $\\hat{B}$ 中不含全为0的行。</li>\n</ol>\n<p>+++primary 证明（理解）</p>\n<p>我们把上述的对角标准型状态方程 $\\dot{\\hat{x}}&#x3D;\\begin{bmatrix}\\lambda_1&amp;&amp;0\\&amp;\\ddots&amp;\\0&amp;&amp;\\lambda_n\\end{bmatrix}\\hat{x}+\\hat{B}u$ 展开：</p>\n<p>$$\\left{ \\begin{matrix}\\dot{\\hat{x}}<em>1&#x3D;\\lambda_1\\hat{x}<em>1+\\hat{b}</em>{11}u_1+\\hat{b}</em>{12}u_2+\\cdots+\\hat{b}<em>{1p}u_p\\\\dot{\\hat{x}}<em>2&#x3D;\\lambda_2\\hat{x}<em>2+\\hat{b}</em>{21}u_1+\\hat{b}</em>{22}u_2+\\cdots+\\hat{b}</em>{2p}u_p\\\\vdots\\\\dot{\\hat{x}}<em>n&#x3D;\\lambda_n\\hat{x}<em>n+\\hat{b}</em>{n1}u_1+\\hat{b}</em>{n2}u_2+\\cdots+\\hat{b}_{np}u_p\\\\end{matrix}\\right.$$</p>\n<p>从中可以看出状态变量间是解耦的，状态变量间是没有联系的。若 $\\hat{B}$ 中存在一行全为0，那么该行对应的状态变量将不受输入的控制，故系统不可控。</p>\n<ul>\n<li>为何要转换为对角标准型：若非对角标准型，状态变量间并不是解耦的，那么输入便可通过状态变量间的耦合关系进行控制。</li>\n</ul>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id2 例题1</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的可控性。</p>\n<p>$$\\begin{bmatrix}\\dot{x}_1\\\\dot{x}_2\\\\dot{x}_3\\end{bmatrix}&#x3D;\\begin{bmatrix}3&amp;0&amp;0\\0&amp;-1&amp;0\\0&amp;0&amp;-2\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\x_3\\end{bmatrix}+\\begin{bmatrix}2\\1\\0\\end{bmatrix}u$$</p>\n<p>:::</p>\n<p>该系统不可控，因为状态变量 $x_3$ 不可控。</p>\n<p>;;;id2 例题2</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的可控性。</p>\n<p>$$\\begin{bmatrix}\\dot{x}_1\\\\dot{x}_2\\\\dot{x}_3\\end{bmatrix}&#x3D;\\begin{bmatrix}-7&amp;0&amp;0\\0&amp;-5&amp;0\\0&amp;0&amp;-1\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\x_3\\end{bmatrix}+\\begin{bmatrix}0&amp;1\\4&amp;0\\7&amp;5\\end{bmatrix}\\begin{bmatrix}u_1\\u_2\\end{bmatrix}$$</p>\n<p>:::</p>\n<p>该系统可控。</p>\n<p>;;;</p>\n<p>+++</p>\n<p>该判据的优点是能够容易判断出能控性，并且能够直接看出不可控的部分，但缺点在于需要等价变换。</p>\n<p>注意，上述判据2存在不适用情况：</p>\n<ul>\n<li>若系统矩阵 $A$ 为对角形但含有相同元素；</li>\n<li>若系统矩阵 $A$ 的若尔当标准型中有两个若尔当块的特征值相同；</li>\n</ul>\n<p>+++info 例子</p>\n<p>对于系统 $\\dot{x}&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}x+\\begin{bmatrix}1\\1\\end{bmatrix}u$，矩阵 $B$ 中虽然没有全零行，但是矩阵 $A$ 为对角阵且含有相同元素，故该系统不可控。</p>\n<p>对于系统 $\\dot{x}&#x3D;\\begin{bmatrix}-1&amp;1&amp;0\\0&amp;-4&amp;0\\0&amp;0&amp;-4\\end{bmatrix}x+\\begin{bmatrix}0\\1\\2\\end{bmatrix}u$，虽然所有若尔当块的最后一行均没有全零行，但是矩阵 $A$ 为若尔当标准型且存在两个若尔当块的特征值相同，故该系统不可控。</p>\n<p>+++</p>\n<p>若系统矩阵 $A$ 具有重特征值 $\\lambda_1(m_1重),\\lambda_2(m_2重),\\cdots,\\lambda_k(m_k重)$ 且每个重特征值只有一个若尔当块时时，则系统状态可控的充要条件是，系统经过线性非奇异变换后，系统转换为若尔当标准型，状态方程为 $\\dot{\\hat{x}}&#x3D;\\begin{bmatrix}J_1&amp;0&amp;\\cdots&amp;0\\0&amp;J_2&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;J_n\\end{bmatrix}\\hat{x}+\\hat{B}u$，其中 $\\hat{B}$ 中与每个若尔当块 $J_i$ 最后一行对应的行中各元素不全为0。</p>\n<p>+++info 例题</p>\n<p>;;;id3 例题1</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的可控性。</p>\n<p>$$\\begin{bmatrix}\\dot{x}_1\\\\dot{x}_2\\\\dot{x}_3\\end{bmatrix}&#x3D;\\begin{bmatrix}-3&amp;1&amp;0\\0&amp;-3&amp;0\\0&amp;0&amp;1\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\x_3\\end{bmatrix}+\\begin{bmatrix}0&amp;0\\2&amp;-1\\0&amp;3\\end{bmatrix}\\begin{bmatrix}u_1\\u_2\\end{bmatrix}$$</p>\n<p>:::</p>\n<p>该系统可控。</p>\n<p>;;;id3 例题2</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的可控性。</p>\n<p>$$\\begin{bmatrix}\\dot{x}_1\\\\dot{x}_2\\\\dot{x}_3\\end{bmatrix}&#x3D;\\begin{bmatrix}4&amp;1&amp;0\\0&amp;4&amp;0\\0&amp;0&amp;-2\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\x_3\\end{bmatrix}+\\begin{bmatrix}4&amp;2\\0&amp;0\\3&amp;0\\end{bmatrix}\\begin{bmatrix}u_1\\u_2\\end{bmatrix}$$</p>\n<p>:::</p>\n<p>该系统不可控。</p>\n<p>+++</p>\n<h3 id=\"线性定常系统的输出能控性\"><a href=\"#线性定常系统的输出能控性\" class=\"headerlink\" title=\"线性定常系统的输出能控性\"></a>线性定常系统的输出能控性</h3><p>很多情况下，被控制量往往是系统的输出而非状态变量，因此还需分析输出能控性。</p>\n<ol>\n<li>输出能控性的定义：对于线性定常系统： $\\dot{x}&#x3D;Ax+Bu$， 如果存在输入控制 $u(t)$ 在有限的时间 $[t_0,t_1]$ 内能将系统从初始状态 $y(t_0)$ 转移到任意的状态 $y(t_1)$ ，那么可以说明系统是输出的完全可控。</li>\n<li>输出可控性的判据：系统输出完全可控的充要条件是矩阵 $\\begin{bmatrix}CB&amp;CAB&amp;CA^2B&amp;\\cdots&amp;CA^{n-1}B\\end{bmatrix}$ 的秩等于输出的维数，即矩阵 $C$ 的维数。</li>\n</ol>\n<pre><code class=\"language-matlab\">A = [-4,1;2,-3];   % A矩阵必须为n*n矩阵\nB = [1;2];         % B矩阵必须为n*k矩阵\nC = [1,0];         % C矩阵必须为p*n矩阵\n[n, ~] = size(A);  % 获取状态变量维数\n[p, ~] = size(C);  % 获取输出维数\nUc = [C*B]; temp = eye(n,n);\nfor i = 1:n-1\n    temp = temp*A;\n    Uc = [Uc,C*temp*B];\nend\ndisp(rank(Uc)==p);\n</code></pre>\n<p>+++info 例题</p>\n<p>;;;id4 例题1</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的状态能控性和输出能控性。</p>\n<p>$$\\begin{matrix}\\begin{bmatrix}\\dot{x}_1\\\\dot{x}_2\\end{bmatrix}&#x3D;\\begin{bmatrix}-4&amp;1\\2&amp;-3\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\end{bmatrix}+\\begin{bmatrix}1\\2\\end{bmatrix}u\\y&#x3D;\\begin{bmatrix}1&amp;0\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\end{bmatrix}\\end{matrix}$$</p>\n<p>:::</p>\n<p>系统的状态能控性矩阵：$\\begin{bmatrix}B&amp;AB\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;-2\\2&amp;-4\\end{bmatrix}$，秩为1，故系统状态不可控。</p>\n<p>系统的输出能控性矩阵：$\\begin{bmatrix}CB&amp;CAB\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;-2\\end{bmatrix}$，秩为1，故系统输出可控。</p>\n<p>+++</p>\n<h2 id=\"能观测性\"><a href=\"#能观测性\" class=\"headerlink\" title=\"能观测性\"></a>能观测性</h2><p>能观测性是指通过对输出的测量来确定系统的状态变量，反映了从系统外部观测系统内部的能力。</p>\n<p>在前面<strong>状态方程的解</strong>方面的内容中，我们知道线性时不变系统动态方程（取初态时间 $t_0&#x3D;0$）的解为：</p>\n<p>$$x(t)&#x3D;e^{A(t)}x(0)+\\int_{0}^te^{A(t-\\tau)}Bu(\\tau),d\\tau,  t\\geq0   \\tag{3}$$</p>\n<p>上式中，系统矩阵 $A,B$ 以及控制输入 $u(t)$ 已知，因此只需要关注初态 $x(0)$ 即可得到 $x(t)$。</p>\n<h3 id=\"线性定常系统的能观性定义\"><a href=\"#线性定常系统的能观性定义\" class=\"headerlink\" title=\"线性定常系统的能观性定义\"></a>线性定常系统的能观性定义</h3><p>对于线性定常系统： </p>\n<p>$$\\left{ \\begin{aligned}\\dot{x}&amp;&#x3D;Ax+Bu\\y&amp;&#x3D;Cx   \\end{aligned}\\right.  \\tag{4}$$</p>\n<p> 如果在任意给定的输入 $u(t)$ 下，根据输出 $y(t)$ 在有限的时间 $[t_0,t_1]$ 内的测量值唯一确定初始状态 $x(t_0)$ ，则称系统在 $t_0$ 时刻可观测。若在任意时刻都可观测，则该系统是状态完全可观测的。</p>\n<h3 id=\"线性定常系统的能观性判据\"><a href=\"#线性定常系统的能观性判据\" class=\"headerlink\" title=\"线性定常系统的能观性判据\"></a>线性定常系统的能观性判据</h3><ol>\n<li>判据1：对于式（4），系统，该系统完全能控的充要条件为能控性矩阵</li>\n</ol>\n<p>$$U_o&#x3D;\\begin{bmatrix}C\\CA\\\\vdots\\CA^{n-1}\\end{bmatrix}   \\tag{5}$$</p>\n<p>的秩为 $n$ ，即 $rankU_o &#x3D;n$。</p>\n<pre><code class=\"language-matlab\">A = [2,-1;1,-3];   % A矩阵必须为n*n矩阵\nB = [-1;1];        % B矩阵必须为n*k矩阵\nC = [1,0;-1,0];    % C矩阵必须为p*n矩阵\n[n, ~] = size(A);  % 获取状态变量维数\n[p, ~] = size(C);  % 获取输出维数\nUo = [C]; %temp = eye(n,n);\nfor i = 1:n-1\n    Uo = [Uo;Uo(end-p+1:end,:)*A];\nend\ndisp(rank(Uo)==p);\n</code></pre>\n<p>+++info 例题</p>\n<p>;;;id5 例题1</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的能观测性</p>\n<p>$$\\begin{aligned}\\begin{bmatrix}\\dot{x_1}\\\\dot{x_2}\\end{bmatrix}&amp;&#x3D;\\begin{bmatrix}2&amp;-1\\1&amp;-3\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\end{bmatrix}+\\begin{bmatrix}-1\\1\\end{bmatrix}u\\\\begin{bmatrix}y_1\\y_2\\end{bmatrix}&amp;&#x3D;\\begin{bmatrix}1&amp;0\\-1&amp;0\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\end{bmatrix} \\end{aligned}$$</p>\n<p>:::</p>\n<p>系统的能观性矩阵 $U_o&#x3D;\\begin{bmatrix}C\\CA\\\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0\\-1&amp;0\\2&amp;-1\\-2&amp;1\\end{bmatrix}$ 的秩为2，故该系统能观测。</p>\n<p>+++</p>\n<ol start=\"2\">\n<li>判据2：对于式（4）系统，若系统矩阵 $A$ 具有互不相同的特征值，则系统状态可观的充要条件是，系统经过线性非奇异变换后，矩阵 $A$ 转换为对角标准型，状态方程为 $\\left{\\begin{aligned}\\dot{\\hat{x}}&amp;&#x3D;\\begin{bmatrix}\\lambda_1&amp;&amp;0\\&amp;\\ddots&amp;\\0&amp;&amp;\\lambda_n\\end{bmatrix}\\hat{x}\\y&amp;&#x3D;\\hat{C}\\hat{x}\\end{aligned}\\right.$，其中 $\\hat{C}$ 中不含全为0的列。</li>\n</ol>\n<p>若系统矩阵 $A$ 具有重特征值 $\\lambda_1(m_1重),\\lambda_2(m_2重),\\cdots,\\lambda_k(m_k重)$ 且每个重特征值只有一个若尔当块时时，则系统状态可控的充要条件是，系统经过线性非奇异变换后，系统转换为若尔当标准型，状态方程为 $\\left{\\begin{aligned}\\dot{\\hat{x}}&amp;&#x3D;\\begin{bmatrix}J_1&amp;0&amp;\\cdots&amp;0\\0&amp;J_2&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;J_n\\end{bmatrix}\\hat{x}\\y&amp;&#x3D;\\hat{C}\\hat{x}\\end{aligned}\\right.$，其中 $\\hat{C}$ 中与每个若尔当块 $J_i$ 第一列对应的行中各元素不全为0。</p>\n<p>+++info 例题</p>\n<p>;;;id6 例题1</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的能观测性</p>\n<p>$$\\begin{aligned}\\dot{x}&amp;&#x3D;\\begin{bmatrix}-2&amp;0\\0&amp;5\\end{bmatrix}x\\y&amp;&#x3D;\\begin{bmatrix}1&amp;3\\end{bmatrix}x \\end{aligned}$$</p>\n<p>:::</p>\n<p>该系统为对角标准型，不含全为0的列，故系统完全可观测。</p>\n<p>;;;id6 例题2</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的能观测性</p>\n<p>$$\\begin{aligned}\\dot{x}&amp;&#x3D;\\begin{bmatrix}2&amp;1&amp;0&amp;0\\0&amp;2&amp;0&amp;0\\0&amp;0&amp;3&amp;1\\0&amp;0&amp;0&amp;3\\end{bmatrix}x\\y&amp;&#x3D;\\begin{bmatrix}0&amp;1&amp;1&amp;0\\0&amp;1&amp;1&amp;1\\end{bmatrix}x \\end{aligned}$$</p>\n<p>:::</p>\n<p>该系统为若尔当标准型，第一个若尔当块第一列全为0，故系统不可观测。</p>\n<p>;;;id6 例题3</p>\n<p>:::info no-icon</p>\n<p>判断以下系统的能观测性</p>\n<p>$$\\begin{aligned}\\dot{x}&amp;&#x3D;\\begin{bmatrix}-3&amp;1&amp;0\\0&amp;-3&amp;0\\0&amp;0&amp;1\\end{bmatrix}x\\y&amp;&#x3D;\\begin{bmatrix}1&amp;0&amp;0\\0&amp;0&amp;-1\\end{bmatrix}x \\end{aligned}$$</p>\n<p>:::</p>\n<p>该系统为若尔当标准型，所有若尔当块的第一列不全为0，故系统可观测。</p>\n<p>+++</p>\n<h2 id=\"能控性与能观测性的对偶关系\"><a href=\"#能控性与能观测性的对偶关系\" class=\"headerlink\" title=\"能控性与能观测性的对偶关系\"></a>能控性与能观测性的对偶关系</h2><h3 id=\"对偶系统\"><a href=\"#对偶系统\" class=\"headerlink\" title=\"对偶系统\"></a>对偶系统</h3><p>对于两个系统 $\\Sigma_1:\\left{ \\begin{aligned}\\dot{x}&amp;&#x3D;Ax+Bu\\y&amp;&#x3D;Cx \\end{aligned}  \\right.$ ， $\\Sigma_2:\\left{ \\begin{aligned}\\dot{z}&amp;&#x3D;A^Tz+C^Tv\\w&amp;&#x3D;B^Tz \\end{aligned}  \\right.$，其中 $x$ 与 $z$ 的维度相同，$u$ 与 $v$ 的维度相同，$y$ 与 $w$ 的维度相同，这两个系统即是对偶系统。</p>\n<img data-src=\"/2023/12/06/2023-12-06-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%B5%8B%E6%80%A7/02%E5%AF%B9%E5%81%B6%E7%B3%BB%E7%BB%9F.png\" class=\"\">{height=\"150px\"}\n\n<h3 id=\"对偶原理\"><a href=\"#对偶原理\" class=\"headerlink\" title=\"对偶原理\"></a>对偶原理</h3><p>对于上述两个系统 $\\Sigma_1,\\Sigma_2$，$\\Sigma_1$ 能观 $\\Leftrightarrow$ $\\Sigma_2$ 能控，$\\Sigma_1$ 能控 $\\Leftrightarrow$ $\\Sigma_2$ 能观。</p>\n<p>+++info 证明</p>\n<p>证明 $\\Sigma_1$ 的能观性矩阵与 $\\Sigma_2$ 的能控性矩阵一致， $\\Sigma_1$ 的能控性矩阵与 $\\Sigma_2$ 的能观性矩阵一致。</p>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>进一步分析对偶系统的传递函数可知：$G_{\\Sigma_1}(s)&#x3D;[G_{\\Sigma_2}(s)]^T$</p>\n<p>:::</p>\n<h2 id=\"线性定常系统的结构分解\"><a href=\"#线性定常系统的结构分解\" class=\"headerlink\" title=\"线性定常系统的结构分解\"></a>线性定常系统的结构分解</h2><p>结构分解就是将系统的可控（可观）和不可控（不可观）的部分分离开，进而理解系统的内部。</p>\n<p>对于系统 $\\left{ \\begin{aligned}\\dot{x}&amp;&#x3D;Ax+Bu\\y&amp;&#x3D;Cx \\end{aligned}   \\right.$，以下将进行能控性分解、能观性分解和标准分解。</p>\n<h3 id=\"能控性分解\"><a href=\"#能控性分解\" class=\"headerlink\" title=\"能控性分解\"></a>能控性分解</h3><p>假设系统不完全可控，即能控性矩阵的秩为 $n_1&lt;n$。存在非奇异矩阵 $T_c$ 进行状态变换 $x&#x3D;T_c\\tilde{x}$ ，使得系统的状态空间方程变换为：$\\left{ \\begin{aligned}\\dot{\\tilde{x}}&amp;&#x3D;\\tilde{A}\\tilde{x}+\\tilde{B}u\\y&amp;&#x3D;\\tilde{C}x \\end{aligned}   \\right.$，其中 $\\tilde{A}&#x3D;T_c^{-1}AT_c&#x3D;\\begin{bmatrix}\\tilde{A}<em>{11}&amp;\\tilde{A}</em>{12}\\0&amp;\\tilde{A}<em>{22}\\end{bmatrix}$，$\\tilde{B}&#x3D;T_c^{-1}B&#x3D;\\begin{bmatrix}\\tilde{B}</em>{1}\\0\\end{bmatrix}$，$\\tilde{C}&#x3D;CT_c&#x3D;\\begin{bmatrix}\\tilde{C}<em>{1}&amp;\\tilde{C}<em>2\\end{bmatrix}$，其中 $\\tilde{A}</em>{11},\\tilde{A}</em>{12},\\tilde{A}<em>{22}$ 均为分块矩阵，各自的维数为 $n_1\\times n_1,n_1\\times (n-n_1),(n-n_1)\\times (n-n_1)$，$\\tilde{B}</em>{1}$ 为 $n_1\\times p$ 的分块矩阵，$\\tilde{C}<em>{1},\\tilde{C}</em>{2}$ 为 $q\\times n_1,q\\times (n-n_1)$ 的分块矩阵。</p>\n<p>那么系统的 $n_1$ 维能控部分可表示为：$\\dot{\\tilde{x}}&#x3D;\\tilde{A}_{11}\\tilde{x}<em>1+\\tilde{A}</em>{12}\\tilde{x}_2+\\tilde{B}_1u$，$n-n_1$ 维不可控部分可表示为：$\\tilde{x}<em>2&#x3D;\\tilde{A}</em>{22}\\tilde{x}_2$ 。</p>\n<p>那么变换矩阵 $T_c$ 如何获取呢？</p>\n<ul>\n<li>从能控性矩阵 $U_c&#x3D;\\begin{bmatrix}B&amp;AB&amp;\\cdots&amp;A^{n-1}B\\end{bmatrix}$ 中选取 $n_1$ 个线性无关的列向量作为 $T_c$ 矩阵的前 $n_1$ 列。</li>\n<li>其余 $n-n_1$ 列可在保证 $T_c$ 非奇异的条件下任意选取。</li>\n</ul>\n<p>+++info 例题</p>\n<p>;;;id7 例题1</p>\n<p>:::info no-icon</p>\n<p>对下列系统进行能控性分解。</p>\n<p>$$\\begin{aligned}\\dot{x}&amp;&#x3D;\\begin{bmatrix}0&amp;0&amp;-1\\1&amp;0&amp;-3\\0&amp;1&amp;-3\\end{bmatrix}x+\\begin{bmatrix}1\\1\\0\\end{bmatrix}u\\y&amp;&#x3D;\\begin{bmatrix}0&amp;1&amp;-2\\end{bmatrix}x \\end{aligned}$$</p>\n<p>:::</p>\n<ul>\n<li>计算能控性矩阵的秩。$rank\\begin{bmatrix}b&amp;Ab&amp;A^2b\\end{bmatrix}&#x3D;rank\\begin{bmatrix}1&amp;0&amp;-1\\1&amp;1&amp;-3\\0&amp;1&amp;-2\\end{bmatrix}&#x3D;2&lt;3$，系统不完全可控。</li>\n<li>选取两个线性无关的列向量 $\\begin{bmatrix}1\\1\\0\\end{bmatrix}$ 和$\\begin{bmatrix}0\\1\\1\\end{bmatrix}$。再任意选取另外一个线性无关的列向量 $\\begin{bmatrix}0\\0\\1\\end{bmatrix}$ 构成变换矩阵 $T_c&#x3D;\\begin{bmatrix}1&amp;0&amp;0\\1&amp;1&amp;0\\0&amp;1&amp;1\\end{bmatrix}$。</li>\n<li>求逆：$T_c^{-1}&#x3D;\\begin{bmatrix}1&amp;0&amp;0\\-1&amp;1&amp;0\\1&amp;-1&amp;1\\end{bmatrix}$。</li>\n<li>利用状态变换 $x&#x3D;T_c\\tilde{x}$ ，得到变换后的状态空间表达式：$\\left{\\begin{aligned}\\dot{\\tilde{x}}&amp;&#x3D;\\begin{bmatrix}0&amp;-1&amp;-1\\1&amp;-2&amp;-2\\0&amp;0&amp;-1\\end{bmatrix}\\tilde{x}+\\begin{bmatrix}1\\0\\0\\end{bmatrix}u\\y&amp;&#x3D;\\begin{bmatrix}1&amp;-1&amp;-2\\end{bmatrix}\\tilde{x} \\end{aligned}\\right.$。</li>\n</ul>\n<p>故可控部分为：$\\left{\\begin{aligned}&amp;\\dot{\\tilde{x}}_1&#x3D;\\begin{bmatrix}0&amp;-1\\1&amp;-2\\end{bmatrix}\\tilde{x}_1+\\begin{bmatrix}1\\0\\end{bmatrix}u\\&amp;y&#x3D;\\begin{bmatrix}1&amp;-1\\end{bmatrix}\\tilde{x}_1 \\end{aligned}\\right.$。</p>\n<p>+++</p>\n<h3 id=\"能观性分解\"><a href=\"#能观性分解\" class=\"headerlink\" title=\"能观性分解\"></a>能观性分解</h3><p>假设系统不完全能观，即能观性矩阵的秩为 $n_2&lt;n$。存在非奇异矩阵 $T_o$ 进行状态变换 $x&#x3D;T_o\\tilde{x}$ ，使得系统的状态空间方程变换为：$\\left{ \\begin{aligned}\\dot{\\tilde{x}}&amp;&#x3D;\\tilde{A}\\tilde{x}+\\tilde{B}u\\y&amp;&#x3D;\\tilde{C}x \\end{aligned}   \\right.$，其中 $\\tilde{A}&#x3D;T_o^{-1}AT_o&#x3D;\\begin{bmatrix}\\tilde{A}<em>{11}&amp;0\\\\tilde{A}</em>{21}&amp;\\tilde{A}<em>{22}\\end{bmatrix}$，$\\tilde{B}&#x3D;T_o^{-1}B&#x3D;\\begin{bmatrix}\\tilde{B}</em>{1}\\\\tilde{B}<em>{2}\\end{bmatrix}$，$\\tilde{C}&#x3D;CT_o&#x3D;\\begin{bmatrix}\\tilde{C}</em>{1}&amp;0\\end{bmatrix}$，其中 $\\tilde{A}<em>{11},\\tilde{A}</em>{12},\\tilde{A}<em>{22}$ 均为分块矩阵，各自的维数为 $n_2\\times n_2,(n-n_2)\\times n_2,(n-n_2)\\times (n-n_2)$，$\\tilde{B}</em>{1},\\tilde{B}<em>{2}$ 为 $n_2\\times p,(n-n_2)\\times p$ 的分块矩阵，$\\tilde{C}</em>{1}$ 为 $q\\times n_2$ 的分块矩阵。</p>\n<p>那么系统的 $n_2$ 维能观部分可表示为：$\\left{\\begin{aligned}&amp;\\dot{\\tilde{x}}&#x3D;\\tilde{A}_{11}\\tilde{x}_1+\\tilde{B}_1u\\&amp;y_1&#x3D;\\tilde{C}_1\\tilde{x}_1\\end{aligned}\\right.$，$n-n_2$ 维不可观部分可表示为：$\\tilde{x}<em>2&#x3D;\\tilde{A}</em>{21}\\tilde{x}<em>1+\\tilde{A}</em>{22}\\tilde{x}<em>2+\\tilde{B}</em>{2}u$ 。</p>\n<p>:::info no-icon</p>\n<p>能观子系统的传递函数矩阵与原系统的传递函数矩阵相同，因为不能观测的部分不能出现在传递函数矩阵中。</p>\n<p>:::</p>\n<p>同样关键是变换矩阵 $T_o$ 如何获取。</p>\n<ul>\n<li>从能观性矩阵 $U_o&#x3D;\\begin{bmatrix}C\\CA\\\\vdots\\CA^{n-1}\\end{bmatrix}$ 中选取 $n_2$ 个线性无关的行向量作为 $T_o^{-1}$ 矩阵的前 $n_2$ 行。</li>\n<li>其余 $n-n_2$ 列可在保证 $T_o^{-1}$ 非奇异的条件下任意选取。</li>\n</ul>\n<p>+++info 例题</p>\n<p>;;;id8 例题1</p>\n<p>:::info no-icon</p>\n<p>对下列系统进行能观性分解。</p>\n<p>$$\\begin{aligned}\\dot{x}&amp;&#x3D;\\begin{bmatrix}0&amp;0&amp;-1\\1&amp;0&amp;-3\\0&amp;1&amp;-3\\end{bmatrix}x+\\begin{bmatrix}1\\1\\0\\end{bmatrix}u\\y&amp;&#x3D;\\begin{bmatrix}0&amp;1&amp;-2\\end{bmatrix}x \\end{aligned}$$</p>\n<p>:::</p>\n<ul>\n<li>计算能观性矩阵的秩。$rank\\begin{bmatrix}C\\CA\\CA^2\\end{bmatrix}&#x3D;rank\\begin{bmatrix}0&amp;1&amp;-2\\1&amp;-2&amp;3\\-2&amp;3&amp;-4\\end{bmatrix}&#x3D;2&lt;3$，系统不完全可观。</li>\n<li>选取两个线性无关的行向量 $\\begin{bmatrix}0&amp;1&amp;-2\\end{bmatrix}$ 和$\\begin{bmatrix}1&amp;-2&amp;3\\end{bmatrix}$。再任意选取另外一个线性无关的行向量 $\\begin{bmatrix}0&amp;0&amp;1\\end{bmatrix}$ 构成变换矩阵 $T_o^{-1}&#x3D;\\begin{bmatrix}0&amp;1&amp;-2\\1&amp;-2&amp;3\\0&amp;0&amp;1\\end{bmatrix}$。</li>\n<li>求逆：$T_o&#x3D;\\begin{bmatrix}2&amp;1&amp;1\\1&amp;0&amp;2\\0&amp;0&amp;1\\end{bmatrix}$。</li>\n<li>利用状态变换 $x&#x3D;T_o\\tilde{x}$ ，得到变换后的状态空间表达式：$\\left{\\begin{aligned}\\dot{\\tilde{x}}&amp;&#x3D;\\begin{bmatrix}0&amp;1&amp;0\\-1&amp;-2&amp;0\\1&amp;0&amp;-1\\end{bmatrix}\\tilde{x}+\\begin{bmatrix}1\\-1\\0\\end{bmatrix}u\\y&amp;&#x3D;\\begin{bmatrix}1&amp;0&amp;0\\end{bmatrix}\\tilde{x} \\end{aligned}\\right.$。</li>\n</ul>\n<p>故可观部分为：$\\left{\\begin{aligned}&amp;\\dot{\\tilde{x}}_1&#x3D;\\begin{bmatrix}0&amp;-1\\-1&amp;-2\\end{bmatrix}\\tilde{x}_1+\\begin{bmatrix}1\\-1\\end{bmatrix}u\\&amp;y&#x3D;\\begin{bmatrix}1&amp;0\\end{bmatrix}\\tilde{x}_1 \\end{aligned}\\right.$。</p>\n<p>+++</p>\n<h2 id=\"能控性、能观性与传递函数矩阵的关系\"><a href=\"#能控性、能观性与传递函数矩阵的关系\" class=\"headerlink\" title=\"能控性、能观性与传递函数矩阵的关系\"></a>能控性、能观性与传递函数矩阵的关系</h2><p>在单输入单输出系统中，系统能控能观的充要条件是传递函数中没有零极点相消的现象。</p>\n<p>:::info no-icon</p>\n<p>推论</p>\n<ol>\n<li>一个系统的传递函数所表示的是该系统既能控又能观的那一部分子系统。</li>\n<li>一个系统的传递函数若有零、极点对消现象，则视状态变量的选择不同，系统或是不能控的或是不能观的。</li>\n</ol>\n<p>:::</p>\n<h2 id=\"能控标准型\"><a href=\"#能控标准型\" class=\"headerlink\" title=\"能控标准型\"></a>能控标准型</h2><p>在单输入单输出系统（$\\dot{x}&#x3D;Ax+bu$），若系统矩阵 $A$ 和控制矩阵 $b$ 表示如下，那么其为状态空间表达式的能控标准型。</p>\n<p>$$A&#x3D;\\begin{bmatrix}0&amp;1&amp;0&amp;\\cdots&amp;0\\0&amp;0&amp;1&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;0&amp;\\cdots&amp;0\\-a_n&amp;-a_{n-1}&amp;-a_{n-2}&amp;\\cdots&amp;-a_1\\end{bmatrix},b&#x3D;\\begin{bmatrix}0\\0\\\\vdots\\0\\1\\end{bmatrix}$$</p>\n<p>对于线性定常系统 $\\dot{x}&#x3D;Ax+bu$，若其能控，那么必定存在非奇异变换 $\\tilde{x}&#x3D;Px$ 将该系统转换为能控标准型 $\\dot{\\tilde{x}}&#x3D;A_c\\tilde{x}+b_cu$（$A_c,b_c$ 符合上述能控标准型）。非奇异变换 $P&#x3D;\\begin{bmatrix}p_1\\P_1A\\\\vdots\\p_1A^{n-1}\\end{bmatrix}$，其中 $p_1$ 由 $p_1&#x3D;\\begin{bmatrix}0&amp;0&amp;0&amp;\\cdots&amp;0&amp;1\\end{bmatrix}\\begin{bmatrix}b&amp;Ab&amp;A^{2}b&amp;\\cdots&amp;A^{n-1}b\\end{bmatrix}^{-1}$ 确定。</p>\n<p>+++info 例题</p>\n<p>;;;id9 例题1</p>\n<p>:::info no-icon</p>\n<p>将下列线性定常系统化为能控标准型。</p>\n<p>$$\\begin{aligned}\\dot{x}&amp;&#x3D;\\begin{bmatrix}1&amp;-1\\1&amp;0\\end{bmatrix}x+\\begin{bmatrix}1\\1\\end{bmatrix}u \\end{aligned}$$</p>\n<p>:::</p>\n<p>系统的能控性矩阵为：$U_c&#x3D;\\begin{bmatrix}b&amp;Ab\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0\\1&amp;1\\end{bmatrix}$，求逆得到 $U_c^{-1}&#x3D;\\begin{bmatrix}1&amp;0\\-1&amp;1\\end{bmatrix}$，进而计算 $p_1&#x3D;\\begin{bmatrix}-1&amp;1\\end{bmatrix}$。则变换矩阵$P&#x3D;\\begin{bmatrix}p_1\\p_1A\\end{bmatrix}&#x3D;\\begin{bmatrix}-1&amp;1\\0&amp;1\\end{bmatrix}$，求逆得到 $P^{-1}&#x3D;\\begin{bmatrix}-1&amp;1\\0&amp;1\\end{bmatrix}$。</p>\n<p>则 $A_c&#x3D;PAP^{-1}&#x3D;\\begin{bmatrix}0&amp;1\\-1&amp;1\\end{bmatrix},b_c&#x3D;Pb&#x3D;\\begin{bmatrix}0\\1\\end{bmatrix}$，则能控标准型表示为：$\\dot{\\tilde{x}}&#x3D;\\begin{bmatrix}0&amp;1\\-1&amp;1\\end{bmatrix}\\tilde{x}+\\begin{bmatrix}0\\1\\end{bmatrix}u$。</p>\n<p>+++</p>\n<h2 id=\"能观测标准型\"><a href=\"#能观测标准型\" class=\"headerlink\" title=\"能观测标准型\"></a>能观测标准型</h2><p>在单输入单输出系统（$\\left{\\begin{aligned}&amp;\\dot{x}&#x3D;Ax+bu\\&amp;y&#x3D;cx\\end{aligned}\\right.$），若系统矩阵 $A$ 和控制矩阵 $b$ 表示如下，那么其为状态空间表达式的能控标准型。</p>\n<p>$$A&#x3D;\\begin{bmatrix}0&amp;0&amp;\\cdots&amp;0&amp;-a_n\\1&amp;0&amp;\\cdots&amp;0&amp;-a_{n-1}\\0&amp;1&amp;\\cdots&amp;0&amp;-a_{n-2}\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;0&amp;-a_1\\end{bmatrix},c&#x3D;\\begin{bmatrix}0&amp;0&amp;\\cdots&amp;0&amp;1\\end{bmatrix}$$</p>\n<p>对于线性定常系统 $\\left{\\begin{aligned}&amp;\\dot{x}&#x3D;Ax+bu\\&amp;y&#x3D;cx\\end{aligned}\\right.$，若其能观，那么必定存在非奇异变换 $x&#x3D;T\\tilde{x}$ 将该系统转换为能控标准型 $\\left{\\begin{aligned}&amp;\\dot{\\tilde{x}}&#x3D;A_o\\tilde{x}+b_ou\\&amp;y&#x3D;c_o\\tilde{x}\\end{aligned}\\right.$（$A_o,c_o$ 符合上述能观标准型）。非奇异变换 $T&#x3D;\\begin{bmatrix}T_1&amp;AT_1&amp;\\cdots&amp;A^{n-1}T_1\\end{bmatrix}$，其中 $T_1$ 由 $T_1&#x3D;\\begin{bmatrix}c\\cA\\cA^{2}\\\\vdots\\cA^{n-1}\\end{bmatrix}^{-1}\\begin{bmatrix}0\\0\\\\vdots\\0\\1\\end{bmatrix}$ 确定。</p>\n<p>+++info 例题</p>\n<p>;;;id10 例题1</p>\n<p>:::info no-icon</p>\n<p>将下列线性定常系统化为能观标准型。</p>\n<p>$$\\begin{aligned}\\dot{x}&amp;&#x3D;\\begin{bmatrix}1&amp;-1\\0&amp;2\\end{bmatrix}x\\y&amp;&#x3D;\\begin{bmatrix}-1&amp;-\\frac{1}{2}\\end{bmatrix}x \\end{aligned}$$</p>\n<p>:::</p>\n<p>系统的能观性矩阵为：$U_o&#x3D;\\begin{bmatrix}c\\cA\\end{bmatrix}&#x3D;\\begin{bmatrix}-1&amp;-\\frac{1}{2}\\-1&amp;0\\end{bmatrix}$，则 $T_1&#x3D;\\begin{bmatrix}c\\cA\\end{bmatrix}^{-1}\\begin{bmatrix}0\\1\\end{bmatrix}&#x3D;\\begin{bmatrix}-1\\2\\end{bmatrix}$。则变换矩阵$T&#x3D;\\begin{bmatrix}T_1\\AT_1\\end{bmatrix}&#x3D;\\begin{bmatrix}-1&amp;-3\\2&amp;4\\end{bmatrix}$。</p>\n<p>则能观标准型表示为：$\\left{\\begin{aligned}&amp;\\dot{\\tilde{x}}&#x3D;T^{-1}AT\\tilde{x}&#x3D;\\begin{bmatrix}0&amp;-2\\1&amp;3\\end{bmatrix}\\tilde{x}\\&amp;y&#x3D;cT\\tilde{x}&#x3D;\\begin{bmatrix}0&amp;1\\end{bmatrix}\\tilde{x}\\end{aligned}\\right.$。</p>\n<p>+++</p>\n","categories":["现代控制理论"],"tags":["能控性","能观性"]},{"title":"第一篇论文","url":"/2023/11/27/2023-11-27_%E7%AC%AC%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"083768b854b2e685d8b2245d2afab260c70463acde536d70c61fbbd32f424dbf\">dcdd4c7f8418aae4a90e26acdd15c23ec5783b2cc8f3469f62f5f61fe907f52eef80494fef149402774d9a3bc0c449fc9d506c8e48b3df0a0ab428caa724b41105798cbb9dab0c42c7caa635732b9af0c4c56d1dfd9250f861951f59ab924a522e68ad3b2911e736f9ee1df34887375b9ce7cf82667088a489ee1b60a6c3a2a46f38d4acc9586603311f7eb5bd361c072ffb2a1cc1d8225ed8511d13107cee82d923a36020801943448e4a6314a2f284e152f5fb7e5cd9d3739402e91edd31b43e9acc88813db4dc5aa1d7b6f0182243d4500b4d0872cce59546761d6e4fdd7538c1dc9d54debebbf8f54800883971f7ec808c7ac670ff4b382031c5b1b2d91dc38169160208384a1177e045c27dee26b565183cabe7a15c17971b9cbce9008735718963d95bb4c481e8c316646c7e76b07ea249163d6ceffd99c58b276e3f129b5a30054a3383ac5928f105b33545b5ecf14e75dae456646571c7eaadabaa5538be9aa04fc3c52cd72ac95c04bcc3ea0894eb3fe3dc3023c6dfd3574cc9e3f1644daca3ad047b7f356d8bee48ac1b2179a91aeac4b28e0e545184dc949df3225ebc475aa958d1904cf0f0b579608b6076b1da49f3c31cf1a7a935f5636a18fa623e152599b99f3f1f1f53b765ee4d28bfd2aacc1fcf28c0df8c92f696a3a889ede584d2e6cb8858a7cec41c5ca55011a8e98d7c01af9f6e44bb8a54189b4b03ab52f401bed05500e28014d0214919a1b2fe809069e71afeba317844006f1d1a3cafe670015f212ea6c28eeb10bd6a57966643a09842bc6589e362099d6b12054fcb65639e8628728e5d8794936351a47a5c0d6589c4e90e2bb385cb1b44e5d596634697b6f6a0f20e4633bf4bbec7970258d4242d99263fc9f5b6e7886558a957582a2c2dca486c48da8bf9f351396acb91aa068de0734a4443efb1bb84cb3cfc8cd4020dce605bcd6f53dc72c4934209ccfe31a147e38991a9d6ae27a1e9d6167ee4c33bdc980d3e6cae9c600668a7bc22d1a98e2650cd850796de49e6522379ce18e59be828ec46be30d2e8226f017988487cbb5d34c09c01f5428854b73a22bb03721c57362c67bca61930968819b36a61e848666fca7cc108e27a98d104769300f4199f9ea756ce1c65104b1a037a9729630f0815a195b7e0edc48919d6784fb868da0a485fd9528b047a7d1435ff9ef6f2f918df5f3ceaeac5353fa9ab0108fc17d26cfae84884d2b293015fc061e934e4a68d4314d51aec63f19262b65d829fa64db22045527d799260fd41bc16d60e3140392781e56963c32bf49130</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Hey, password is required here.</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","categories":["杂谈"]},{"title":"特征图可视化","url":"/2023/12/06/2023-12-06_%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"<p>卷积神经网络各层特征图的可视化</p>\n<span id=\"more\"></span>\n\n<h1 id=\"特征图可视化\"><a href=\"#特征图可视化\" class=\"headerlink\" title=\"特征图可视化\"></a>特征图可视化</h1><p>代码链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0hueTEyMTYvRmVhdHVyZU1hcFZpc3VhbGl6YXRpb24=\">https://github.com/Hny1216/FeatureMapVisualization</span></p>\n<p>速食可直接跳转<a href=\"#%E5%BC%95%E7%94%A8%E6%96%B9%E6%B3%95\">引用方法</a></p>\n<h2 id=\"特征图\"><a href=\"#特征图\" class=\"headerlink\" title=\"特征图\"></a>特征图</h2><p>理解特征图（Feature Map）就需要先理解卷积神经网络（Convolutional Neural Network，CNN）是如何工作的。</p>\n<p>卷积神经网络大体可以分为特征提取层和特征映射层。特征提取层主要由若干卷积层、激活层和池化层组成，特征映射层主要是多层全连接层。在卷积层中，使用不同的卷积核从局部感受野中提取各种特征，每个核生成自己的特征图，多个卷积核得到的特征图在深度方向堆叠得到输出特征图（Feature Maps）。</p>\n<p>以Alexnet为例，其网络结构如下图。其输入图像的大小为 $224\\times224\\times3$ ，第一个卷积层中卷积核的大小是$5\\times5$，共有96个卷积核（分为两批），每个卷积核与输入进行卷积运算得到一张特征图，因此可以得到96张特征图（图中为何是48个特征图？Alexnet设计网络时运算能力不足，因此将网络分为了两批，每一批都是48，因此总特征图就是48*2&#x3D;96张）。</p>\n<img data-src=\"/2023/12/06/2023-12-06_%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/01-Alexnet%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png\" class=\"\">\n\n\n\n<h2 id=\"激活可视化\"><a href=\"#激活可视化\" class=\"headerlink\" title=\"激活可视化\"></a>激活可视化</h2><p>特征图的激活可视化本质就是可视化特征图，通过观察特征图中被激活的像素位置，从而借此理解卷积神经网络关注输入的那一部分数据信息，进而对卷积神经网络进行解释。</p>\n<p>同样以Alexnet网络的第一层卷积层为例，输入选择一张标签为“balloon”，大小为  $705\\times705\\times3$ 的图像。输入的三通道图像如下：</p>\n<img data-src=\"/2023/12/06/2023-12-06_%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/02-%E8%BE%93%E5%85%A5%E5%9B%BE%E5%83%8F.png\" class=\"\">\n\n<p>我们可视化浅层网络（Relu1）和深层网络（Relu4，Relu5），来观察网络各层激活了哪些特征（选取了前18个通道）。浅层网络激活的特征信息较多，且与原始数据较为相似，越深层网络所提取到的特征就越抽象，更加注重输入的纹理细节信息。</p>\n<img data-src=\"/2023/12/06/2023-12-06_%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/03-Relu1.png\" class=\"\">\n\n<img data-src=\"/2023/12/06/2023-12-06_%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/04-Relu4.png\" class=\"\">\n\n<img data-src=\"/2023/12/06/2023-12-06_%E7%89%B9%E5%BE%81%E5%9B%BE%E5%8F%AF%E8%A7%86%E5%8C%96/05-Relu5.png\" class=\"\">\n\n<h2 id=\"代码解析\"><a href=\"#代码解析\" class=\"headerlink\" title=\"代码解析\"></a>代码解析</h2><h2 id=\"引用方法\"><a href=\"#引用方法\" class=\"headerlink\" title=\"引用方法\"></a>引用方法</h2><p>本方法实现了一个特征图可视化类，提供了Matlab和Python两种语言的版本，以下根据需要使用合适的语言自行使用。</p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>下载链接如下：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0hueTEyMTYvRmVhdHVyZU1hcFZpc3VhbGl6YXRpb24=\">https://github.com/Hny1216/FeatureMapVisualization</span></p>\n<h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><p>确保特征图可视化类与运行脚本文件在一个路径即可。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>;;;id1 Matlab</p>\n<pre><code class=\"language-matlab\">a = alexnet;\nFmv = FeatureMapVisualization(a,isShow=true);\n</code></pre>\n<p>;;;</p>\n<p>;;;id1 Python</p>\n<pre><code class=\"language-python\">import FeatureMapVisualization as Fmv\nmodel = models.alexnet(pretrained=True)\nmodelLayer = list(model.children())\nmodelVisualization = Fmv.FeatureMapVisualization(modelLayer)\n</code></pre>\n<p>;;;</p>\n","categories":["技能工具"]},{"title":"Md+Shoka使用技巧","url":"/2023/12/14/2023-12-14_md+shoka%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","content":"<p>关于Md文件使用Shoka主题渲染的关键技巧&#x2F;基础</p>\n<span id=\"more\"></span>\n\n<h1 id=\"图片显示\"><a href=\"#图片显示\" class=\"headerlink\" title=\"图片显示\"></a>图片显示</h1><h2 id=\"单个图片显示\"><a href=\"#单个图片显示\" class=\"headerlink\" title=\"单个图片显示\"></a>单个图片显示</h2><ol>\n<li>图片下方显示标题内容</li>\n</ol>\n<pre><code class=\"language-txt\">![](https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg &quot;芙宁娜&quot;)\n</code></pre>\n<p><img data-src=\"https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg\" title=\"芙宁娜\"></p>\n<ol start=\"2\">\n<li>指定图片大小</li>\n</ol>\n<pre><code class=\"language-txt\">![](https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg &quot;芙宁娜200*300&quot;)&#123;height=&quot;200px&quot; width=&quot;300px&quot;&#125;\n</code></pre>\n<p><img data-src=\"https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg\" title=\"芙宁娜200*300\">{height&#x3D;”200px” width&#x3D;”300px”}</p>\n<ol start=\"3\">\n<li>使用本地图片时，编辑器和Shoka同时渲染出图片</li>\n</ol>\n<p>在<code>_posts</code>路径下创建一个与md文件同名（不带文件尾缀）的文件夹，将图片放在该文件夹下，调用图片时使用相对路径调用。以本文件为例，文件名为<code>2023-12-14_md+shoka使用技巧.md</code>，在文件同级目录下创建文件夹<code>2023-12-14_md+shoka使用技巧</code>，内含图片<code>芙宁娜.jpg</code>。图片引用小括号内填写（格式问题，就不用代码块了）：<code>2023-12-14_md+shoka使用技巧/芙宁娜.jpg</code></p>\n<h2 id=\"多个图片显示\"><a href=\"#多个图片显示\" class=\"headerlink\" title=\"多个图片显示\"></a>多个图片显示</h2><p>使用相册图案列表（<strong>注意图片之间不用换行，我这里为了方便看所以分行了</strong>）</p>\n<pre><code class=\"language-txt\">![](https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg)\n![](https://s1.imagehub.cc/images/2023/11/16/49ada8b3e781b287ee31af3cc75393fd.jpeg)\n![](https://s1.imagehub.cc/images/2023/11/16/ec096dea8315c4068cd0e2aac4ac628f.jpeg)\n![](https://s1.imagehub.cc/images/2023/11/16/dbb87c34a09e2edb4e2324cb8f8cf42c.jpeg) &#123;.gallery&#125;\n</code></pre>\n<p><img data-src=\"https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg\"><img data-src=\"https://s1.imagehub.cc/images/2023/11/16/49ada8b3e781b287ee31af3cc75393fd.jpeg\"> <img data-src=\"https://s1.imagehub.cc/images/2023/11/16/ec096dea8315c4068cd0e2aac4ac628f.jpeg\"> <img data-src=\"https://s1.imagehub.cc/images/2023/11/16/dbb87c34a09e2edb4e2324cb8f8cf42c.jpeg\"> {.gallery}</p>\n<p>设置每行高度：data-height，默认为220。</p>\n<pre><code class=\"language-txt\">![](https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg)\n![](https://s1.imagehub.cc/images/2023/11/16/49ada8b3e781b287ee31af3cc75393fd.jpeg)\n![](https://s1.imagehub.cc/images/2023/11/16/ec096dea8315c4068cd0e2aac4ac628f.jpeg)\n![](https://s1.imagehub.cc/images/2023/11/16/dbb87c34a09e2edb4e2324cb8f8cf42c.jpeg) &#123;.gallery  data-height=&quot;100&quot;&#125;\n</code></pre>\n<p><img data-src=\"https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg\"><img data-src=\"https://s1.imagehub.cc/images/2023/11/16/49ada8b3e781b287ee31af3cc75393fd.jpeg\"><img data-src=\"https://s1.imagehub.cc/images/2023/11/16/ec096dea8315c4068cd0e2aac4ac628f.jpeg\"><img data-src=\"https://s1.imagehub.cc/images/2023/11/16/dbb87c34a09e2edb4e2324cb8f8cf42c.jpeg\"> {.gallery  data-height&#x3D;”100”}</p>\n<h1 id=\"代码显示\"><a href=\"#代码显示\" class=\"headerlink\" title=\"代码显示\"></a>代码显示</h1><p>填入基本格式：<code>[language] [title] [url] [link text] [mark] [command]</code></p>\n<p><code>language</code>：语言类型（raw表示空显示代码块）。<code>title</code>：标题内容。<code>url</code>：链接。<code>link text</code>：链接显示内容。<code>mark</code>：行高亮显示，用法为：<code>mark:2,4,5-8,9</code>。<code>command</code>：命令行提示符，用法为：<code>command:(&quot;&gt;&gt; root$&quot;:1,4||&quot;&gt;&gt; host$&quot;:6,7)</code></p>\n<h2 id=\"编程语言代码\"><a href=\"#编程语言代码\" class=\"headerlink\" title=\"编程语言代码\"></a>编程语言代码</h2><pre><code class=\"language-raw\">python 示例代码 https://hening25.gitee.io 链接 mark:1,3-4\n\nimport math\nimport numpy as np\nimport torch\narray = np.arrary([1,2,3])\n</code></pre>\n<pre><code class=\"language-python\">import math\nimport numpy as np\nimport torch\narray = np.arrary([1,2,3])\n</code></pre>\n<h2 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h2><pre><code class=\"language-raw\">bash 命令行 https://hening25.gitee.io 链接 command:(&quot;(base) PS D:\\&gt; &quot;:1,2,6||&quot;(base) PS D:\\Github&gt;&quot;:7)\n\nls\npwd\nPath\n----\nD:\\\ncd Github\npwd\nPath\n----\nD:\\Github\n</code></pre>\n<pre><code class=\"language-bash\">ls\npwd\nPath\n----\nD:\\\ncd Github\npwd\nPath\n----\nD:\\Github\n</code></pre>\n<h1 id=\"PDF文件显示\"><a href=\"#PDF文件显示\" class=\"headerlink\" title=\"PDF文件显示\"></a>PDF文件显示</h1><pre><code>&#123;% pdf file_path  600 1000%&#125;\n</code></pre>\n<h1 id=\"待办事件\"><a href=\"#待办事件\" class=\"headerlink\" title=\"待办事件\"></a>待办事件</h1><pre><code class=\"language-raw\">- [ ] 叉叉\n- [x] 勾勾\n&#123;.danger&#125;\n\n- [ ] 叉叉\n- [x] 勾勾\n&#123;.danger&#125;\n\n- [ ] 叉叉\n- [x] 默认颜色\n</code></pre>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 叉叉</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 勾勾</li>\n</ul>\n<p>{.danger}</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 叉叉</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 勾勾</li>\n</ul>\n<p>{.primary}</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 叉叉</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 默认颜色</li>\n</ul>\n<h1 id=\"习题模式\"><a href=\"#习题模式\" class=\"headerlink\" title=\"习题模式\"></a>习题模式</h1><p>该模式需要在<code>Front Matter</code>中添加<code>quiz: true</code>。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">标签</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>&#123;.quiz&#125;</code></td>\n<td>选择题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#123;.quiz .multi&#125;</code></td>\n<td>多选题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#123;.quiz .true&#125;</code></td>\n<td>正确的判断题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#123;.quiz .false&#125;</code></td>\n<td>错误的判断题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#123;.quiz .fill&#125;</code></td>\n<td>填空题</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[]&#123;.gap&#125;</code></td>\n<td>空白下划线</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[答案内容]&#123;.gap&#125;</code></td>\n<td>答案内容下划线</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#123;.options&#125;</code></td>\n<td>选择题的选项</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&#123;.correct&#125;</code></td>\n<td>选择题的正确选项</td>\n</tr>\n<tr>\n<td align=\"left\"><code>&gt;</code></td>\n<td>答案解析</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[8.2]&#123;.mistake&#125;</code></td>\n<td>错题备注</td>\n</tr>\n</tbody></table>\n<pre><code class=\"language-raw\">1. 下列定义中合法的是[]&#123;.gap&#125;。&#123;.quiz .multi&#125;\n\t- `shor _a=1-.1e-1;` &#123;.correct&#125;\n\t- `double b=1+5e2.5;`\n\t- `long do=0xfdaL;`\n\t- `float end_=0.1;` &#123;.correct&#125;\n\t&#123;.options&#125;\n\t&gt; - :heavy_check_mark: 正确\n\t&gt; - :x: 错误\n\t&gt; - :x: 错误\n\t&gt; - :heavy_check_mark: 正确\n2. -8在内存中的存储形式是[]&#123;.gap&#125;。&#123;.quiz&#125;\n\t- `11111111 11111000` &#123;.correct&#125;\n\t- `10000000 00001000`\n\t- `00000000 00001000`\n\t- `11111111 11110111`\n\t&#123;.options&#125;\n3. 已知int x=6;则执行x+=x-=x*x语句后，x的值是[-60]&#123;.gap&#125;。&#123;.quiz .fill&#125;\n</code></pre>\n<ol>\n<li><p>下列定义中合法的是[]{.gap}。{.quiz .multi}</p>\n<ul>\n<li><code>shor _a=1-.1e-1;</code> {.correct}</li>\n<li><code>double b=1+5e2.5;</code></li>\n<li><code>long do=0xfdaL;</code></li>\n<li><code>float end_=0.1;</code> {.correct}<br>{.options}<blockquote>\n<ul>\n<li>:heavy_check_mark: 正确</li>\n<li>:x: 错误</li>\n<li>:x: 错误</li>\n<li>:heavy_check_mark: 正确<br>{.options}</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>-8在内存中的存储形式是[]{.gap}。{.quiz}</p>\n<ul>\n<li><code>11111111 11111000</code> {.correct}</li>\n<li><code>10000000 00001000</code></li>\n<li><code>00000000 00001000</code></li>\n<li><code>11111111 11110111</code><br> {.options}</li>\n</ul>\n</li>\n<li><p>已知int x&#x3D;6;则执行x+&#x3D;x-&#x3D;x*x语句后，x的值是[-60]{.gap}。 {.quiz .fill}</p>\n</li>\n</ol>\n","categories":["杂谈"]},{"title":"05 控制系统的李雅普诺夫稳定性分析","url":"/2023/12/15/2023-12-15-%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%8E%E9%9B%85%E6%99%AE%E8%AF%BA%E5%A4%AB%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/","content":"<p>现代控制理论——05 控制系统的李雅普诺夫稳定性分析</p>\n<span id=\"more\"></span>\n\n<h1 id=\"控制系统的李雅普诺夫稳定性分析\"><a href=\"#控制系统的李雅普诺夫稳定性分析\" class=\"headerlink\" title=\"控制系统的李雅普诺夫稳定性分析\"></a>控制系统的李雅普诺夫稳定性分析</h1><h2 id=\"李氏稳定性的定义\"><a href=\"#李氏稳定性的定义\" class=\"headerlink\" title=\"李氏稳定性的定义\"></a>李氏稳定性的定义</h2><p>何为平衡状态？对于一个系统 $\\dot{x}&#x3D;f(x,t)$，若果存在状态 $x_e$ 满足 $\\dot{x}_e\\equiv 0$，那么该状态即为平衡状态。</p>\n<ol>\n<li><strong>稳定</strong>：对于任意实数 $\\varepsilon&gt;0$，都存在一个实数 $\\delta&gt;0$ 满足 $||x_0-x_e||\\leq\\delta$，从任意 $x_0$ 触发的解都能够满足 $||x_t-x_e||\\leq\\varepsilon$，则称 $x_e$ 在李雅普诺夫意义下是<strong>稳定</strong>的。</li>\n<li><strong>渐进稳定</strong>：当上述解能够满足 $||x_t-x_e||\\leq\\mu$，也就是能够收敛到 $x_e$ 时，则称系统<strong>渐进稳定</strong>。</li>\n<li><strong>不稳定</strong>：无论 $\\delta$ 有多小，都会使得 $||x_t-x_e||&gt;\\varepsilon$，则称系统<strong>不稳定</strong>。</li>\n</ol>\n<p><img data-src=\"https://s1.imagehub.cc/images/2023/12/15/0dfa81a886d2cba99a38d05364f57ecd.png\"><br><img data-src=\"https://s1.imagehub.cc/images/2023/12/15/8d8829ffb7da9bc162c4e91874a019f9.png\"><br><img data-src=\"https://s1.imagehub.cc/images/2023/12/15/f84bc555ea80a021158a0f6dab2b292b.png\"> {.gallery}</p>\n<ol start=\"4\">\n<li><p><strong>大范围渐进稳定</strong>：从状态空间中所有初始点出发的轨迹都具有渐进稳定性，那么状态 $x_e$ 为<strong>大范围渐进稳定</strong>。</p>\n</li>\n<li><p><strong>正定函数</strong>：对于函数 $V(x)$，在区域 $S$ 内的所有 $x$ 都有：① $V(x)$ 中的各分量的偏导均存在；②$V(0)&#x3D;0$ ；③当 $x\\neq0$ 时， $V(x)&gt;0 (V(x)\\geq0)$ 。则称该函数是正定(半正定)的。</p>\n</li>\n</ol>\n<h2 id=\"李雅普诺夫第一方法\"><a href=\"#李雅普诺夫第一方法\" class=\"headerlink\" title=\"李雅普诺夫第一方法\"></a>李雅普诺夫第一方法</h2><ol>\n<li>线性系统的稳定性判据</li>\n</ol>\n<p>李雅普诺夫稳定的充要条件：系统矩阵 $A$ 的全部特征值实部大于0，即位于复平面左半部。</p>\n<ol start=\"2\">\n<li>非线性系统的稳定性判据</li>\n</ol>\n<p>对于非线性系统 $\\dot{x}&#x3D;f(x)$，讨论其在可能平衡状态 $x_e$ 的稳定性。引入新向量 $y&#x3D;x-x_e$，那么系统的状态方程转换为 $\\dot{y}&#x3D;Ay+G(y)y$，其中 $A$ 为雅克比矩阵。 </p>\n<p>……</p>\n<h2 id=\"李雅普诺夫第二方法\"><a href=\"#李雅普诺夫第二方法\" class=\"headerlink\" title=\"李雅普诺夫第二方法\"></a>李雅普诺夫第二方法</h2><p>对于状态方程为 $\\dot{x}&#x3D;f(x,t),f(0,t)&#x3D;0$ 的系统，存在一个具有连续偏导的标量函数 $V(x,t)$，满足</p>\n<ol>\n<li><p>$V(x,t)$ 正定，$\\dot{V}(x,t)$ 半正定，则系统在原点<strong>一致稳定</strong>；在此基础上，若对于任意 $t_0$ 和 $x_0\\neq0$，在 $t\\geq t_0$ 时不恒等于 0，则系统在原点<strong>渐进稳定</strong>；在此基础上，若随着 $||x||\\to \\infty$，$V(x,t)\\to \\infty$，则系统在原点<strong>大范围渐进稳定</strong>。</p>\n</li>\n<li><p>$V(x,t)$ 正定，$\\dot{V}(x,t)$ 正定，则系统在原点<strong>不稳定</strong>；</p>\n</li>\n</ol>\n<p>+++info 例题 </p>\n<p>;;;id1 例题1</p>\n<p>:::info no-icon</p>\n<p>用李雅普诺夫第二方法判断以下系统的稳定性。</p>\n<p>$$\\begin{aligned}&amp;\\dot{x}_1&#x3D;-(x_1+x_2)-x_2^2\\&amp;\\dot{x}_2&#x3D;-(x_1+x_2)+x_1x_2\\end{aligned}$$</p>\n<p>:::</p>\n<p>系统存在的唯一可能平衡状态为 $x_1&#x3D;0,x_2&#x3D;0$，取标量函数 $V(x)&#x3D;x_1^2+x_2^2$，显然 $V(x)$ 正定，求导有 </p>\n<p>$$\\dot{V}(x)&#x3D;2x_1\\dot{x}_1+2x_2\\dot{x}_2&#x3D;-2(x_1+x_2)^2$$</p>\n<p>负定。除原点外有 $x_1&#x3D;-x_2$ 使得 $\\dot{V}(x)&#x3D;0$，但是系统状态仍在转移中，故 $\\dot{V}(x)$ 不会恒定等于 0。且随着 $||x||\\to \\infty$，$V(x)\\to \\infty$，故系统在原点大范围渐进稳定。</p>\n<p>:::</p>\n<p>+++</p>\n<h3 id=\"李雅普诺夫方程判断线性系统的稳定性\"><a href=\"#李雅普诺夫方程判断线性系统的稳定性\" class=\"headerlink\" title=\"李雅普诺夫方程判断线性系统的稳定性\"></a>李雅普诺夫方程判断线性系统的稳定性</h3><ol>\n<li><p>在连续系统 $\\dot{x}&#x3D;Ax$ 中，在平衡状态 $x&#x3D;0$ 处是大范围渐进稳定的充要条件：对于给定的正定对称实矩阵 $Q$，存在一个正定实对称矩阵 $P$ ，满足 $A^TP+PA&#x3D;-Q$。（其中 $x^TPx$ 就是李雅普诺夫函数 ） </p>\n</li>\n<li><p>在离散系统 $x(k+1)&#x3D;Gx(k)$，在平衡状态 $x&#x3D;0$ 处是渐进稳定的充要条件：对于给定的正定对称实矩阵 $Q$，存在一个正定实对称矩阵 $P$ ，满足 $G^TPG-P&#x3D;-Q$。（其中 $x^TPx$ 就是李雅普诺夫函数 ）</p>\n</li>\n</ol>\n<p>+++info 例题</p>\n<p>;;;id2 例题1</p>\n<p>:::info no-icon</p>\n<p>以下系统的平衡状态在坐标原点，判断其渐进稳定性。</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1\\-1&amp;-1\\end{bmatrix}x$$</p>\n<p>:::</p>\n<p>设 $P&#x3D;\\begin{bmatrix}p_{11}&amp;p_{12}\\p_{12}&amp;p_{22}\\end{bmatrix}$，由 $A^TP+PA&#x3D;-I$ 有，$\\begin{bmatrix}0&amp;-1\\1&amp;-1\\end{bmatrix}\\begin{bmatrix}p_{11}&amp;p_{12}\\p_{12}&amp;p_{22}\\end{bmatrix}+\\begin{bmatrix}p_{11}&amp;p_{12}\\p_{12}&amp;p_{22}\\end{bmatrix}\\begin{bmatrix}0&amp;1\\-1&amp;-1\\end{bmatrix}&#x3D;\\begin{bmatrix}-1&amp;0\\0&amp;-1\\end{bmatrix}$，则 $\\left{\\begin{aligned}&amp;-2p_{12}&#x3D;-1\\&amp;p_{11}-p_{12}-p_{22}&#x3D;0\\&amp;2p_{12}-2p_{22}&#x3D;-1\\end{aligned} \\right.\\to \\left{\\begin{aligned}&amp;p_{11}&#x3D;\\frac{3}{2}\\&amp;p_{12}&#x3D;1\\&amp;p_{22}&#x3D;\\frac{1}{2}\\end{aligned} \\right.$，得到 $P&#x3D;\\begin{bmatrix}\\frac{3}{2}&amp;\\frac{1}{2}\\\\frac{1}{2}&amp;1\\end{bmatrix}$，验证各阶主子行列式是否大于 0：$P_{11}&#x3D;\\frac{3}{2}&gt;0$，$P_{22}&#x3D;det\\begin{bmatrix}p_{11}&amp;p_{12}\\p_{12}&amp;p_{22}\\end{bmatrix}&#x3D;\\frac{5}{4}&gt;0$，故矩阵 $P$ 正定。故系统在原点大范围渐进稳定。</p>\n<p>;;;id2 例题2</p>\n<p>:::info no-icon</p>\n<p>以下系统的平衡状态在坐标原点，判断其渐进稳定性。</p>\n<p>$$\\begin{bmatrix}x_1(k+1)\\x_2(k+1)\\end{bmatrix}&#x3D;\\begin{bmatrix}0&amp;0.5\\-0.5&amp;-1\\end{bmatrix}\\begin{bmatrix}x_1(k)\\x_2(k)\\end{bmatrix}$$</p>\n<p>:::</p>\n<p>设 $P&#x3D;\\begin{bmatrix}p_{11}&amp;p_{12}\\p_{12}&amp;p_{22}\\end{bmatrix}$，由 $G^TPG-P&#x3D;-I$ 有，$\\begin{bmatrix}0&amp;-0.5\\0.5&amp;-1\\end{bmatrix}\\begin{bmatrix}p_{11}&amp;p_{12}\\p_{12}&amp;p_{22}\\end{bmatrix}\\begin{bmatrix}0&amp;0.5\\-0.5&amp;-1\\end{bmatrix}-\\begin{bmatrix}p_{11}&amp;p_{12}\\p_{12}&amp;p_{22}\\end{bmatrix}&#x3D;\\begin{bmatrix}-1&amp;0\\0&amp;-1\\end{bmatrix}$，得到 $P&#x3D;\\begin{bmatrix}\\frac{52}{27}&amp;\\frac{40}{27}\\\\frac{40}{27}&amp;\\frac{100}{27}\\end{bmatrix}$，验证各阶主子行列式均大于 0，故矩阵 $P$ 正定。故系统在原点大范围渐进稳定。</p>\n<p>+++</p>\n","categories":["现代控制理论"]},{"title":"06 状态反馈和状态观测器","url":"/2023/12/21/2023-12-21-%E7%8A%B6%E6%80%81%E5%8F%8D%E9%A6%88%E5%92%8C%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B%E5%99%A8/","content":"<p>现代控制理论——06 状态反馈和状态观测器</p>\n<span id=\"more\"></span>\n\n<h1 id=\"状态反馈和状态观测器\"><a href=\"#状态反馈和状态观测器\" class=\"headerlink\" title=\"状态反馈和状态观测器\"></a>状态反馈和状态观测器</h1><h2 id=\"状态反馈\"><a href=\"#状态反馈\" class=\"headerlink\" title=\"状态反馈\"></a>状态反馈</h2><p>状态反馈的公式可表示为：</p>\n<p>$$u&#x3D;Lv-Kx     \\tag{1}$$</p>\n<p>定常系统$\\left{\\begin{aligned}\\dot{x}&amp;&#x3D;Ax+Bu\\y&amp;&#x3D;Cx\\end{aligned}\\right.$ 表示为 $\\left{\\begin{aligned}\\dot{x}&amp;&#x3D;(A-BK)x+BLv\\y&amp;&#x3D;Cx\\end{aligned}\\right.$ 。</p>\n<p>:::info no-icon</p>\n<p>引入状态反馈并不影响系统的能控性，但有可能影响系统的能观测性。</p>\n<p>:::</p>\n<h3 id=\"极点配置定理\"><a href=\"#极点配置定理\" class=\"headerlink\" title=\"极点配置定理\"></a>极点配置定理</h3><p>给定系统 $\\Sigma:\\left{\\begin{aligned}\\dot{x}&amp;&#x3D;Ax+Bu\\y&amp;&#x3D;Cx+Du\\end{aligned}\\right.$ 通过状态反馈 $u&#x3D;Lv-Kx$ 能使闭环极点位于预先任意指定位置上的充要条件是该系统 $\\Sigma$ 完全能控。</p>\n<p>+++info 证明</p>\n<p><strong>充分性</strong>：</p>\n<p><strong>必要性</strong>：</p>\n<p>+++</p>\n<h3 id=\"单输入系统极点配置算法\"><a href=\"#单输入系统极点配置算法\" class=\"headerlink\" title=\"单输入系统极点配置算法\"></a>单输入系统极点配置算法</h3><p>求 $1\\times n$ 的实向量 $K$，使得矩阵 $(A-bK)$ 的特征值为给定的复共轭成对出现的 $\\lambda_1^<em>,\\lambda_2^</em>,\\dots,\\lambda_n^*$。</p>\n<ol>\n<li><strong>算法1</strong>  适用于系统维数较高，控制矩阵中非零元素较多的情况。</li>\n</ol>\n<p>:::info no-icon</p>\n<p>计算前先判断系统是否完全可控，即判断 $rank(U_c)&#x3D;n$ 。具体原因见<a href=\"#%E6%9E%81%E7%82%B9%E9%85%8D%E7%BD%AE%E5%AE%9A%E7%90%86\">极点配置定理</a></p>\n<p>:::</p>\n<ul>\n<li>求 $A$ 的特征多项式：$a(s)&#x3D;det(sI-A)&#x3D;s^n+a_1s^{n-1}+\\dots+a_{n-1}s+a_n$ 。</li>\n<li>求闭环系统的期望特征多项式：$a^<em>(s)&#x3D;(s-\\lambda_1^</em>)(s-\\lambda_2^<em>)\\dots (s-\\lambda_n^</em>)&#x3D;s^n+a_1^*s^{n-1}+\\dots+a_{n-1}s+a_n$ 。</li>\n<li>计算：$\\tilde{K}&#x3D;\\begin{bmatrix}a_n^<em>-a_n&amp;a_{n-1}^</em>-a_{n-1}&amp;\\dots&amp;a_1^*-a_1\\end{bmatrix}$ 。</li>\n<li>计算：$Q&#x3D;\\begin{bmatrix}b&amp;Ab&amp;\\dots&amp;A^{n-1}b\\end{bmatrix}\\cdot{}\\begin{bmatrix}a_{n-1}&amp;\\dots&amp;a_1&amp;1\\\\vdots&amp;\\cdot^{\\cdot^{\\cdot}}&amp;\\cdot^{\\cdot^{\\cdot}}&amp;\\a_1&amp;\\cdot^{\\cdot^{\\cdot}}&amp;0&amp;\\1\\end{bmatrix}$ 。</li>\n<li>令 $P&#x3D;Q^{-1}$，求 $K&#x3D;\\tilde{K}P$ 。</li>\n</ul>\n<p>+++info 例题</p>\n<p>;;;id1 例题1</p>\n<p>:::info no-icon</p>\n<p>给定系统的状态空间表达式 $\\dot{x}&#x3D;\\begin{bmatrix}0&amp;0&amp;0\\1&amp;-1&amp;0\\0&amp;1&amp;-1\\end{bmatrix}x+\\begin{bmatrix}1\\0\\0\\end{bmatrix}u$，求状态反馈矩阵 $K$ 使得反馈后闭环特征值为 $\\lambda_1^<em>&#x3D;-2,\\lambda_{2,3}^</em>&#x3D;-1\\pm j\\sqrt{3}$。</p>\n<p>:::</p>\n<p>由于 $rank(U_c)&#x3D;rank(\\begin{bmatrix}b&amp;Ab&amp;A^2b\\end{bmatrix})&#x3D;rank\\begin{bmatrix}1&amp;0&amp;0\\0&amp;1&amp;-1\\0&amp;0&amp;1\\end{bmatrix}&#x3D;3$，故系统完全可控。</p>\n<ul>\n<li>$det({sI-A})&#x3D;det\\begin{bmatrix}s&amp;0&amp;0\\-1&amp;s+1&amp;0\\0&amp;-1&amp;s+1\\end{bmatrix}&#x3D;s^3+2s^2+s$，得到 $a_1&#x3D;2,a_2&#x3D;1,a_3&#x3D;0$。</li>\n<li>$(s-\\lambda_1^<em>)(s-\\lambda_2^</em>)(s-\\lambda_3^<em>)&#x3D;(s+2)(s+1+j\\sqrt3)(s+1-j\\sqrt3)&#x3D;s^3+4s^2+8s+8$，得到 $a_1^</em>&#x3D;4,a_2^<em>&#x3D;8,a_3^</em>&#x3D;8$。</li>\n<li>$\\tilde{K}&#x3D;\\begin{bmatrix}a_3^<em>-a_3&amp;a_2^</em>-a_2&amp;a_1^*-a_1\\end{bmatrix}&#x3D;\\begin{bmatrix}8&amp;7&amp;2\\end{bmatrix}$ 。</li>\n<li>$Q&#x3D;\\begin{bmatrix}b&amp;Ab&amp;A^2b\\end{bmatrix}\\cdot{}\\begin{bmatrix}a_2&amp;a_1&amp;1\\a_1&amp;1&amp;0\\1&amp;0&amp;0\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;2&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;0\\end{bmatrix}$ 。</li>\n<li>$P&#x3D;Q^{-1}&#x3D;\\begin{bmatrix}1&amp;2&amp;1\\1&amp;1&amp;0\\1&amp;0&amp;0\\end{bmatrix}^{-1}&#x3D;\\begin{bmatrix}0&amp;0&amp;1\\0&amp;1&amp;-1\\1&amp;-2&amp;1\\end{bmatrix}$， $K&#x3D;\\tilde{K}P&#x3D;\\begin{bmatrix}8&amp;7&amp;2\\end{bmatrix}\\begin{bmatrix}0&amp;0&amp;1\\0&amp;1&amp;-1\\1&amp;-2&amp;1\\end{bmatrix}&#x3D;\\begin{bmatrix}2&amp;3&amp;3\\end{bmatrix}$ 。</li>\n</ul>\n<p>;;;</p>\n<p>+++</p>\n<ol start=\"2\">\n<li><strong>算法2</strong>  适用于系统维数较低，控制矩阵中只有一个非零元素的情况。</li>\n</ol>\n<ul>\n<li>将 $u&#x3D;-Kx$ 代入系统状态方程 $sI-A+bK$，求得相应闭环系统的特征多项式： $a(s)&#x3D;s^n+a_1(K)s^{n-1}+\\cdots+a_{n-1}(K)s+a_n(K)$。</li>\n<li>计算理想特征多项式：$a^<em>(x)&#x3D;(s-\\lambda_1^</em>)(s-\\lambda_2^<em>)\\cdots(s-\\lambda_n^</em>)&#x3D;s^n+a_1^*s^{n-1}+\\cdots+a_{n-1}^<em>s+a_n^</em>$。</li>\n<li>将 $a(s)$ 与 $a^*(s)$ 各项一一对应即可求解。</li>\n</ul>\n<p>+++info 例题</p>\n<p>;;;id2 例题1</p>\n<p>:::info no-icon</p>\n<p>给定系统的状态空间表达式 $\\dot{x}&#x3D;\\begin{bmatrix}0&amp;0&amp;0\\1&amp;-1&amp;0\\0&amp;1&amp;-1\\end{bmatrix}x+\\begin{bmatrix}1\\0\\0\\end{bmatrix}u$，求状态反馈矩阵 $K$ 使得反馈后闭环特征值为 $\\lambda_1^<em>&#x3D;-2,\\lambda_{2,3}^</em>&#x3D;-1\\pm j\\sqrt{3}$。</p>\n<p>:::</p>\n<p>由于 $rank(U_c)&#x3D;rank(\\begin{bmatrix}b&amp;Ab&amp;A^2b\\end{bmatrix})&#x3D;rank\\begin{bmatrix}1&amp;0&amp;0\\0&amp;1&amp;-1\\0&amp;0&amp;1\\end{bmatrix}&#x3D;3$，故系统完全可控。</p>\n<ul>\n<li>设所需的状态反馈矩阵 $K$ 为 $K&#x3D;\\begin{bmatrix}k_1&amp;k_2&amp;k_3\\end{bmatrix}$，则经过状态反馈 $u&#x3D;v-Kx$ 后闭环系统的特征多项式为:</li>\n</ul>\n<p>$$\\begin{aligned}a(s)&amp;&#x3D;det(sI-A+bK)\\&amp;&#x3D;det\\begin{Bmatrix}\\begin{bmatrix}s&amp;0&amp;0\\0&amp;s&amp;0\\0&amp;0&amp;s\\end{bmatrix}-\\begin{bmatrix}0&amp;0&amp;0\\1&amp;-1&amp;0\\0&amp;1&amp;-1\\end{bmatrix}+\\begin{bmatrix}1\\0\\0\\end{bmatrix}\\begin{bmatrix}k_1&amp;k_2&amp;k_3\\end{bmatrix}\\end{Bmatrix}\\&amp;&#x3D;s^3+(2+k_1)s^2+(2k_1+k_2+1)s+(k_1+k_2+k_3)\\end{aligned}$$</p>\n<ul>\n<li>由题，目标闭环期望极点对应的闭环特征多项式为：$a^*(s)&#x3D;(s+2)(s+1+j\\sqrt{3})(s+1-j\\sqrt{3})&#x3D;s^3+4s^2+8s+8$。</li>\n<li>对比 $a(s)$ 与 $a^*(s)$ ，可得 $2+k_1&#x3D;4,2k_1+k_2+1&#x3D;8,k_1+k_2+k_3&#x3D;8$。解得 $K&#x3D;\\begin{bmatrix}k_1&amp;k_2&amp;k_3\\end{bmatrix}&#x3D;\\begin{bmatrix}2&amp;3&amp;3\\end{bmatrix}$。</li>\n</ul>\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"状态观测器\"><a href=\"#状态观测器\" class=\"headerlink\" title=\"状态观测器\"></a>状态观测器</h2><h3 id=\"状态观测器的存在条件\"><a href=\"#状态观测器的存在条件\" class=\"headerlink\" title=\"状态观测器的存在条件\"></a>状态观测器的存在条件</h3><p>:::info no-icon</p>\n<ol>\n<li>充分条件：能观测。</li>\n<li>充要条件：不能观测的部分渐进稳定。</li>\n</ol>\n<p>:::</p>\n<p> 给定定常系统 $\\Sigma:\\left{\\begin{aligned}\\dot{x}&amp;&#x3D;Ax+Bu\\y&amp;&#x3D;Cx\\end{aligned}\\right.$ ，若状态完全能观测，则状态向量 $x$ 能够由输入 $x$ 和输出 $y$ 表示。</p>\n<p>+++info 证明</p>\n<p>由于 $\\left{\\begin{aligned}y&amp;&#x3D;Cx\\\\dot{y}&amp;&#x3D;C\\dot{x}&#x3D;CAx+CBu\\y^{(n)}&amp;&#x3D;CA\\dot{x}+CB\\dot{u}&#x3D;CA^2x+CABu+CB\\dot{u}\\ &amp;\\vdots\\y^{(n-1)}&amp;&#x3D;CA^{n-1}x+CA^{n-2}Bu+\\cdots+CBu^{(n-2)}\\end{aligned}\\right.$ ，则</p>\n<p>$$\\begin{bmatrix}y\\\\dot{y}-CBu\\y^{(n)}-CABu-CB\\dot{u}\\ \\vdots\\y^{(n-1)}-CA^{n-2}Bu-\\cdots-CBu^{(n-2)}\\end{bmatrix}&#x3D;\\begin{bmatrix}C\\CA\\CA^2\\\\vdots\\CA^{n-1}\\end{bmatrix}x&#x3D;Nx$$</p>\n<p>当且仅当 $rank(N)&#x3D;n$ 时，上述 $x$ 有唯一解。$N$即是能观性矩阵。</p>\n<p>+++</p>\n","categories":["现代控制理论"]},{"title":"Life prediction model for lithium-ion battery via a 3D convolutional network enhanced by channel attention considering charging and discharging process","url":"/2024/12/01/2024-12-01_Life%20prediction%20model%20for%20lithium-ion%20battery%20via%20a%203D%20convolutional%20network%20enhanced%20by%20channel%20attention%20considering%20charging%20and%20discharging%20process/","content":"<p>基于动态自编码网络的电池故障检测</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Life-prediction-model-for-lithium-ion-battery-via-a-3D-convolutional-network-enhanced-by-channel-attention-considering-charging-and-discharging-process\"><a href=\"#Life-prediction-model-for-lithium-ion-battery-via-a-3D-convolutional-network-enhanced-by-channel-attention-considering-charging-and-discharging-process\" class=\"headerlink\" title=\"Life prediction model for lithium-ion battery via a 3D convolutional network enhanced by channel attention considering charging and discharging process\"></a>Life prediction model for lithium-ion battery via a 3D convolutional network enhanced by channel attention considering charging and discharging process</h1><p>Article link: <a href=\"\">Realistic fault detection of li-ion battery via dynamical deep learning (nature.com)</a></p>\n<p>local link: [Realistic fault detection of li-ion battery via dynamical deep learning](&#x2F;downloads&#x2F;2024-12-01_Life prediction model for lithium-ion battery via a 3D convolutional network enhanced by channel attention considering charging and discharging process.pdf)</p>\n<p>Date: 2024-12-01</p>\n<h2 id=\"Gaps\"><a href=\"#Gaps\" class=\"headerlink\" title=\"Gaps\"></a>Gaps</h2><ul>\n<li><p>对于多路测量参数（温度、电压、电流等），已有研究大多将它们直接连接，忽视了其中的耦合关系，导致了在映射到潜在特征空间时出现解耦。这种数据交互不足阻碍了模型的性能。</p>\n</li>\n<li><p>在模型层面：（1）许多方法仅关注充电或放电单一过程；（2）CNN在处理时序性数据时性能不佳，且缺乏不同充电策略下的泛化能力。</p>\n</li>\n</ul>\n<h2 id=\"Novelty-Originality\"><a href=\"#Novelty-Originality\" class=\"headerlink\" title=\"Novelty&#x2F;Originality\"></a>Novelty&#x2F;Originality</h2><ul>\n<li><p>从放电过程中的IC曲线和电压曲线中提取HI，与充电特征进行融合；</p>\n</li>\n<li><p>通过RP技术将充电过程中的VIT数据转换为多维数据；</p>\n</li>\n<li><p>提出了一种深度可分离的通道注意力3DCNN，用以解决权重数量多喝数据缺乏耦合计算的问题；</p>\n</li>\n<li><p>提出了一种同时预测不同充电协议下的寿命预测方法。</p>\n</li>\n</ul>\n<h2 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"Input\"></a>Input</h2><h3 id=\"Datasets\"><a href=\"#Datasets\" class=\"headerlink\" title=\"Datasets\"></a>Datasets</h3><p>数据集采用MIT的两套锂离子退化数据集，分别包含了124和45个电池样本，两套数据集的采用不同的充电策略。</p>\n<ul>\n<li>（1）“C1(Q1)-C2”-(80%)-“1CC(3.6V)-1CV”</li>\n<li>（2）“CC1-CC2-CC3-CC4”-“CC5-CV1”</li>\n</ul>\n<h3 id=\"Charge-process\"><a href=\"#Charge-process\" class=\"headerlink\" title=\"Charge process\"></a>Charge process</h3><p>RP技术：</p>\n<h3 id=\"DisCharge-process\"><a href=\"#DisCharge-process\" class=\"headerlink\" title=\"DisCharge process\"></a>DisCharge process</h3><ul>\n<li>IC曲线的峰值坐标（PIIC）</li>\n<li></li>\n</ul>\n","categories":["论文文献阅读"]},{"title":"Transformer","url":"/2024/12/15/2025-06-18-%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA/","content":"<p>AA-CrossViT——模型搭建</p>\n<span id=\"more\"></span>\n\n<p>本文模型采用基于轴向分块和交叉注意力融合策略的双分支视觉Transformer作为锂离子电池早期寿命预测模型。具体而言，分别基于图形特征的电压轴向和周期轴向进行分块，而后利用卷积层将各分块编码到向量空间，随后添加反映分块信息和位置的可学习参数矩阵分类token $x_{cls}$ 和位置编码矩阵 $X_{pe}$ 。Transformer编码层用以提取特征和捕捉分块间的依赖关系，随后提取双流分支的分类token和分块token输出作为交叉注意力机制的输入，以融合双轴向分支的信息。</p>\n<h3 id=\"Related-Module\"><a href=\"#Related-Module\" class=\"headerlink\" title=\"Related Module\"></a>Related Module</h3><p>导入相关依赖库。</p>\n<pre><code class=\"language-python\">import torch\nimport torch.nn as nn\nfrom torch import Tensor\nfrom einops.layers.torch import Rearrange, Reduce\nfrom einops import repeat, rearrange\nfrom torchsummary import summary\n</code></pre>\n<p>:::info no-icon</p>\n<ul>\n<li><code>Rearrange/Reduce</code>和<code>rearrange/reduce</code>的区别：</li>\n</ul>\n<p>前者是网络层，后者是数据处理函数。</p>\n<p>:::</p>\n<h3 id=\"Input-Size\"><a href=\"#Input-Size\" class=\"headerlink\" title=\"Input Size\"></a>Input Size</h3><p>本文输入为锂离子电池的图形特征输入，尺寸为$3\\times 100\\times 100$。</p>\n<pre><code class=\"language-python\">x = torch.randn(3,100,100)   # 单样本尺寸为3*100*100\nprint(x.shape)   # (3,100,100)\n\nx_batch = torch.randn(16,3,100,100)  # 单个batch尺寸为16*3*100*100\nprint(x_batch.shape)\n</code></pre>\n<h3 id=\"Patch-Embedding\"><a href=\"#Patch-Embedding\" class=\"headerlink\" title=\"Patch Embedding\"></a>Patch Embedding</h3><p>视觉Transformer模型的第一步需要将图片划分为多个分块（Patches），并且将其映射到向量。具体而言，处于效率考虑，先利用卷积层将每个分块映射到向量空间维度$d_k$，卷积核的大小与步长均为patch的尺寸，卷积核个数等于编码维度$d_k$，而后利用<code>Rearrange</code>函数改变维度顺序。</p>\n<pre><code class=\"language-python\">in_channels, patch_size = 3, (1,100)\nprojection = nn.Sequential(\n            nn.Conv2d(in_channels=in_channels, out_channels=emb_size, kernel_size=patch_size, stride=(1,1)),\n            Rearrange(&quot;b e h w -&gt; b (h w) e&quot;),\n        )\n</code></pre>\n<p>:::info no-icon</p>\n<p><code>Rearrange/Reduce</code>参数解析：输入参数格式为字符串</p>\n<p>:::</p>\n<pre><code class=\"language-python\">class PatchEmbedding(nn.Module):\n    def __init__(self, input_size:int=100, in_channels:int=3, patch_size:tuple=(1,100), emb_size:int=100):\n        super().__init__()\n        self.projection = nn.Sequential(\n            nn.Conv2d(in_channels=in_channels, out_channels=emb_size, kernel_size=patch_size, stride=(1,1)),\n            Rearrange(&quot;b e h w -&gt; b (h w) e&quot;),\n        )\n        self.cls_token = nn.Parameter(torch.randn(1,1,emb_size)/emb_size)\n        self.positions = nn.Parameter(torch.randn((input_size**2 // (patch_size[0]*patch_size[1]) + 1,emb_size)) / emb_size)\n\n    def forward(self,x:Tensor):\n        b, c, h, w = x.shape\n        x = self.projection(x)\n        cls_tokens = repeat(self.cls_token,&quot;() n e -&gt; b n e&quot;,b=b)\n        x = torch.cat([cls_tokens, x], dim=1)\n        x += self.positions    # 这里区别于class token直接用广播机制相加，原因是位置编码应该在batch内的不同样本也保持一致\n        # print(x.shape)\n        return x\n</code></pre>\n<h3 id=\"Class-Token\"><a href=\"#Class-Token\" class=\"headerlink\" title=\"Class Token\"></a>Class Token</h3><h3 id=\"Positional-Encoding\"><a href=\"#Positional-Encoding\" class=\"headerlink\" title=\"Positional Encoding\"></a>Positional Encoding</h3><h3 id=\"Transformer-Encoder\"><a href=\"#Transformer-Encoder\" class=\"headerlink\" title=\"Transformer Encoder\"></a>Transformer Encoder</h3><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3>","categories":["AA-CrossViT","Transformer"]},{"title":"01 矩阵的相似变换","url":"/2024/09/21/2024-09-21-%E7%9F%A9%E9%98%B5%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%8F%98%E6%8D%A2/","content":"<p>矩阵论——01 矩阵的相似变换</p>\n<span id=\"more\"></span>\n\n<h1 id=\"控制系统的状态空间描述\"><a href=\"#控制系统的状态空间描述\" class=\"headerlink\" title=\"控制系统的状态空间描述\"></a>控制系统的状态空间描述</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"系统的状态空间模型\"><a href=\"#系统的状态空间模型\" class=\"headerlink\" title=\"系统的状态空间模型\"></a>系统的状态空间模型</h3><ol>\n<li>线性时变系统的状态空间模型：系数矩阵与时间无关。</li>\n</ol>\n<p>$$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.   \\tag{1}$$</p>\n<p>其中，$u&#x3D;R^r$为输入向量；$y&#x3D;R^m$为输出向量；$x\\in R^n$为状态向量。$A,B,C,D$为系数矩阵。</p>\n<ol start=\"2\">\n<li>线性时不变系统的状态空间模型：系数矩阵与时间有关。</li>\n</ol>\n<p>$$\\left{ \\begin{matrix} \\dot{x}&#x3D;A(t)x+B(t)u\\y&#x3D;C(t)x+D(t)u\\\\end{matrix}\\right.   \\tag{2}$$</p>\n<ol start=\"3\">\n<li>离散线性系统的状态空间模型。</li>\n</ol>\n<p>$$\\left{ \\begin{matrix} x(k+1)&#x3D;A(k)x(k)+B(k)u(k)\\y(k)&#x3D;C(k)x(k)+D(k)u(k)\\\\end{matrix}\\right.   \\tag{3}$$</p>\n<h3 id=\"状态空间描述的特点\"><a href=\"#状态空间描述的特点\" class=\"headerlink\" title=\"状态空间描述的特点\"></a>状态空间描述的特点</h3><ol>\n<li>系统的状态变量的个数&#x3D;系统中包含的独立储能元件的个数&#x3D;系统的阶数。</li>\n<li>在给定的系统中，状态变量的选择不唯一，但是状态变量的个数是一致的。</li>\n<li>基于状态变量选取的不同，同一系统可以用不同的动态方程来描述。</li>\n</ol>\n<p>+++primary 证明</p>\n<p>对于一个状态方程$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx\\\\end{matrix}\\right.$，选择非奇异矩阵$P\\in R^{n\\times n}$作为变换阵，有$x&#x3D;P\\overline{x}$，那么此时状态方程可表示为：</p>\n<p>$$\\dot{\\overline{x}}&#x3D;P^{-1}\\dot{x}&#x3D;P^{-1}[Ax+Bu]&#x3D;P^{-1}AP\\overline{x}+P^{-1}Bu&#x3D;\\overline{A}\\overline{x}+\\overline{B}u   \\tag{4}$$</p>\n<p>$$y&#x3D;Cx&#x3D;CP\\overline{x}&#x3D;\\overline{C}\\overline{x}    \\tag{5}$$</p>\n<p>其中，$\\overline{A}&#x3D;P^{-1}AP,\\overline{B}&#x3D;P^{-1}B,\\overline{C}&#x3D;CP$。</p>\n<p>因此当状态变量 $x$ 改变时，一定存在变换矩阵 $P$ 使得状态方程发生变化。</p>\n<p>+++</p>\n<h3 id=\"状态空间模型的建立步骤\"><a href=\"#状态空间模型的建立步骤\" class=\"headerlink\" title=\"状态空间模型的建立步骤\"></a>状态空间模型的建立步骤</h3><ol>\n<li>选择状态变量。</li>\n<li>根据物体或其他机理列写微分方程。</li>\n<li>转化为矩阵形式，得到状态空间模型。</li>\n</ol>\n<h3 id=\"状态空间表达式的系统方框图\"><a href=\"#状态空间表达式的系统方框图\" class=\"headerlink\" title=\"状态空间表达式的系统方框图\"></a>状态空间表达式的系统方框图</h3><p>公式（1）是线性时不变系统状态空间表达式的一般形式。其系统方框图可表示如下：</p>\n\n\n<h3 id=\"状态空间表达式的状态变量图\"><a href=\"#状态空间表达式的状态变量图\" class=\"headerlink\" title=\"状态空间表达式的状态变量图\"></a>状态空间表达式的状态变量图</h3><ol>\n<li>状态变量图的基本元素符号</li>\n</ol>\n\n\n<ol start=\"2\">\n<li>绘制步骤</li>\n</ol>\n<ul>\n<li><strong>绘制积分器</strong>  积分器数量等于状态变量数目。</li>\n<li><strong>由状态方程和输出方程绘制加法器和放大器</strong></li>\n<li><strong>连接各元件</strong></li>\n</ul>\n<p>+++info 例题</p>\n<p>;;;id1 例题1</p>\n<p>:::info no-icon</p>\n<p>设有三阶系统状态空间表达式如下，试绘制其状态变量图。</p>\n<p>$$\\left{ \\begin{aligned}\\begin{matrix} \\dot{x}_1&#x3D;x_2\\\\dot{x}_2&#x3D;x_3\\\\dot{x}_3&#x3D;-6x_1-3x_2-2x_3+u\\y&#x3D;x_1+x_2\\end{matrix}\\end{aligned}\\right.$$</p>\n<p>:::</p>\n<p>其状态变量图可绘制如下：</p>\n\n\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"传递函数和传递函数矩阵\"><a href=\"#传递函数和传递函数矩阵\" class=\"headerlink\" title=\"传递函数和传递函数矩阵\"></a>传递函数和传递函数矩阵</h2><h3 id=\"单输入单输出系统\"><a href=\"#单输入单输出系统\" class=\"headerlink\" title=\"单输入单输出系统\"></a>单输入单输出系统</h3><p>对于单输入单输出系统$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.$，在零初始条件下其传递函数可表示为：</p>\n<p>$$g(s)&#x3D;\\frac{Y(s)}{U(s)}&#x3D;C(sI-A)^{-1}B+D    \\tag{6}$$</p>\n<p>+++primary 推导</p>\n<p>在系统$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.$ 中，在零初始条件下取拉氏变换有：$\\left{ \\begin{matrix} sX(s)&#x3D;AX(s)+BU(s)\\Y(s)&#x3D;CX(s)+DU(s)\\\\end{matrix}\\right.$，整理得到$\\left{ \\begin{matrix} X(s)&#x3D;(sI-A)^{-1}BU(s)\\Y(s)&#x3D;C(sI-A)^{-1}BU(s)+DU(s)\\\\end{matrix}\\right.$，故$g(s)&#x3D;\\frac{Y(s)}{U(s)}&#x3D;C(sI-A)^{-1}B+D$</p>\n<p>+++</p>\n<p>在 $D&#x3D;0$ 时，$g(s)&#x3D;\\frac{Y(s)}{U(s)}&#x3D;C(sI-A)^{-1}B&#x3D;\\frac{Cadj(sI-A)B}{|sI-A|}$，其中$adj(sI-A)$表示矩阵$sI-A$的伴随矩阵。</p>\n<p>对比自控原理中传递函数的表达式：$g(s)&#x3D;\\frac{b_0s^n+b_1s^{n-1}+\\cdots +b_{n-1}s+b_n}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n}$，可知：</p>\n<ol>\n<li>系统矩阵$A$的特征多项式等同于传递函数的分母多项式。</li>\n<li>传递函数的极点就是系统矩阵$A$的特征值。</li>\n<li><strong>传递函数的不变性</strong>  同一系统的状态空间描述不唯一，但传递函数是唯一的。</li>\n</ol>\n<p>+++primary 证明：同一系统的不同状态空间描述具有相同的特征值。</p>\n<p>对于同一系统，选择两个不同的状态向量 $x\\in{R^n}$ 和 $\\overline{x}\\in{R^n}$ 分别得到不同的状态空间描述：</p>\n<p>$$\\begin{matrix}\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.&amp;&amp;&amp;\\left{ \\begin{matrix} \\dot{\\overline{x}}&#x3D;\\overline{A}\\overline{x}+\\overline{B}u\\y&#x3D;\\overline{C}\\overline{x}+\\overline{D}u\\\\end{matrix}\\right.\\end{matrix}$$</p>\n<p>两种状态变量一定存在着可逆变化关系：$x&#x3D;P\\overline{x}$，故：</p>\n<p>$$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.\\Rightarrow \\left{ \\begin{matrix} P\\dot{\\overline{x}}&#x3D;AP\\overline{x}+Bu\\y&#x3D;CP\\overline{x}+Du\\\\end{matrix}\\right.\\Rightarrow \\left{ \\begin{matrix} \\dot{\\overline{x}}&#x3D;P^{-1}AP\\overline{x}+P^{-1}Bu\\y&#x3D;CP\\overline{x}+Du\\\\end{matrix}\\right.$$</p>\n<p>故 $\\overline{A}&#x3D;P^{-1}AP$，所以矩阵 $A$ 与矩阵 $\\overline{A}$ 相似，故特征值相同。</p>\n<p>:::info</p>\n<p>相似矩阵具体相同的特征值</p>\n<p>:::</p>\n<p>+++</p>\n<h3 id=\"多输入多输出系统\"><a href=\"#多输入多输出系统\" class=\"headerlink\" title=\"多输入多输出系统\"></a>多输入多输出系统</h3><p>对于多输入多输出系统，输入向量$u&#x3D;[u_1\\cdots u_p]^T$，输出向量$y&#x3D;[y_1\\dots y_q]^T$。我们把第$i$个输出$y_i$和第$j$个输入$u_j$间的传递函数定义为：$g_{ij}(s)&#x3D;\\frac{Y_i(s)}{U_j(s)}$。故系统的输入输出关系可表示为：</p>\n<p>$$\\begin{bmatrix}Y_1(s)\\Y_2(s)\\\\vdots\\Y_q(s)\\end{bmatrix}&#x3D;\\begin{bmatrix}g_{11}(s)&amp;g_{12}(s)&amp;\\cdots&amp;g_{1p}(s)\\g_{21}(s)&amp;g_{22}(s)&amp;\\cdots&amp;g_{2p}(s)\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\g_{q1}(s)&amp;g_{q2}(s)&amp;\\cdots&amp;g_{qp}(s)\\end{bmatrix}\\begin{bmatrix}U_1(s)\\U_2(s)\\\\vdots\\U_q(s)\\end{bmatrix}$$</p>\n<p>以矩阵的形式表示：$Y(s)&#x3D;G(s)U(s)$，其中 $G(s)$称为传递函数矩阵。</p>\n<p>对于多输入多输出系统$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.$，同样传递函数矩阵为：</p>\n<p>$$G(s)&#x3D;C(sI-A)^{-1}B+D&#x3D;\\frac{Cadj(sI-A)B+D|sI-A|}{|sI-A|}$$</p>\n<p>+++info 例题</p>\n<p>;;;id2 例题1</p>\n<p>:::info no-icon</p>\n<p>已知系统动态方程为$\\begin{bmatrix}\\dot{x}_1\\\\dot{x}_2\\end{bmatrix}&#x3D;\\begin{bmatrix}0&amp;1\\0&amp;-2\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\end{bmatrix}+\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}\\begin{bmatrix}u_1\\u_2\\end{bmatrix}$，$\\begin{bmatrix}y_1\\y_2\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\end{bmatrix}$，试求系统的传递函数矩阵。</p>\n<p>:::</p>\n<p>由题，$G(s)&#x3D;C(sI-A)^{-1}B+D&#x3D;\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}\\begin{bmatrix}\\frac{1}{s}&amp;\\frac{1}{s(s+2)}\\0&amp;\\frac{1}{s+2}\\end{bmatrix}\\begin{bmatrix}1&amp;0\\0&amp;1\\end{bmatrix}&#x3D;\\begin{bmatrix}\\frac{1}{s}&amp;\\frac{1}{s(s+2)}\\0&amp;\\frac{1}{s+2}\\end{bmatrix}$。</p>\n<p>;;;</p>\n<p>+++</p>\n<h2 id=\"建立状态空间表达式\"><a href=\"#建立状态空间表达式\" class=\"headerlink\" title=\"建立状态空间表达式\"></a>建立状态空间表达式</h2><h3 id=\"高阶微分方程化为状态空间描述\"><a href=\"#高阶微分方程化为状态空间描述\" class=\"headerlink\" title=\"高阶微分方程化为状态空间描述\"></a>高阶微分方程化为状态空间描述</h3><p>在单输入单输出线性时不变系统中，系统的输出与输入的关系可用如下高阶微分方程描述：</p>\n<p>$$y^{(n)}+a_1y^{(n-1)}+\\cdots +a_{n-1}\\dot{y}+a_ny&#x3D;b_0u^{(m)}+b_1u^{(m-1)}+\\cdots +b_{m-1}\\dot{u}+b_mu    \\tag{7}$$</p>\n<p>其中，$m\\leq n$。根据微分方程右侧是否含有输入函数的导数（即$m$是否等于0）分两种情况讨论。</p>\n<h4 id=\"常微分方程中不含输入函数的导数\"><a href=\"#常微分方程中不含输入函数的导数\" class=\"headerlink\" title=\"常微分方程中不含输入函数的导数\"></a>常微分方程中不含输入函数的导数</h4><p>若常微分方程中不含有输入函数的导数，即：$y^{(n)}+a_1y^{(n-1)}+\\cdots +a_{n-1}\\dot{y}+a_ny&#x3D;b_mu$。</p>\n<p>那么可以选取状态变量：</p>\n<p>$$x_1&#x3D;\\frac{1}{b_m}y,\\quad x_2&#x3D;\\frac{1}{b_m}\\dot{y},\\quad \\cdots \\quad  x_n&#x3D;\\frac{1}{b_m}y^{(n-1)}      \\tag{8}$$</p>\n<p>那么就可以得到状态方程（前$n-1$条通过求导获得，最后一条通过原微分方程获得）：</p>\n<p>$$\\left{ \\begin{matrix} \\dot{x}_1&#x3D;x_2\\\\dot{x}_2&#x3D;x_3\\\\vdots\\\\dot{x}<em>n&#x3D;y^{(n)}&#x3D;-a_nx_1-a</em>{n-1}x_2-\\cdots -a_1x_n+u\\end{matrix}\\right.$$</p>\n<p>输出方程为：$y&#x3D;b_mx_1$。</p>\n<p>以矩阵的形式可表示为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1&amp;\\cdots &amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;1\\-a_n&amp;-a_{n-1}&amp;\\cdots&amp;-a_1\\end{bmatrix}x+\\begin{bmatrix}0\\0\\\\vdots\\1\\end{bmatrix}u    \\tag{9}$$</p>\n<p>$$y&#x3D;\\begin{bmatrix}1&amp;0&amp;\\cdots&amp;0\\end{bmatrix}x     \\tag{10}$$</p>\n<p>+++primary 能控标准型</p>\n<p>形如公式（9）的状态空间模型称为能控标准型。即$A$与$b$可用以下形式表示：</p>\n<p>$$A&#x3D;\\begin{bmatrix}0&amp;1&amp;\\cdots &amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;1\\-a_n&amp;-a_{n-1}&amp;\\cdots&amp;-a_1\\end{bmatrix},\\quad b&#x3D;\\begin{bmatrix}0\\0\\\\vdots\\1\\end{bmatrix}$$</p>\n<p>+++</p>\n<p>+++info 例题</p>\n<p>;;;id3 例题1</p>\n<p>:::info no-icon</p>\n<p>设系统的运动方程为：$y^{(3)}+5\\ddot{y}+8\\dot{y}+6y&#x3D;3u$，试求其状态空间表达式。</p>\n<p>:::</p>\n<p>选取状态变量$x_1&#x3D;y,\\quad x_2&#x3D;\\dot{y},\\quad x_3&#x3D;\\ddot{y}$，则有状态方程：</p>\n<p>$$\\left{ \\begin{matrix} \\dot{x}_1&#x3D;x_2\\\\dot{x}_2&#x3D;x_3\\\\dot{x}_3&#x3D;y^{(3)}&#x3D;-6x_1-8x_2 -5x_3+3u\\end{matrix}\\right.$$</p>\n<p>输出方程为$y&#x3D;x_1$。</p>\n<p>故状态空间表达式为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1 &amp;0\\0&amp;0&amp;1\\-6&amp;-8&amp;-5\\end{bmatrix}x+\\begin{bmatrix}0\\0\\3\\end{bmatrix}u $$</p>\n<p>$$y&#x3D;\\begin{bmatrix}1&amp;0&amp;0\\end{bmatrix}x$$</p>\n<p>;;;</p>\n<p>+++</p>\n<h4 id=\"常微分方程中含有输入函数的导数\"><a href=\"#常微分方程中含有输入函数的导数\" class=\"headerlink\" title=\"常微分方程中含有输入函数的导数\"></a>常微分方程中含有输入函数的导数</h4><p>若常微分方程中含有输入函数的导数，即：$y^{(n)}+a_1y^{(n-1)}+\\cdots +a_{n-1}\\dot{y}+a_ny&#x3D;b_0u^{(m)}+b_1u^{(m-1)}+\\cdots +b_{m-1}\\dot{u}+b_mu$。</p>\n<p>选择状态变量：</p>\n<p>$$\\left{ \\begin{matrix} x_1&#x3D;y-\\beta_0u\\x_2&#x3D;\\dot{x}<em>1-\\beta_1u&#x3D;\\dot{y}-\\beta_0\\dot{u}-\\beta_1u\\x_3&#x3D;\\dot{x}<em>2-\\beta_2u&#x3D;\\ddot{y}-\\beta_0\\ddot{u}-\\beta_1\\dot{u}-\\beta_2u\\\\vdots\\x_n&#x3D;\\dot{x}</em>{n-1}-\\beta</em>{n-1}u&#x3D;y^{(n)}-\\beta_0u^{(n-1)}-\\beta_1u^{(n-2)}-\\cdots -\\beta_{n-2}\\dot{u}-\\beta_{n-1}u\\end{matrix}\\right.   \\tag{11}$$</p>\n<p>其中参数$\\beta_0,\\beta_1,\\cdots,\\beta_n$由下式决定：</p>\n<p>$$\\begin{bmatrix}\\beta_0\\\\beta_1\\\\beta_2\\\\vdots\\\\beta_n\\end{bmatrix}&#x3D;\\begin{bmatrix}1&amp;0&amp;\\cdots&amp;0&amp;0\\a_1&amp;1&amp;\\cdots&amp;0&amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots&amp;\\vdots\\a_{n-1}&amp;a_{n-2}&amp;\\cdots&amp;1&amp;0\\a_n&amp;a_{n-1}&amp;\\cdots&amp;a_1&amp;1\\end{bmatrix}\\begin{bmatrix}b_0\\b_1\\b_2\\\\vdots\\b_n\\end{bmatrix}    \\tag{12}$$</p>\n<p>由（11）可得到状态方程：$\\left{ \\begin{matrix} \\dot{x}<em>1&#x3D;x_2+\\beta_1u\\\\dot{x}<em>2&#x3D;x_3+\\beta_2u\\\\vdots\\\\dot{x}</em>{n-1}&#x3D;x_n+\\beta</em>{n-1}u\\\\begin{aligned}\\dot{x}<em>n&amp;&#x3D;y^{(n)}-\\beta_0u^{(u)}-\\beta_1u^{(n-1)}-\\cdots -\\beta</em>{n-2}\\ddot{u}-\\beta_{n-1}\\dot{u}\\&amp;&#x3D;-a_nx_1-a_{n-1}x_2-\\cdots -a_1x_n+\\beta_nu\\end{aligned} \\end{matrix}\\right.$。</p>\n<p>+++info 最后一个等式怎么化简得到的？</p>\n<p>+++</p>\n<p>因此，状态空间表达式为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1&amp;0&amp;\\cdots&amp;0\\0&amp;0&amp;1&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;0&amp;\\cdots&amp;1\\-a_n&amp;-a_{n-1}&amp;-a_{n-2}&amp;\\cdots&amp;-a_1\\end{bmatrix}x+\\begin{bmatrix}\\beta_0\\\\beta_1\\\\vdots\\\\beta_{n-1}\\\\beta_n\\end{bmatrix}u   \\tag{13}$$</p>\n<p>$$y&#x3D;[1\\quad 0\\quad \\cdots\\quad 0 ]x+\\beta_0u$$</p>\n<h3 id=\"通过传递函数建立状态空间描述\"><a href=\"#通过传递函数建立状态空间描述\" class=\"headerlink\" title=\"通过传递函数建立状态空间描述\"></a>通过传递函数建立状态空间描述</h3><p>后续的方法我们讨论的传递函数的分子多项式次数均小于分母多项式次数。因为对于实际系统，分子多项式次数总是小于或等于分母多项式次数，在次数相等时可以通过化简的方法转化为分子多项式次数小于分母多项式次数。</p>\n<p>+++primary 推导</p>\n<p>若传递函数的分子多项式次数等于分母多项式次数，即</p>\n<p>$$g(s)&#x3D;\\frac{b_0s^m+b_1s^{m-1}+\\cdots +b_{m-1}s+b_m}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n},m&#x3D;n$$</p>\n<p>它总是可以化简为：</p>\n<p>$$g(s)&#x3D;\\frac{b_1s^{m-1}+\\cdots +b_{m-1}s+b_m}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n}&#x3D;\\overline{g}(s)+b_0,m&#x3D;n$$</p>\n<p>其中 $\\overline{g}(s)$ 为分子多项式次数小于分母多项式次数的传递函数，$b_0$ 为常数，整体视为两者的并联结构。</p>\n<p>+++</p>\n<h4 id=\"直接分解法\"><a href=\"#直接分解法\" class=\"headerlink\" title=\"直接分解法\"></a>直接分解法</h4><p>对于$n$阶传递函数：$g(s)&#x3D;\\frac{Y(s)}{U(s)}&#x3D;\\frac{b_1s^{n-1}+\\cdots +b_{n-1}s+b_n}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n}$。</p>\n<p>同时除以$s^n$有：$Y(s)&#x3D;U(s)\\frac{b_1s^{-1}+\\cdots +b_{n-1}s^{-(n-1)}+b_ns^{-n}}{1+a_1s^{-1}+\\cdots +a_{n-1}s^{-(n-1)}+a_ns^{-n}}$。</p>\n<p>令中间变量$E(s)&#x3D;U(s)\\frac{1}{1+a_1s^{-1}+\\cdots +a_{n-1}s^{-(n-1)}+a_ns^{-n}}$，即$E(s)&#x3D;U(s)-a_1s^{-1}E(s)-\\cdots -a_{n-1}s^{-(n-1)}E(s)-a_ns^{-n}E(s)$。</p>\n<p>则输入$U(s)$、中间变量$E(s)$和输出$Y(s)$的关系流程图如下：</p>\n\n\n<p>则$Y(s)&#x3D;b_1s^{-1}E(s)+b_2s^{-2}E(s)+\\cdots +b_{n-1}s^{-(n-1)}E(s)+b_ns^{-n}E(s)$。</p>\n<p>令$x_n,x_{n-1},\\cdots,x_1$为$s^{-1}E(s),s^{-2}E(s),\\cdots,s^{-n}E(s)$的拉氏逆变换，那么就可以绘制状态变量图并得到系统的状态空间表达式（能控标准型）。</p>\n\n\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}0&amp;1&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\0&amp;0&amp;\\cdots&amp;1\\-a_n&amp;-a_{n-1}&amp;\\cdots&amp;-a_1\\end{bmatrix}x+\\begin{bmatrix}0\\\\vdots\\0\\1\\end{bmatrix}u   \\tag{14}$$</p>\n<p>$$y&#x3D;[b_n\\quad b_{n-1}\\quad \\cdots\\quad b_1 ]x$$</p>\n<p>+++info 补充</p>\n<p>如果该$n$阶系统传递函数的分子多项式次数等于分母多项式次数（在<a href=\"#%E9%80%9A%E8%BF%87%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%BB%BA%E7%AB%8B%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0\">通过传递函数建立状态空间描述</a>中讨论过该情况）即 $g(s)&#x3D;\\frac{b_1s^{m-1}+\\cdots +b_{m-1}s+b_m}{s^n+a_1s^{n-1}+\\cdots +a_{n-1}s+a_n}&#x3D;\\overline{g}(s)+b_0,m&#x3D;n$，那么先算出 $\\overline{g}(s)$ 后在输入到输出之间直接连接一个比例环节即可。</p>\n<p>+++</p>\n<h4 id=\"串联分解法\"><a href=\"#串联分解法\" class=\"headerlink\" title=\"串联分解法\"></a>串联分解法</h4><p>该方法适用于传递函数可分解为因式相乘的形式，即$g(s)&#x3D;\\frac{b_1(s-z_1)(s-z_2)\\cdots(s-z_{n-1})}{(s-p_1)(s-p_2)\\dots(s-p_n)}$。</p>\n<p>以一个三阶系统进行说明：$g(s)&#x3D;\\frac{b_1(s-z_1)(s-z_2)}{(s-p_1)(s-p_2)(s-p_3)}$。</p>\n<p>上式中可分为两种：$\\frac{1}{s-p}&#x3D;\\frac{\\frac{1}{s}}{1-\\frac{1}{s}p}$，$\\frac{s-z}{s-p}&#x3D;1+\\frac{p-z}{s-p}&#x3D;1+(p-z)\\frac{\\frac{1}{s}}{1-\\frac{1}{s}p}$。</p>\n<p>因此系统可视为三个一阶系统串联而成，结构图如下：</p>\n\n\n<p>取每个积分器的输出为状态变量，那么可以得到状态空间表达式如下：</p>\n<p>$$\\left{ \\begin{matrix} \\dot{x}_1&#x3D;p_1x_1+b_1u\\\\dot{x}_2&#x3D;x_1+p_2x_2\\\\dot{x}_3&#x3D;x_1+(p_2-z_2)x_2+p_3x_3\\y&#x3D;x_1+(p_2-z_2)x_2+(p_3-z_3)x_3\\end{matrix}\\right.$$</p>\n<p>写成向量的形式为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}p_1&amp;0&amp;0\\1&amp;p_2&amp;0\\1&amp;p_2-z_2&amp;p_3\\end{bmatrix}x+\\begin{bmatrix}b_1\\0\\0\\end{bmatrix}u   \\tag{15}$$</p>\n<p>$$y&#x3D;[1\\quad p_2-z_2\\quad \\quad p_3-z_3 ]x$$</p>\n<h4 id=\"并联分解法\"><a href=\"#并联分解法\" class=\"headerlink\" title=\"并联分解法\"></a>并联分解法</h4><ol>\n<li>若传递函数的极点两两相异。</li>\n</ol>\n<p>传递函数极点两两相异，则$g(s)&#x3D;\\frac{N(s)}{(s-p_1)(s-p_2)\\dots(s-p_n)}&#x3D;\\frac{c_1}{s-p_1}+\\frac{c_2}{s-p_2}+\\cdots+\\frac{c_n}{s-p_n}$，其中$c_i&#x3D;\\lim_{s\\to p_i}(s-p_i)g(s)$。</p>\n<p>选取状态变量 $x_i(s)&#x3D;\\frac{1}{s-p_i}U(s)$，即 $sx_i(s)&#x3D;p_ix_i(s)+u(s)$，做拉氏逆变换有：</p>\n<p>$$\\dot{x}_i(t)&#x3D;p_ix_i(t)+u(t)$$</p>\n<p>输出 $y(s)&#x3D;g(s)u(s)&#x3D;\\sum_{i&#x3D;1}^n\\frac{c_i}{s-p_i}u_i(s)&#x3D;\\sum_{i&#x3D;1}^nc_ix_i(s)$，做拉氏逆变换有：</p>\n<p>$$y(t)&#x3D;\\sum_{i&#x3D;1}^nc_ix_i(t)$$</p>\n<p>写成向量的形式为：</p>\n<p>$$\\dot{x}&#x3D;\\begin{bmatrix}p_1&amp;0&amp;\\cdots&amp;0\\0&amp;p_2&amp;\\cdots&amp;0\\\\vdots&amp;\\vdots&amp;\\ddots&amp;0\\0&amp;0&amp;\\cdots&amp;p_n\\end{bmatrix}x+\\begin{bmatrix}1\\1\\\\vdots\\1\\end{bmatrix}u   \\tag{16}$$</p>\n<p>$$y&#x3D;[c_1\\quad c_2\\quad\\cdots \\quad c_n]x$$</p>\n<p>+++info 上式为对角标准型</p>\n<p>对于系统 $\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx\\\\end{matrix}\\right.$ ，若$A$为对角阵且各元素为传递函数的极点，$B$为全1矩阵，$C$内各元素为对应极点的留数，那么称该矩阵表达式为对角标准型。</p>\n<p>+++</p>\n<ol start=\"2\">\n<li>若传递函数具有重极点。</li>\n</ol>\n<p>先考虑只有一个重极点和若干个单极点，重数为$r$，$g(s)&#x3D;\\frac{c_{11}}{(s-p_1)^{r}}+\\frac{c_{12}}{(s-p_1)^{r-1}}+\\cdots+\\frac{c_{1r}}{(s-p_1)^{}}+\\frac{c_{r+1}}{s-p_{r+1}}+\\cdots+\\frac{c_n}{s-p_n}$，其中对于单极点仍有：$c_i&#x3D;\\lim_{s\\to p_i}(s-p_i)g(s)$，而对于重极点则有：$c_1j&#x3D;\\frac{1}{(j-1)!}\\lim_{s\\to p_1}\\frac{d^{j-1}}{ds^{j-1}}[(s-p_1)g(s)],\\quad j&#x3D;1,2,\\cdots,r$。</p>\n<p>选取状态变量，化简求拉氏逆变换得到状态方程：</p>\n<p>$$\\begin{matrix}\\left{ \\begin{matrix} x_1(s)&#x3D;\\frac{U(s)}{(s-p_1)^{r}}\\x_2(s)&#x3D;\\frac{U(s)}{(s-p_1)^{r-1}}\\\\vdots\\x_r(s)&#x3D;\\frac{U(s)}{(s-p_1)}\\x_{r+1}(s)&#x3D;\\frac{U(s)}{s-p_{r+1}}\\\\vdots\\x_{1}(s)&#x3D;\\frac{U(s)}{s-p_{n}}\\end{matrix}\\right.\\quad\\stackrel{}{\\Rightarrow}\\quad\\left{ \\begin{matrix} x_1(s)&#x3D;\\frac{1}{s-p_1}x_2(s)\\x_2(s)&#x3D;\\frac{1}{s-p_1}x_3(s)\\\\vdots\\x_r(s)&#x3D;\\frac{1}{s-p_1}U(s)\\x_{r+1}(s)&#x3D;\\frac{1}{s-p_{r+1}}U(s)\\\\vdots\\x_n(s)&#x3D;\\frac{1}{s-p_n}U(s)\\end{matrix}\\right.\\quad\\stackrel{L^{-1}}{\\Rightarrow}\\quad \\left{ \\begin{matrix} \\dot{x}<em>1(t)&#x3D;p_1x_1+x_2\\\\dot{x}<em>2(t)&#x3D;p_1x_2+x_3\\\\vdots\\\\dot{x}<em>r(t)&#x3D;p_1x_r+u\\\\dot{x}</em>{r+1}(t)&#x3D;p</em>{r+1}x</em>{x+1}+u\\\\vdots\\\\dot{x}_n(t)&#x3D;p_nx_n+u\\end{matrix}\\right.     \\end{matrix}$$</p>\n<p>输出方程的拉氏变换为：</p>\n<p>$$Y(s)&#x3D;c_{11}x_1(s)+c_{12}x_2(s)+\\cdots+c_{1r}x_r(s)+c_{r+1}x_{r+1}(s)+\\cdots+c_{nx_n(s)}$$</p>\n<p>求拉氏逆变换有：</p>\n<p>$$y(t)&#x3D;c_{11}x_1(t)+c_{12}x_2(t)+\\cdots+c_{1r}x_r(t)+c_{r+1}x_{r+1}(t)+\\cdots+c_{nx_n(t)}$$</p>\n<p>得到状态空间表达式为：</p>\n<p>$$\\begin{bmatrix}\\dot{x_1}\\\\dot{x_2}\\\\vdots\\\\dot{x_r}\\\\dot{x_{r+1}}\\\\vdots\\\\dot{x_n}\\end{bmatrix}&#x3D;\\begin{bmatrix}p_1&amp;1&amp;&amp;&amp;&amp;&amp;\\&amp;p_1&amp;\\ddots&amp;&amp;&amp;\\bold{0}&amp;\\&amp;&amp;\\ddots&amp;1\\&amp;&amp;&amp;p_1\\&amp;&amp;&amp;&amp;p_{r+1}&amp;&amp;\\&amp;\\bold{0}&amp;&amp;&amp;&amp;\\ddots&amp;\\&amp;&amp;&amp;&amp;&amp;&amp;p_n\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\\\vdots\\x_r\\x_{r+1}\\\\vdots\\x_n\\end{bmatrix}+\\begin{bmatrix}0\\0\\\\vdots\\1\\1\\\\vdots\\1\\end{bmatrix}u   \\tag{17}$$</p>\n<p>$$y&#x3D;\\begin{bmatrix}c_{11}&amp; c_{12}&amp;\\cdots&amp; c_{1r}&amp;c_{r+1}&amp;\\cdots&amp;c_{n}\\end{bmatrix}\\begin{bmatrix}x_1\\x_2\\\\vdots\\x_r\\x_{r+1}\\\\vdots\\x_n\\end{bmatrix}$$</p>\n<p>对于重根部分，矩阵$A$中对应的是若尔当块，$B$中为一个只有末行是1其余行为0的矩阵，$C$中对应元素为$r$重极点对应的留数。而对于其中的单极点部分，形式与<a href=\"#%E5%B9%B6%E8%81%94%E5%88%86%E8%A7%A3%E6%B3%95\">无重根</a>时一致。</p>\n<p>拓展到具有多个重极点的情况。矩阵$A$中在对角上补充对应的若尔当块，$B$中对应补充只有末行是1其余行为0的矩阵，$C$中补充对应元素为$r$重极点对应的留数。</p>\n<h2 id=\"组合系统\"><a href=\"#组合系统\" class=\"headerlink\" title=\"组合系统\"></a>组合系统</h2><h3 id=\"并联联结\"><a href=\"#并联联结\" class=\"headerlink\" title=\"并联联结\"></a>并联联结</h3><p>在$n$个子系统并联的并联系统中，组合系统的传递函数矩阵等于子系统传递函数矩阵的和。</p>\n<p>$$G(s)&#x3D;G_1(s)+G_2(s)+\\cdots+G_n(s)   \\tag{18}$$</p>\n<h3 id=\"串联联结\"><a href=\"#串联联结\" class=\"headerlink\" title=\"串联联结\"></a>串联联结</h3><p>在$n$个子系统串联的串联系统中，组合系统的传递函数矩阵等于子系统传递函数矩阵的积。</p>\n<p>$$G(s)&#x3D;G_n(s)\\cdots G_2(s)G_1(s)   \\tag{19}$$</p>\n<p>:::info </p>\n<p>注：子系统传递函数矩阵的积遵循左乘原则。</p>\n<p>:::</p>\n<h3 id=\"反馈联结\"><a href=\"#反馈联结\" class=\"headerlink\" title=\"反馈联结\"></a>反馈联结</h3><p>对于系统 $G_1(s)$，若添加反馈环节（动态反馈$G_2(s)$或常数反馈$H$），则可得到组合系统的传递函数矩阵：</p>\n<ol>\n<li><strong>动态反馈</strong> 反馈子系统为动态系统$G_2(s)$。</li>\n</ol>\n<p>组合系统的传递函数矩阵为：</p>\n<p>$$G(s)&#x3D;[I+G_2(s)G_1(s)]^{-1}G_1(s)   \\tag{20}$$</p>\n<ol start=\"2\">\n<li><strong>常数反馈</strong>  反馈环节为常数矩阵$H$。</li>\n</ol>\n<p>组合系统的传递函数矩阵为：</p>\n<p>$$G(s)&#x3D;[I+HG_1(s)]^{-1}G_1(s)   \\tag{21}$$</p>\n<h2 id=\"线性变换\"><a href=\"#线性变换\" class=\"headerlink\" title=\"线性变换\"></a>线性变换</h2><h3 id=\"系统状态的线性变换\"><a href=\"#系统状态的线性变换\" class=\"headerlink\" title=\"系统状态的线性变换\"></a>系统状态的线性变换</h3><p>对于一个状态方程$\\left{ \\begin{matrix} \\dot{x}&#x3D;Ax+Bu\\y&#x3D;Cx+Du\\\\end{matrix}\\right.$，选择非奇异矩阵$P\\in R^{n\\times n}$作为变换阵，有$x&#x3D;P\\overline{x}$，那么此时状态方程可表示为：</p>\n<p>$$\\dot{\\overline{x}}&#x3D;P^{-1}\\dot{x}&#x3D;P^{-1}[Ax+Bu]&#x3D;P^{-1}AP\\overline{x}+P^{-1}Bu&#x3D;\\overline{A}\\overline{x}+\\overline{B}u   \\tag{22}$$</p>\n<p>$$y&#x3D;Cx&#x3D;CP\\overline{x}&#x3D;\\overline{C}\\overline{x}    \\tag{23}$$</p>\n<p>其中，$\\overline{A}&#x3D;P^{-1}AP,\\overline{B}&#x3D;P^{-1}B,\\overline{C}&#x3D;CP,\\overline{D}&#x3D;D$。</p>\n<p>:::info</p>\n<p>该方法通常用于将非对角阵$A$转化为对角阵$\\overline{A}$，从而实现状态变量的解耦。</p>\n<p>:::</p>\n<p>:::danger no-icon</p>\n<p>线性定常系统的系统矩阵A的特征值是表征系统的动力学特性的重要参量。系统的状态方程可通过适当的线性非奇异变换化为由特征值表征的标准形，对分析系统的结构特性非常直观。 </p>\n<ol>\n<li>特征值互异时，标准形为对角阵。</li>\n<li>特征值非互异时，标准形一般为约当阵。</li>\n</ol>\n<p>:::</p>\n<h3 id=\"状态方程转化为对角标准型\"><a href=\"#状态方程转化为对角标准型\" class=\"headerlink\" title=\"状态方程转化为对角标准型\"></a>状态方程转化为对角标准型</h3><h3 id=\"状态方程转化为若尔当标准型\"><a href=\"#状态方程转化为若尔当标准型\" class=\"headerlink\" title=\"状态方程转化为若尔当标准型\"></a>状态方程转化为若尔当标准型</h3><h3 id=\"状态变换后特征值及传递函数矩阵的不变形\"><a href=\"#状态变换后特征值及传递函数矩阵的不变形\" class=\"headerlink\" title=\"状态变换后特征值及传递函数矩阵的不变形\"></a>状态变换后特征值及传递函数矩阵的不变形</h3>","categories":["矩阵论"],"tags":["矩阵","相似变换"]},{"title":"Tucker分解","url":"/2025/07/17/2025-07-17-Tucker%E5%88%86%E8%A7%A3/","content":"<p>Tucker分解</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Tucker分解\"><a href=\"#Tucker分解\" class=\"headerlink\" title=\"Tucker分解\"></a>Tucker分解</h1><hr>\n<h2 id=\"什么是-Tucker-分解？\"><a href=\"#什么是-Tucker-分解？\" class=\"headerlink\" title=\"什么是 Tucker 分解？\"></a>什么是 Tucker 分解？</h2><p>Tucker 分解是 <strong>张量（tensor）分解</strong> 的一种，是矩阵 SVD（奇异值分解）在更高阶上的推广。</p>\n<p>它的核心思想是：</p>\n<blockquote>\n<p>用一个小的 <strong>核心张量</strong> $\\mathcal{G}$，以及几个矩阵将一个大的原始张量表示出来，达到<strong>降维、压缩、解耦</strong>的效果。</p>\n</blockquote>\n<hr>\n<h2 id=\"张量与模式乘积（mode-n-product）\"><a href=\"#张量与模式乘积（mode-n-product）\" class=\"headerlink\" title=\"张量与模式乘积（mode-n product）\"></a>张量与模式乘积（mode-n product）</h2><ul>\n<li><strong>矩阵是二维张量</strong>，例如： $A \\in \\mathbb{R}^{m \\times n}$.</li>\n<li><strong>张量是更高维的数组</strong>，例如：<ul>\n<li>三阶张量 $\\mathcal{X} \\in \\mathbb{R}^{I \\times J \\times K}$.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"模式-n乘积（Mode-n-product）\"><a href=\"#模式-n乘积（Mode-n-product）\" class=\"headerlink\" title=\"模式-n乘积（Mode-n product）\"></a>模式-n乘积（Mode-n product）</h3><p>给定三阶张量 $\\mathcal{X} \\in \\mathbb{R}^{I \\times J \\times K}$，和矩阵 $U \\in \\mathbb{R}^{L \\times I}$，那么：</p>\n<p>$$\\mathcal{Y} &#x3D; \\mathcal{X} \\times_1 U \\in \\mathbb{R}^{L \\times J \\times K}$$</p>\n<p>这表示对第一个维度（mode-1）做矩阵变换。其本质是：</p>\n<blockquote>\n<p>把张量的第1个维度的每个“切片”乘以 U</p>\n</blockquote>\n<hr>\n<h2 id=\"Tucker-分解的数学定义\"><a href=\"#Tucker-分解的数学定义\" class=\"headerlink\" title=\"Tucker 分解的数学定义\"></a>Tucker 分解的数学定义</h2><p>设有一个三阶张量：</p>\n<p>$$\\mathcal{X} \\in \\mathbb{R}^{I \\times J \\times K}$$</p>\n<p>Tucker 分解将其表示为：</p>\n<p>$$\\mathcal{X} \\approx \\mathcal{G} \\times_1 A \\times_2 B \\times_3 C$$</p>\n<p>其中：</p>\n<ul>\n<li>$\\mathcal{G} \\in \\mathbb{R}^{R_1 \\times R_2 \\times R_3}$：核心张量（压缩表示）</li>\n<li>$A \\in \\mathbb{R}^{I \\times R_1}$、$B \\in \\mathbb{R}^{J \\times R_2}$、$C \\in \\mathbb{R}^{K \\times R_3}$：模式矩阵，控制每个维度的投影</li>\n<li>$\\times_n$：表示对张量的第 n 维进行矩阵乘法</li>\n</ul>\n<blockquote>\n<p>总结一句话：Tucker 分解就是：</p>\n<p><strong>“把高维张量压缩成小的核心张量 + 每一维的线性变换矩阵”</strong></p>\n</blockquote>\n<hr>\n<h2 id=\"图示理解（示意图）\"><a href=\"#图示理解（示意图）\" class=\"headerlink\" title=\"图示理解（示意图）\"></a>图示理解（示意图）</h2><pre><code>            Tucker Decomposition\n           ┌───────────────┐\n           │  Tensor X     │         原始张量 X ∈ ℝ^&#123;I×J×K&#125;\n           └────┬──────────┘\n                ↓ Tucker分解\n       ┌────────┴────────┐\n       ↓        ↓        ↓\n  Matrix A   Matrix B   Matrix C    模式矩阵（每一维的降维）\n   (I×R1)     (J×R2)     (K×R3)\n       ↓        ↓        ↓\n            Core tensor G           核心张量 ∈ ℝ^&#123;R1×R2×R3&#125;\n</code></pre>\n<hr>\n<h2 id=\"为什么-Tucker-有用？\"><a href=\"#为什么-Tucker-有用？\" class=\"headerlink\" title=\"为什么 Tucker 有用？\"></a>为什么 Tucker 有用？</h2><p>Tucker 分解可以：</p>\n<ol>\n<li><p><strong>降低维度&#x2F;压缩张量</strong>：原始张量参数量为 $I \\times J \\times K$，而 Tucker 分解后是：</p>\n<p>$$I \\cdot R_1 + J \\cdot R_2 + K \\cdot R_3 + R_1 \\cdot R_2 \\cdot R_3$$</p>\n<p>通常远小于原始张量。</p>\n</li>\n<li><p><strong>捕捉模态之间的交互关系</strong>：核心张量 $\\mathcal{G}$ 建模了压缩后表示之间的高阶交互。</p>\n</li>\n<li><p><strong>在多模态场景中用于融合</strong>：比如图像、文本输入，分别编码后送入 Tucker 融合模块。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"举个数值例子\"><a href=\"#举个数值例子\" class=\"headerlink\" title=\"举个数值例子\"></a>举个数值例子</h2><p>设有张量 $\\mathcal{X} \\in \\mathbb{R}^{4 \\times 3 \\times 2}$，我们用 Tucker 分解它：</p>\n<ul>\n<li>模式矩阵：<ul>\n<li>$A \\in \\mathbb{R}^{4 \\times 2}$.</li>\n<li>$B \\in \\mathbb{R}^{3 \\times 2}$.</li>\n<li>$C \\in \\mathbb{R}^{2 \\times 1}$.</li>\n</ul>\n</li>\n<li>核心张量 $\\mathcal{G} \\in \\mathbb{R}^{2 \\times 2 \\times 1}$.</li>\n</ul>\n<p>合成的张量为：</p>\n<p>$$\\mathcal{X} \\approx \\mathcal{G} \\times_1 A \\times_2 B \\times_3 C \\in \\mathbb{R}^{4 \\times 3 \\times 2}$$</p>\n<hr>\n<h2 id=\"与其他分解的对比\"><a href=\"#与其他分解的对比\" class=\"headerlink\" title=\"与其他分解的对比\"></a>与其他分解的对比</h2><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>类型</th>\n<th>适用场景</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Tucker</td>\n<td>多模态张量分解</td>\n<td>多模态融合</td>\n<td>保留交互，参数可控</td>\n</tr>\n<tr>\n<td>CP (CANDECOMP&#x2F;PARAFAC)</td>\n<td>张量秩分解</td>\n<td>分解张量为秩1分量之和</td>\n<td>更简单但可解释性低</td>\n</tr>\n<tr>\n<td>PCA</td>\n<td>矩阵分解</td>\n<td>降维</td>\n<td>相当于 SVD 的特例</td>\n</tr>\n<tr>\n<td>SVD</td>\n<td>矩阵分解</td>\n<td>特征提取</td>\n<td>二阶张量特例</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h2><h3 id=\"1-多模态融合\"><a href=\"#1-多模态融合\" class=\"headerlink\" title=\"1. 多模态融合\"></a>1. 多模态融合</h3><p>如在视觉问答中，将图像向量 vv 和文本向量 qq 融合，用 Tucker 分解实现有效的高阶交互建模。</p>\n<h3 id=\"2-模型压缩\"><a href=\"#2-模型压缩\" class=\"headerlink\" title=\"2. 模型压缩\"></a>2. 模型压缩</h3><p>可以用 Tucker 分解对 CNN 卷积核或 Transformer 权重张量进行压缩。</p>\n<h3 id=\"3-多任务学习\"><a href=\"#3-多任务学习\" class=\"headerlink\" title=\"3. 多任务学习\"></a>3. 多任务学习</h3><p>可以用共享核心张量，同时用不同模式矩阵适配不同任务。</p>\n<hr>\n<h2 id=\"Tucker-分解的-PyTorch-简单实现\"><a href=\"#Tucker-分解的-PyTorch-简单实现\" class=\"headerlink\" title=\"Tucker 分解的 PyTorch 简单实现\"></a>Tucker 分解的 PyTorch 简单实现</h2><pre><code class=\"language-python\"># 简化版 Tucker 融合（v: image, q: text）\nv_proj = U_v(v)      # [B, r1]\nq_proj = U_q(q)      # [B, r2]\nouter = torch.einsum(&quot;bi,bj-&gt;bij&quot;, v_proj, q_proj)   # [B, r1, r2]\nfused = torch.einsum(&quot;bij,ijk-&gt;bk&quot;, outer, core)     # [B, r3]\nout = U_o(fused)     # [B, d_out]\n</code></pre>\n<hr>\n","categories":["深度学习","工具"],"tags":["矩阵变换,tucker"]},{"title":"Leetcode刷题记录","url":"/2025/08/15/2025-08-15-Leetcode/","content":"<p>Leetcode刷题记录</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Leetcode刷题\"><a href=\"#Leetcode刷题\" class=\"headerlink\" title=\"Leetcode刷题\"></a>Leetcode刷题</h1><h2 id=\"数组-字符串\"><a href=\"#数组-字符串\" class=\"headerlink\" title=\"数组&#x2F;字符串\"></a>数组&#x2F;字符串</h2><h3 id=\"1071-字符串的最大公因子\"><a href=\"#1071-字符串的最大公因子\" class=\"headerlink\" title=\"1071. 字符串的最大公因子\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmVhdGVzdC1jb21tb24tZGl2aXNvci1vZi1zdHJpbmdzLw==\">1071. 字符串的最大公因子</span></h3><p>对于字符串 <code>s</code> 和 <code>t</code>，只有在 <code>s = t + t + t + ... + t + t</code>（<code>t</code> 自身连接 1 次或多次）时，我们才认定 “<code>t</code> 能除尽 <code>s</code>”。</p>\n<p>给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回 <em>最长字符串 <code>x</code>，要求满足 <code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p>\n<p>:::info no-icon</p>\n<p>若两个字符串是由同一个字符串 X重复拼接而成，那么无论先拼哪个，结果应该相同。<br>如果 str1 + str2 !&#x3D; str2 +str1，说明不存在公共的重复因子，直接返回空串 “”。<br>如果两个字符串都是由同一个字符串 X 组成，那么 X 的长度必然是str1.size()和 str2.size() 的最大公约数。</p>\n<pre><code class=\"language-python\">class Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -&gt; str:\n        if not str1 + str2 == str2 + str1:\n            return &quot;&quot;\n        return str1[0:self.gcd(len(str1), len(str2))]\n    \n    def gcd(self, a,b):\n        if b == 0: return a\n        else: return gcd(b, a%b)\n    \n</code></pre>\n<p>作者：Random<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmVhdGVzdC1jb21tb24tZGl2aXNvci1vZi1zdHJpbmdzL3NvbHV0aW9ucy8zNzQ5ODkxL3NodS14dWUtenVpLWRhLWdvbmcteXVlLXNodS1ieS1jb2Rlci1yYW4tYTg4dS8=\">https://leetcode.cn/problems/greatest-common-divisor-of-strings/solutions/3749891/shu-xue-zui-da-gong-yue-shu-by-coder-ran-a88u/</span></p>\n<p>:::</p>\n<h3 id=\"605-种花问题\"><a href=\"#605-种花问题\" class=\"headerlink\" title=\"605. 种花问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tcGxhY2UtZmxvd2Vycy8=\">605. 种花问题</span></h3><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>\n<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p>\n<p>:::info no-icon</p>\n<p>从左到右遍历数组，能种花就立刻种花。</p>\n<p>如何判断能否种花？由于「花不能种植在相邻的地块上」，如果要在下标 i 处种花，需要满足 flowerbed[i−1],flowerbed[i],flowerbed[i+1] 均为 0。</p>\n<p>每种一朵花，就把 n 减一。如果最后 n≤0，则返回 true，否则返回 false。</p>\n<p>为了简化判断逻辑，可以在数组的开头和末尾各插入一个 0。</p>\n<pre><code class=\"language-python\">class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -&gt; bool:\n      nums = len(flowerbed)\n      new_flowerbed = [0] + flowerbed + [0]\n      for i in range(1,len(new_flowerbed)-1):\n        if new_flowerbed[i-1] == 0 and new_flowerbed[i+1] == 0 and new_flowerbed[i] == 0:\n          new_flowerbed[i] = 1\n          n -= 1\n      return n &lt;= 0\n</code></pre>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tcGxhY2UtZmxvd2Vycy9zb2x1dGlvbnMvMjQ2MzAxOC9iZW4tdGktenVpLWppYW4tZGFuLXhpZS1mYS1weXRob25qYXZhY2dvLTZhNmsv\">https://leetcode.cn/problems/can-place-flowers/solutions/2463018/ben-ti-zui-jian-dan-xie-fa-pythonjavacgo-6a6k/</span></p>\n<p>:::</p>\n<h3 id=\"334-递增的三元子序列\"><a href=\"#334-递增的三元子序列\" class=\"headerlink\" title=\"334. 递增的三元子序列\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbmNyZWFzaW5nLXRyaXBsZXQtc3Vic2VxdWVuY2Uv\">334. 递增的三元子序列</span></h3><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p>\n<p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>:::info no-icon</p>\n<p>;;;id1 巧解</p>\n<p>核心想法：遍历一遍数组，希望遍历到的这个数three，前面已经有一个比他小的数two，再前面有一个比two小的数one。<br>我们需要维护两个变量：one和two。代表递增子序列的第一个数和第二个数。<br>假设我们已经有了这两个数，那么three的大小有以下三种情况：</p>\n<ol>\n<li><p><strong>three大于two</strong>    此情况下：即找到了三元组，直接返回true。</p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/334-01.png\" class=\"\" width=\"300\">\n</li>\n<li><p><strong>three介于two和one之间</strong>     此情况下：应更新two，赋值为这个更小的值。这相当于帮我们扩大了three的可选择范围，当再次遇到一个比更新过的two大的数即可找到。</p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/334-02.png\" class=\"\" width=\"300\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/334-03.png\" class=\"\" width=\"300\">\n</li>\n<li><p><strong>three小于one</strong>     此情况下：应更新one，赋值为这个更小的值。而不需要动two。这相当于帮我们扩大了之后出现的two的可选择范围。进而扩大了之后出现的three的可选择范围。</p>\n</li>\n</ol>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/334-04.png\" class=\"\" width=\"300\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/334-05.png\" class=\"\" width=\"300\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/334-06.png\" class=\"\" width=\"300\">\n\n<p>需要注意的是，我们只更新one，原先的two不需要更改，因为子序列是从前往后的，只有当之后再出现比two小的数的时候再按照第二步那样更改。</p>\n<p>假设有如下示例：[2,5,1,6]，在遇到1之后更新了one，后遇到6，因为先判断是否大于two，由于6大于5，就直接返回true了。</p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/334-07.png\" class=\"\" width=\"300\">\n\n<p>注意：two附带隐含信息——这之前有个数比two小<br>所以此时找到的递增子序列不是one、two、three的1 5 6，而是old one、two、three的2 5 6。</p>\n<p>这里更新的one的意思是，为之后可能存在的更小的递增子序列打基础。<br>假设有如下示例：[2,5,1,2,6]，在遇到1之后更新了one，后遇到2，2介于1和5（two）之间，更新two为2，后遇到6，由于6大于2，返回true。<br>此时找到的递增子序列才是one、two、three的1 2 6</p>\n<p>最后考虑one、two的初值，容易想到设定为Integer.MAX_VALUE即可。</p>\n<p>作者：Xzz<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbmNyZWFzaW5nLXRyaXBsZXQtc3Vic2VxdWVuY2Uvc29sdXRpb25zLzUzNTcyNS9wb3UteGktYmVuLXpoaS15aS13ZW4tYmFuZy1uaS1rYW4tcWluZy10LTN5ZTIv\">https://leetcode.cn/problems/increasing-triplet-subsequence/solutions/535725/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/</span></p>\n<pre><code class=\"language-python\">class Solution:\n    def increasingTriplet(self, nums: List[int]) -&gt; bool:\n      one, two = inf, inf\n      for three in nums:\n        if three &gt; two : return True\n        elif three &lt;= one: one = three\n        else: two = three\n      return False\n</code></pre>\n<p>+++info 解析（GPT）</p>\n<p> <strong>1. 递增三元组的性质</strong></p>\n<p>假设数组中存在递增三元组 <code>a &lt; b &lt; c</code>，它们的顺序在数组中是 <strong>前后顺序</strong>，我们只关心：</p>\n<ul>\n<li>第一个数最小</li>\n<li>第二个数比第一个数大</li>\n<li>第三个数比第二个数大</li>\n</ul>\n<p><strong>关键点</strong>：我们不需要知道三元组具体位置，只需要保证存在。</p>\n<p> <strong>2. one 和 two 的作用</strong></p>\n<ul>\n<li><code>one</code>：当前找到的<strong>最小的候选第一个数</strong></li>\n<li><code>two</code>：在 <code>one</code> 之后，找到的<strong>最小的候选第二个数</strong></li>\n</ul>\n<p><strong>核心思想</strong>：</p>\n<ul>\n<li>我们并不是在找数组中所有可能的三元组，而是在<strong>维护最优候选序列</strong>。</li>\n<li>“最优候选”意味着 <strong>尽可能小的 one 和 two</strong>，这样可以最大化出现第三个数 three 的机会。</li>\n</ul>\n<p>换句话说：</p>\n<ol>\n<li>遍历到一个数 three：<ul>\n<li>如果 three &gt; two → 说明找到了一个合法三元组（不管前面 one&#x2F;two 是不是更新过的，都会形成合法的递增序列）。</li>\n</ul>\n</li>\n<li>如果 three &lt;&#x3D; one → 更新 one<ul>\n<li>因为这个更小的 one 可以为之后出现的 two 提供更多可能。</li>\n</ul>\n</li>\n<li>否则 → 更新 two<ul>\n<li>因为这个更小的 two 可以为之后出现的 three 提供更多可能。</li>\n</ul>\n</li>\n</ol>\n<p> <strong>3. 为什么不会漏掉任何情况</strong></p>\n<p>假设数组中有递增三元组 <code>x &lt; y &lt; z</code>，为什么算法一定能找到它？</p>\n<ul>\n<li>当我们遍历到 x：<ul>\n<li>one 会被更新为 ≤ x</li>\n</ul>\n</li>\n<li>当我们遍历到 y：<ul>\n<li>two 会被更新为 ≤ y</li>\n</ul>\n</li>\n<li>当我们遍历到 z：<ul>\n<li>如果 z &gt; two → 返回 True</li>\n</ul>\n</li>\n</ul>\n<p><strong>关键点</strong>：</p>\n<ul>\n<li>即使 one&#x2F;two 被后面更小的数更新过，<strong>old one&#x2F;two 仍然保留了前序信息</strong>，保证当前 three 大于某个二元组时，必然能形成递增三元组。</li>\n<li>换句话说，one&#x2F;two 是动态维护的 <strong>最小可能序列候选</strong>，任何真正存在的递增三元组都会被捕获。</li>\n</ul>\n<p>;;;</p>\n<p>;;;id1 常规</p>\n<p>常规解法</p>\n<p>;;;</p>\n<p>:::</p>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><h3 id=\"1208-尽可能使字符串相等\"><a href=\"#1208-尽可能使字符串相等\" class=\"headerlink\" title=\"1208. 尽可能使字符串相等\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZXQtZXF1YWwtc3Vic3RyaW5ncy13aXRoaW4tYnVkZ2V0Lw==\">1208. 尽可能使字符串相等</span></h3><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p>\n<p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p>\n<p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>\n<p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p>\n<p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3\n输出：3\n解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3\n输出：1\n解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。\n</code></pre>\n<p><strong>示例 3：</strong></p>\n<pre><code>输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0\n输出：1\n解释：a -&gt; a, cost = 0，字符串未发生变化，所以最大长度为 1。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>两个长度相等字符串的 s 和 t ，把 i 位置的 s[i] 转成 t[i] 的开销是两者 ASCII 码之差的绝对值。题目给出了允许的最大预算 maxCost ，求不超过预算的情况下能够转换的最长子串。</p>\n<p>比如，对于 s &#x3D; “abcd”, t &#x3D; “bcdf”, cost &#x3D; 3 而言，我们使用 costs[i] 表示从 s[i]  转成 t[i] 的开销，那么 costs &#x3D; [1, 1, 1, 2] 。由于 maxCost &#x3D; 3， 所以最多允许其前面三个字符进行转换。</p>\n<p>于是题目变成了：<strong>已知一个数组 costs ，求：和不超过 maxCost 时最长的子数组的长度</strong>。</p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/1208-01.png\" class=\"\" width=\"300\">\n\n<pre><code class=\"language-python\">class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -&gt; int:\n        n = len(s)\n        left, right = 0, 0\n        result = 0\n        cost = 0\n        while right &lt; n:\n            cost += abs(ord(s[right]) - ord(t[right]))\n            while cost &gt; maxCost:\n                cost -= abs(ord(s[left]) - ord(t[left]))\n                left += 1\n                \n            result = max(result, right - left + 1)\n            right += 1\n        return result\n</code></pre>\n<p>《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。</p>\n<p>+++info 滑动窗口问题模板</p>\n<p>我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXgtY29uc2VjdXRpdmUtb25lcy1paWkv\">1004. 最大连续1的个数 III</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQv\">424. 替换后的最长重复字符</span>）：</p>\n<pre><code class=\"language-python\">def findSubArray(nums):\n    N = len(nums) # 数组/字符串长度\n    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间\n    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数\n    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度\n    while right &lt; N: # 当右边的指针没有搜索到 数组/字符串 的结尾\n        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数\n        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间\n            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数\n            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反\n        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串\n        res = max(res, right - left + 1) # 需要更新结果\n        right += 1 # 移动右指针，去探索新的区间\n    return res\n</code></pre>\n<p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p>\n<p>模板的整体思想是：</p>\n<p>定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；<br>第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和&#x2F;计数；<br>第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和&#x2F;计数；<br>在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。<br>right 指针每次向右移动一步，开始探索新的区间。<br>模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。</p>\n<p>另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间[left, right]不符合题意 。对于本题而言，就是该区内的和 sums 超过了 maxCost 。</p>\n<p>+++</p>\n<p>作者：负雪明烛<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZXQtZXF1YWwtc3Vic3RyaW5ncy13aXRoaW4tYnVkZ2V0L3NvbHV0aW9ucy81OTIzNTQvZmVuLXhpYW5nLXpoZW4tY2FuZy1kZS1odWEtZG9uZy1jaHVhbmctay1lM3JkLw==\">https://leetcode.cn/problems/get-equal-substrings-within-budget/solutions/592354/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/</span><br>:::</p>\n<h3 id=\"424-替换后的最长重复字符\"><a href=\"#424-替换后的最长重复字符\" class=\"headerlink\" title=\"424. 替换后的最长重复字符\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQv\">424. 替换后的最长重复字符</span></h3><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p>\n<p>在执行上述操作后，返回 <em>包含相同字母的最长子字符串的长度。</em></p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;ABAB&quot;, k = 2\n输出：4\n解释：用两个&#39;A&#39;替换为两个&#39;B&#39;,反之亦然。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;AABABBA&quot;, k = 1\n输出：4\n解释：\n将中间的一个&#39;A&#39;替换为&#39;B&#39;,字符串变为 &quot;AABBBBA&quot;。\n子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。\n可能存在其他的方法来得到同样的结果。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>本题解根据常规的滑动窗口思路进行解题，不需要任何的技巧。<br>滑动窗口法是指通过Left以及Right指针来框定一个窗口，当在窗口内的字符串满足题目要求则记录下当前窗口长度并进一步扩张寻找更长的窗口，若不满足则进行窗口平移。<br>题目中给定的K值是让我们在选定有效窗口时的要求放宽了：</p>\n<p>当K&#x3D;0时，要求滑动窗口内部的所有字母都必须相同；<br>而当K&gt;0时，要求滑动窗口内最多替换K次使得所有字母都必须相同。这里有一个关键点，即我们将当前滑动窗口内出现次数最多的字母作为基准字母（Benchmark），那么其他不一样的字母(Others)都选择替换操作即可以最小的代价转换为全部相同的字母。<br>因此，我们首先通过一个数组(count)记录所有字母在当前窗口出现的次数，通过Max函数选择窗口内的基准字母，然后其他字母出现的次数为Sum(count)-Max(count)，通过与K进行比较，即可知道当前窗口是否有效，下一步是继续扩张还是位移。</p>\n<pre><code class=\"language-python\">class Solution:\n    def characterReplacement(self, s: str, k: int) -&gt; int:\n        count = [0 for _ in range(26)]  #记录当前窗口的字母出现次数\n        \n        left = 0    #滑动窗口左边界\n        right = 0   #滑动窗口右边界\n        retval = 0  #最长窗口长度\n        \n        while right &lt; len(s):\n            count[ord(s[right])-ord(&#39;A&#39;)] += 1  \n            benchmark = max(count)              #选择出现次数最多的字母为基准 \n            others = sum(count) - benchmark     #则其他字母需要通过替换操作来变为基准\n            if others &lt;= k:                     #通过与K进行比较来判断窗口是进行扩张？\n                right += 1\n                retval = max(retval, right-left)#记录当前有效窗口长度\n            else:                               #通过与K进行比较来判断窗口还是进行位移？\n                count[ord(s[left])-ord(&#39;A&#39;)] -= 1\n                left += 1\n                right += 1                      #这里注意：位移操作需要整个向右移，不仅仅只是left向右\n        \n        return retval                           #返回最长窗口长度\n        \n</code></pre>\n<p>作者：Derrick.S<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQvc29sdXRpb25zLzc5OTAxMy9odWEtZG9uZy1jaHVhbmcta291LWZhLWppYW4tZGFuLXlpLWRvbmctM3F3ZWwv\">https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/799013/hua-dong-chuang-kou-fa-jian-dan-yi-dong-3qwel/</span></p>\n<p>:::</p>\n<h2 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h2><h3 id=\"724-寻找数组的中心下标\"><a href=\"#724-寻找数组的中心下标\" class=\"headerlink\" title=\"724. 寻找数组的中心下标\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBpdm90LWluZGV4Lw==\">724. 寻找数组的中心下标</span></h3><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p>\n<p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>\n<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [1, 7, 3, 6, 5, 6]\n输出：3\n解释：\n中心下标是 3 。\n左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [1, 2, 3]\n输出：-1\n解释：\n数组中不存在满足此条件的中心下标。\n</code></pre>\n<p><strong>示例 3：</strong></p>\n<pre><code>输入：nums = [2, 1, -1]\n输出：0\n解释：\n中心下标是 0 。\n左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），\n右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>设 nums 的元素之和为 s。</p>\n<p>设中心下标为 i，其左侧元素和为 $leftS&#x3D;nums[0]+nums[1]+⋯+nums[i−1]$，那么右侧元素和为 $s−nums[i]−leftS$。</p>\n<p>由于左侧元素和等于右侧元素和，所以有</p>\n<p>$$leftS&#x3D;s−nums[i]−leftS$$<br>即</p>\n<p>$$2⋅leftS&#x3D;s−nums[i]$$<br>从左到右遍历数组，一边遍历，一边累加元素更新 leftS。每次累加前，检查是否满足上式，满足则返回 i。</p>\n<p>如果不存在这样的 i，返回 −1。</p>\n<pre><code class=\"language-python\">class Solution:\n    def pivotIndex(self, nums: List[int]) -&gt; int:\n        s = sum(nums)\n        sum_left = 0\n        for i, num in enumerate(nums):\n            if 2*sum_left == s - num:\n                return i\n            sum_left += num\n        return -1\n</code></pre>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBpdm90LWluZGV4L3NvbHV0aW9ucy8yODM0Njg3L2ppYW4tamkteGllLWZhLW8xLWUtd2FpLWtvbmctamlhbi1weXRob24tdHowcC8=\">https://leetcode.cn/problems/find-pivot-index/solutions/2834687/jian-ji-xie-fa-o1-e-wai-kong-jian-python-tz0p/</span></p>\n<p>:::</p>\n<h3 id=\"2352-相等行列对\"><a href=\"#2352-相等行列对\" class=\"headerlink\" title=\"2352. 相等行列对\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lcXVhbC1yb3ctYW5kLWNvbHVtbi1wYWlycy8=\">2352. 相等行列对</span></h3><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code> 列相等的行列对 <code>(Ri, Cj)</code> 的数目*。*</p>\n<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>\n<p>::: info no-icon</p>\n<p>用哈希表统计每行出现的次数，然后遍历列，累加哈希表中列出现的次数。</p>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lcXVhbC1yb3ctYW5kLWNvbHVtbi1wYWlycy9zb2x1dGlvbnMvMTY5NDA0Ny9oYS14aS1iaWFvLXB5dGhvbi1saWFuZy14aW5nLWJ5LWVuZGxlc3NjLWxqYWUv\">https://leetcode.cn/problems/equal-row-and-column-pairs/solutions/1694047/ha-xi-biao-python-liang-xing-by-endlessc-ljae/</span></p>\n<p>;;;id2 Demo 1</p>\n<pre><code class=\"language-python\">class Solution:\n    def equalPairs(self, grid: List[List[int]]) -&gt; int:\n        cnt = Counter(tuple(row) for row in grid)\n        return sum(cnt[col] for col in zip(*grid))\n</code></pre>\n<p>;;;</p>\n<p>;;;id2 Demo2</p>\n<pre><code class=\"language-python\">class Solution:\n    def equalPairs(self, grid: List[List[int]]) -&gt; int:\n        n = len(grid)\n        count = &#123;&#125;\n        result = 0\n        for i in range(n):\n            count[tuple(grid[i])] = count.get(tuple(grid[i]), 0) + 1\n        print(count)\n        for j in zip(*grid):\n            print(j)\n            result += count.get(j,0)\n            # print(grid[:][j], grid[j][:])\n        return result\n</code></pre>\n<p>;;;</p>\n<p>:::</p>\n<h2 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h2><h3 id=\"735-小行星碰撞\"><a href=\"#735-小行星碰撞\" class=\"headerlink\" title=\"735. 小行星碰撞\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3Rlcm9pZC1jb2xsaXNpb24v\">735. 小行星碰撞</span></h3><p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。</p>\n<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>\n<p>找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：asteroids = [5,10,-5]\n输出：[5,10]\n解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：asteroids = [8,-8]\n输出：[]\n解释：8 和 -8 碰撞后，两者都发生爆炸。\n</code></pre>\n<p><strong>示例 3：</strong></p>\n<pre><code>输入：asteroids = [10,2,-5]\n输出：[10]\n解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>这道栈的题目难点应该主要是在分析场景上了。<br>我们需要明确什么时候无脑入栈，什么时候需要判断，理解这两点就可以轻松解题了。<br>首先，循环每一个元素时，在什么情况下无脑入栈呢？</p>\n<p>栈为空<br>栈顶元素为负数(下一个为负数则一起向左，下一个为正数则分向两边)<br>当前元素为正数（栈顶为正一起向右，栈顶为负分向两边）<br>下来，我们需要看碰撞的场景又细分为什么情况：</p>\n<p>栈顶元素大于abs(当前元素)，当前元素被撞毁<br>栈顶元素等于abs(当前元素)，栈顶弹出和当前元素抵消<br>栈顶元素小于abs(当前元素)，栈顶弹出，并与新栈顶完成上述判断<br>最终返回栈即可。</p>\n<pre><code class=\"language-python\">class Solution:\n    def asteroidCollision(self, asteroids: List[int]) -&gt; List[int]:\n        stack, index = [], 0\n        while index &lt; len(asteroids):\n            ast = asteroids[index]\n            if ast &gt; 0 or len(stack)==0 or stack[-1]&lt;0: stack.append(ast)\n            elif stack[-1] &lt;= - ast:\n                if stack.pop(-1) &lt; - ast:\n                    continue\n            index += 1\n        return stack\n</code></pre>\n<p>作者：清风Python<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3Rlcm9pZC1jb2xsaXNpb24vc29sdXRpb25zLzk5NDEwMC83MzV4aW5nLXhpbmctcGVuZy16aHVhbmctamkteXUtemhhbi1xdS1mLXhwZDEv\">https://leetcode.cn/problems/asteroid-collision/solutions/994100/735xing-xing-peng-zhuang-ji-yu-zhan-qu-f-xpd1/</span></p>\n<p>:::</p>\n<h3 id=\"394-字符串解码\"><a href=\"#394-字符串解码\" class=\"headerlink\" title=\"394. 字符串解码\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nLw==\">394. 字符串解码</span></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>\n<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>\n<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>\n<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>\n<p>测试用例保证输出的长度不会超过 <code>105</code>。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;3[a]2[bc]&quot;\n输出：&quot;aaabcbc&quot;\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;3[a2[c]]&quot;\n输出：&quot;accaccacc&quot;\n</code></pre>\n<p><strong>示例 3：</strong></p>\n<pre><code>输入：s = &quot;2[abc]3[cd]ef&quot;\n输出：&quot;abcabccdcdcdef&quot;\n</code></pre>\n<p><strong>示例 4：</strong></p>\n<pre><code>输入：s = &quot;abc3[cd]xyz&quot;\n输出：&quot;abccdcdcdxyz&quot;\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<ul>\n<li><p>本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。</p>\n</li>\n<li><p>算法流程：</p>\n<ul>\n<li><p>构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</p>\n<ul>\n<li><p>当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</p>\n</li>\n<li><p>当 c 为字母时，在 res 尾部添加 c；</p>\n</li>\n<li><p>当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：<br>记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；<br>记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × […] 字符串。<br>进入到新 [ 后，res 和 multi 重新记录。</p>\n</li>\n<li><p>当 c 为 ] 时，stack 出栈，拼接字符串 res &#x3D; last_res + cur_multi * res，其中:</p>\n<ul>\n<li>last_res是上个 [ 到当前 [ 的字符串，例如 “3[a2[c]]” 中的 a；</li>\n<li>cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 “3[a2[c]]” 中的 2。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>返回字符串 res。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">class Solution:\n    def decodeString(self, s: str) -&gt; str:\n        result = &#39;&#39;\n        stack = []\n        res, num = &#39;&#39;, 0\n        for c in s:\n            if c == &#39;[&#39;:\n                stack.append((res, num))\n                res, num = &#39;&#39;, 0\n            elif c == &#39;]&#39;:\n                out_res, out_num = stack.pop()\n                res = out_res + out_num*res\n            elif &#39;0&#39;&lt;= c &lt;= &#39;9&#39;:\n                num = num*10 + int(c)\n            else:\n                res += c\n        return res\n</code></pre>\n<p>作者：Krahets<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL3NvbHV0aW9ucy8xOTQ0Ny9kZWNvZGUtc3RyaW5nLWZ1LXpodS16aGFuLWZhLWRpLWd1aS1mYS1ieS1qeWQv\">https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/</span></p>\n<p>:::</p>\n<h3 id=\"649-Dota2-参议院\"><a href=\"#649-Dota2-参议院\" class=\"headerlink\" title=\"649. Dota2 参议院\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kb3RhMi1zZW5hdGUv\">649. Dota2 参议院</span></h3><p>Dota2 的世界里有两个阵营：<code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）</p>\n<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一</strong> 项：</p>\n<ul>\n<li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 <strong>所有的权利</strong> 。</li>\n<li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li>\n</ul>\n<p>给你一个字符串 <code>senate</code> 代表每个参议员的阵营。字母 <code>&#39;R&#39;</code> 和 <code>&#39;D&#39;</code>分别代表了 <code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是 <code>n</code>。</p>\n<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>\n<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 <code>&quot;Radiant&quot;</code> 或 <code>&quot;Dire&quot;</code> 。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：senate = &quot;RD&quot;\n输出：&quot;Radiant&quot;\n解释：\n第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。\n这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。\n第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：senate = &quot;RDD&quot;\n输出：&quot;Dire&quot;\n解释：\n第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。\n这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。\n这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。\n因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>这道题模拟了一个游戏过程，最终当有权利投票的参议员都是 同一个阵营的 ，这个阵营即获胜。</p>\n<p>那么两个阵营的每个参议员为了获胜，当他拥有权力的时候，一定是会将自己之后首个对立阵营的参议员的权力禁止掉。【这就是每一位参议会为自己的政党做出最好的策略】。请注意：当之后没有对立阵营的参议员的时候，相当于将之前的参议员加到其之后。</p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/649-01.png\" class=\"\" width=\"500\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/649-02.png\" class=\"\" width=\"500\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/649-03.png\" class=\"\" width=\"500\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/649-04.png\" class=\"\" width=\"500\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/649-05.png\" class=\"\" width=\"500\">\n\n<pre><code class=\"language-python\">class Solution:\n    def predictPartyVictory(self, senate: str) -&gt; str:\n        radiants, dires = [], []\n        n = len(senate)\n        for i, se in enumerate(senate):\n            if se == &#39;R&#39;: radiants.append(i)\n            else: dires.append(i)\n        while radiants and dires:\n            if radiants[0] &lt; dires[0]:\n                dires.pop(0)\n                radiants.append(radiants.pop(0) + n)\n            else:\n                radiants.pop(0)\n                dires.append(dires.pop(0) + n)\n        return &quot;Radiant&quot; if radiants else &#39;Dire&#39;\n        \n</code></pre>\n<p>作者：画图小匠<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kb3RhMi1zZW5hdGUvc29sdXRpb25zLzI4NjIxMTUvamF2YXB5dGhvbjNjZHVpLWxpZS1tby1uaS1qaW4temhpLXpoaS1oby1sNHBiLw==\">https://leetcode.cn/problems/dota2-senate/solutions/2862115/javapython3cdui-lie-mo-ni-jin-zhi-zhi-ho-l4pb/</span></p>\n<p>:::</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>:::info no-icon</p>\n<ol>\n<li>找中间节点：快慢指针</li>\n</ol>\n<ul>\n<li><p>中间值左侧：需要加一个dummy节点。</p>\n<pre><code class=\"language-python\">dummy = ListNode(0, head)\nslow, fast = dummy, dummy\nwhile fast and fast.next:\n    fast = fast.next.next\n    if not fast: break\n    slow = slow.next\n</code></pre>\n</li>\n<li><p>中间值右侧：直接从head开始</p>\n<pre><code class=\"language-python\">slow, fast = head, head\nwhile fast and fast.next:\n    fast = fast.next.next\n    if not fast: break\n    slow = slow.next\n</code></pre>\n</li>\n</ul>\n<p>:::</p>\n<h3 id=\"2095-删除链表的中间节点\"><a href=\"#2095-删除链表的中间节点\" class=\"headerlink\" title=\"2095. 删除链表的中间节点\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtdGhlLW1pZGRsZS1ub2RlLW9mLWEtbGlua2VkLWxpc3Qv\">2095. 删除链表的中间节点</span></h3><p>给你一个链表的头节点 <code>head</code> 。<strong>删除</strong> 链表的 <strong>中间节点</strong> ，并返回修改后的链表的头节点 <code>head</code> 。</p>\n<p>长度为 <code>n</code> 链表的中间节点是从头数起第 <code>⌊n / 2⌋</code> 个节点（下标从 <strong>0</strong> 开始），其中 <code>⌊x⌋</code> 表示小于或等于 <code>x</code> 的最大整数。</p>\n<ul>\n<li>对于 <code>n</code> &#x3D; <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 和 <code>5</code> 的情况，中间节点的下标分别是 <code>0</code>、<code>1</code>、<code>1</code>、<code>2</code> 和 <code>2</code> 。</li>\n</ul>\n<p> :::info no-icon</p>\n<p>本题可遍历计数先得到 n，再遍历一次删除指定节点即可，这很简单。本篇讲的是快慢指针这种方法。</p>\n<p>我们令 fast 和 slow 这两个指针同时前进，fast 每次移动两格，slow 每次移动一格，在检测到 <code>fast.next == null</code> 或者 <code>fast.next.next == null</code> 时退出循环。</p>\n<p>引入一个哑巴节点 dummy 便于处理，考虑循环停止时的场景。<br>为方便考虑，本篇题解认为原链表下标从 1 开始，需要删除第 $⌊\\frac{n}{2}⌋+1$ 个节点。</p>\n<ul>\n<li>如果 <em>n</em> 为偶数，如下所示。设 <em>n</em>&#x3D;2<em>k</em>，fast 停在第 2<em>k</em> 个节点，slow 停在第 <em>k</em> 即 $⌊\\frac{n}{2}⌋$ 个节点。</li>\n</ul>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/2095-01.png\" class=\"\" width=\"300\">\n\n<ul>\n<li>如果 <em>n</em> 为奇数，如下所示，设 <em>n</em>&#x3D;2<em>k</em>+1。fast 停在第 2<em>k</em> 个节点，slow 停在第 <em>k</em> 即 $⌊\\frac{n}{2}⌋$ 个节点。</li>\n</ul>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/2095-02.png\" class=\"\" width=\"300\">\n\n<p>所以退出循环时 slow 一定停在 $⌊\\frac{n}{2}⌋$ 个节点，令 <code>slow.next = slow.next.next</code> 即删除了 $⌊\\frac{n}{2}⌋+1$ 个节点。</p>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        zero = ListNode(0, head)\n        slow, fast = zero, zero\n        while fast and fast.next:\n            fast = fast.next.next\n            if not fast: break\n            slow = slow.next\n        slow.next = slow.next.next\n        return zero.next\n\n        \n</code></pre>\n<p>作者：Shawxing精讲算法<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtdGhlLW1pZGRsZS1ub2RlLW9mLWEtbGlua2VkLWxpc3Qvc29sdXRpb25zLzI4NDQyMjkvamlhbi1taW5nLXlhbi1qaW4tZGUta3VhaS1tYW4temhpLXpoZW4tZi04NHN4Lw==\">https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solutions/2844229/jian-ming-yan-jin-de-kuai-man-zhi-zhen-f-84sx/</span></p>\n<p>:::</p>\n<h3 id=\"328-奇偶链表\"><a href=\"#328-奇偶链表\" class=\"headerlink\" title=\"328. 奇偶链表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC8=\">328. 奇偶链表</span></h3><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。</p>\n<p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推。</p>\n<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>\n<p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。</p>\n<p>:::info no-icon</p>\n<p>如果链表为空，则直接返回链表。</p>\n<p>对于原始链表，每个节点都是奇数节点或偶数节点。头节点是奇数节点，头节点的后一个节点是偶数节点，相邻节点的奇偶性不同。因此可以将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。</p>\n<p>原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead &#x3D; head.next，则 evenHead 是偶数链表的头节点。</p>\n<p>维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd &#x3D; head，even &#x3D; evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。</p>\n<ul>\n<li><p>更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next &#x3D; even.next，然后令 odd &#x3D; odd.next，此时 odd 变成 even 的后一个节点。</p>\n</li>\n<li><p>更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next &#x3D; odd.next，然后令 even &#x3D; even.next，此时 even 变成 odd 的后一个节点。</p>\n</li>\n</ul>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/328-01.png\" class=\"\" width=\"400\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/328-02.png\" class=\"\" width=\"400\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/328-03.png\" class=\"\" width=\"400\">\n\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/328-04.png\" class=\"\" width=\"400\">\n\n<p>在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。</p>\n<p>最后令 odd.next &#x3D; evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。</p>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def oddEvenList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        if not head: return head\n        even_head = head.next\n        odd, even = head, even_head\n        while even and even.next:\n            odd.next = even.next\n            odd = odd.next\n            even.next = odd.next\n            even = even.next\n        odd.next = even_head\n        return head\n</code></pre>\n<p>作者：力扣官方题解<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC9zb2x1dGlvbnMvNDgyNzM3L3FpLW91LWxpYW4tYmlhby1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=\">https://leetcode.cn/problems/odd-even-linked-list/solutions/482737/qi-ou-lian-biao-by-leetcode-solution/</span></p>\n<p>:::</p>\n<h3 id=\"2130-链表最大孪生和\"><a href=\"#2130-链表最大孪生和\" class=\"headerlink\" title=\"2130. 链表最大孪生和\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXR3aW4tc3VtLW9mLWEtbGlua2VkLWxpc3Qv\">2130. 链表最大孪生和</span></h3><p>在一个大小为 <code>n</code> 且 <code>n</code> 为 <strong>偶数</strong> 的链表中，对于 <code>0 &lt;= i &lt;= (n / 2) - 1</code> 的 <code>i</code> ，第 <code>i</code> 个节点（下标从 <strong>0</strong> 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。</p>\n<ul>\n<li>比方说，<code>n = 4</code> 那么节点 <code>0</code> 是节点 <code>3</code> 的孪生节点，节点 <code>1</code> 是节点 <code>2</code> 的孪生节点。这是长度为 <code>n = 4</code> 的链表中所有的孪生节点。</li>\n</ul>\n<p><strong>孪生和</strong> 定义为一个节点和它孪生节点两者值之和。</p>\n<p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 <strong>最大孪生和</strong> 。</p>\n<p> +++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/2130-01.png\" class=\"\" width=\"300\">\n\n<pre><code>输入：head = [5,4,2,1]\n输出：6\n解释：\n节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。\n链表中没有其他孪生节点。\n所以，链表的最大孪生和是 6 。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/2130-02.png\" class=\"\" width=\"300\">\n\n<pre><code>输入：head = [4,2,2,3]\n输出：7\n解释：\n链表中的孪生节点为：\n- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。\n- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。\n所以，最大孪生和为 max(7, 4) = 7 。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p><strong>核心思想：寻找链表中间值</strong></p>\n<p>以下两种方法的快慢指针有所不同，参见<a href=\"#%E9%93%BE%E8%A1%A8\">链表</a>。</p>\n<p>;;;id3 快慢指针+反转链表</p>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def pairSum(self, head: Optional[ListNode]) -&gt; int:\n        mid = self.middleNode(head)\n        head2 = self.reverseNode(mid)\n        result = -inf\n        while head2:\n            result = max(result, head.val + head2.val)\n            head = head.next\n            head2 = head2.next\n        return result\n\n    def reverseNode(self, head):\n        cur, pre = head, None\n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n        return pre\n        \n    def middleNode(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n        \n</code></pre>\n<p>;;;</p>\n<p>;;;id3 快慢指针+入栈</p>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def pairSum(self, head: Optional[ListNode]) -&gt; int:\n        dummy = ListNode(next=head)\n        slow, fast = dummy, dummy\n        stack = []\n        result = -inf\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            stack.append(slow.val)\n        print(slow.val)\n        while slow.next:\n            slow = slow.next\n            result = max(result, stack.pop(-1)+slow.val)\n        return result\n        \n</code></pre>\n<p>;;;</p>\n<p>:::</p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>:::info no-icon</p>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVVENHkxWTc2OS8/dmRfc291cmNlPTliMDUwMzdjNzdlYzk0MGRhZTNhZjhlNjk5NjllMGQ2\">看到递归就晕？带你理解递归的本质！【基础算法精讲 09】_哔哩哔哩_bilibili</span></li>\n</ol>\n<p>:::</p>\n<h3 id=\"437-路径总和-III（与560-和为-K-的子数组方法相似）\"><a href=\"#437-路径总和-III（与560-和为-K-的子数组方法相似）\" class=\"headerlink\" title=\"437. 路径总和 III（与560. 和为 K 的子数组方法相似）\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkv\">437. 路径总和 III</span>（与<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsv\">560. 和为 K 的子数组</span>方法相似）</h3><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>\n<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/437-01.png\" class=\"\" width=\"300\">\n\n<pre><code>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n输出：3\n解释：和等于 8 的路径有 3 条，如图所示。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>如果二叉树是一条链，本题就和 560. 和为 K 的子数组 完全一样了：统计有多少个非空连续子数组的元素和恰好等于 targetSum。所以你必须先弄明白 560 题（特殊情况），再来做本题（一般情况）。560 题的做法见 我的题解。</p>\n<p>这两题的联系如下：</p>\n<table>\n<thead>\n<tr>\n<th>560 题</th>\n<th>本题</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>连续子数组</td>\n<td>方向向下的路径</td>\n</tr>\n<tr>\n<td>前缀</td>\n<td>从根节点开始的路径</td>\n</tr>\n<tr>\n<td>做法：枚举子数组右端点，统计有多少个左端点</td>\n<td>做法：枚举路径的终点，统计有多少个起点<br/>我们要解决的问题是：DFS 遍历这棵树，遍历到节点 node 时，假设 node 是路径的终点，那么有多少个起点，满足起点到终点 node 的路径总和恰好等于 targetSum？</td>\n</tr>\n</tbody></table>\n<p>和 560 题一样的套路：一边遍历二叉树，一边用哈希表 cnt 统计前缀和（从根节点开始的路径和）的出现次数。设从根到终点 node 的路径和为 s，那么起点的个数就是 cnt[s−targetSum]，加入答案。对比 560 题，我们在枚举子数组的右端点（终点），统计有多少个左端点（起点），做法完全一致。</p>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; int:\n        ans = 0\n        hp = collections.defaultdict(int)\n        hp[0] = 1\n        def dfs(node, s):\n            if not node: return \n            nonlocal ans\n            s += node.val\n            ans += hp[s - targetSum]\n\n            hp[s] += 1\n            dfs(node.left, s)\n            dfs(node.right, s)\n            hp[s] -= 1\n        dfs(root, 0)\n        return ans\n</code></pre>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkvc29sdXRpb25zLzI3ODQ4NTYvenVvLWZhLWhlLTU2MC10aS1zaGkteWkteWFuZy1kZS1weXRob25qYS1mbXpvLw==\">https://leetcode.cn/problems/path-sum-iii/solutions/2784856/zuo-fa-he-560-ti-shi-yi-yang-de-pythonja-fmzo/</span></p>\n<p>:::</p>\n<h3 id=\"1372-二叉树中的最长交错路径\"><a href=\"#1372-二叉树中的最长交错路径\" class=\"headerlink\" title=\"1372. 二叉树中的最长交错路径\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXppZ3phZy1wYXRoLWluLWEtYmluYXJ5LXRyZWUv\">1372. 二叉树中的最长交错路径</span></h3><p>给你一棵以 <code>root</code> 为根的二叉树，二叉树中的交错路径定义如下：</p>\n<ul>\n<li>选择二叉树中 <strong>任意</strong> 节点和一个方向（左或者右）。</li>\n<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li>\n<li>改变前进方向：左变右或者右变左。</li>\n<li>重复第二步和第三步，直到你在树中无法继续移动。</li>\n</ul>\n<p>交错路径的长度定义为：<strong>访问过的节点数目 - 1</strong>（单个节点的路径长度为 0 ）。</p>\n<p>请你返回给定树中最长 <strong>交错路径</strong> 的长度。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/1372-01.png\" class=\"\" width=\"100\">\n\n<pre><code>输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\n输出：3\n解释：蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/1372-02.png\" class=\"\" width=\"100\">\n\n<pre><code>输入：root = [1,1,1,null,1,null,null,1,1,null,1]\n输出：4\n解释：蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>在 DFS 的过程中，每次我们都把当前点的 len 参数和答案 maxAns 打擂台，这样可以比出一个最大的。然后我们根据 dir 分类讨论。如果当前点应该向左且可以向左，那么就让他向左走一步，新的 len 是当前的 len 加一。如果的的点应该向左但是却没有左子树呢？很无奈那就只能向右了，这个时候 len 的值应该「重置」。</p>\n<p>思考：「重置」为什么是把 len 变成 1 而不是 0？ 因为当前的点下传到它的子节点的时候已经走了一条长度为 1 的边。那么为什么 main 函数中传入的 len 值是 0 而不是 1 呢？ 因为 main 函数中的 root 是没有父亲节点的，所以当前已经走过的路为 0。</p>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: Optional[TreeNode]) -&gt; int:\n        result = 0\n        def search(node, mode, l):\n            if not node:return \n            nonlocal result\n            result = max(result, l)\n            if mode == &#39;left&#39;: \n                search(node.right, &#39;right&#39;,l+1)\n                search(node.left, &#39;left&#39;, 1)\n            elif mode == &#39;right&#39;: \n                search(node.left, &#39;left&#39;, l+1)\n                search(node.right, &#39;right&#39;, 1)\n        search(root,&#39;left&#39;, 0)\n        search(root, &#39;right&#39;, 0)\n        return result\n</code></pre>\n<p>作者：力扣官方题解<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXppZ3phZy1wYXRoLWluLWEtYmluYXJ5LXRyZWUvc29sdXRpb25zLzE0NzQyNS9lci1jaGEtc2h1LXpob25nLWRlLXp1aS1jaGFuZy1qaWFvLWN1by1sdS1qaW5nLWItMi8=\">https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/solutions/147425/er-cha-shu-zhong-de-zui-chang-jiao-cuo-lu-jing-b-2/</span></p>\n<p>:::</p>\n<h3 id=\"236-二叉树的最近公共祖先\"><a href=\"#236-二叉树的最近公共祖先\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv\">236. 二叉树的最近公共祖先</span></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODgvODkxODgzND9mcj1hbGFkZGlu\">百度百科</span>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n<p> +++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/236-01.png\" class=\"\" width=\"200\">\n\n<pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/236-02.png\" class=\"\" width=\"200\">\n\n<pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVc0NHkxWjdBUi8/dmRfc291cmNlPTliMDUwMzdjNzdlYzk0MGRhZTNhZjhlNjk5NjllMGQ2\">二叉树的最近公共祖先【基础算法精讲 12】_哔哩哔哩_bilibili</span></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/236-03.png\" class=\"\" width=\"500\">\n\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:\n        if root == None or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if right and left: return root\n        return left or right\n        \n</code></pre>\n<p>:::</p>\n<h3 id=\"199-二叉树的右视图\"><a href=\"#199-二叉树的右视图\" class=\"headerlink\" title=\"199. 二叉树的右视图\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv\">199. 二叉树的右视图</span></h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入：</strong> root &#x3D; [1,2,3,null,5,null,4]</p>\n<p><strong>输出：</strong>[1,3,4]</p>\n<p><strong>解释：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/199-01.png\" class=\"\" width=\"300\">\n\n<p><strong>示例 2：</strong></p>\n<p><strong>输入：</strong> root &#x3D; [1,2,3,4,null,null,null,5]</p>\n<p><strong>输出：</strong>[1,3,4,5]</p>\n<p><strong>解释：</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/199-02.png\" class=\"\" width=\"300\">\n\n<p><strong>示例 3：</strong></p>\n<p><strong>输入：</strong> root &#x3D; [1,null,3]</p>\n<p><strong>输出：</strong>[1,3]</p>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>;;;id4 深度优先算法</p>\n<p><strong>视频讲解</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMThNNDExejdiYi8=\">【基础算法精讲 10】</span></p>\n<p><strong>思路</strong>：先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。</p>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:\n        result = []\n        def dfs(root, depth):\n            if not root: return \n            if depth == len(result):\n                result.append(root.val)\n            dfs(root.right, depth + 1)\n            dfs(root.left, depth + 1)\n        dfs(root, 0)\n        return result\n</code></pre>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcvc29sdXRpb25zLzIwMTUwNjEvcnUtaGUtbGluZy1odW8teXVuLXlvbmctZGktZ3VpLWxhaS1rYW4tcy1yMW5jLw==\">https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/</span></p>\n<p>;;;</p>\n<p>;;;id4 层序遍历</p>\n<p><strong>思路</strong>：将每层的元素加入队列，从右到左依序遍历每层。</p>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:\n        if not root: return []\n        result = []\n        que = [root]\n        while len(que) &gt; 0:\n            result.append(que[0].val)\n            for _ in range(len(que)):\n                node = que.pop(0)\n                if node.right: que.append(node.right)\n                if node.left: que.append(node.left)\n        return result\n</code></pre>\n<p>;;;</p>\n<p>:::</p>\n<h3 id=\"450-删除二叉搜索树中的节点\"><a href=\"#450-删除二叉搜索树中的节点\" class=\"headerlink\" title=\"450. 删除二叉搜索树中的节点\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC8=\">450. 删除二叉搜索树中的节点</span></h3><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<p>一般来说，删除节点可分为两个步骤：</p>\n<ol>\n<li>首先找到需要删除的节点；</li>\n<li>如果找到了，删除它。</li>\n</ol>\n<p>+++info 示例</p>\n<p><strong>示例 1:</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/450-01.png\" class=\"\" width=\"300\">\n\n<pre><code>输入：root = [5,3,6,2,4,null,7], key = 3\n输出：[5,4,6,2,null,null,7]\n解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n另一个正确答案是 [5,2,6,null,4,null,7]。\n</code></pre>\n<p><strong>示例 2:</strong></p>\n<img data-src=\"/2025/08/15/2025-08-15-Leetcode/450-02.png\" class=\"\" width=\"300\">\n\n<pre><code>输入: root = [5,3,6,2,4,null,7], key = 0\n输出: [5,3,6,2,4,null,7]\n解释: 二叉树不包含值为 0 的节点\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>[视频解析](<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVJ1NHkxQzcyZC8/c3BtX2lkX2Zyb209MzMzLjMzNy5zZWFyY2gtY2FyZC5hbGwuY2xpY2smdmRfc291cmNlPTliMDUwMzdjNzdlYzk0MGRhZTNhZjhlNjk5NjllMGQ2\">【LeetCode75】第四十二题 删除二叉搜索树中的节点_哔哩哔哩_bilibili</span>)</p>\n<p>二叉搜索树的题目往往可以用递归来解决。此题要求删除二叉树的节点，函数 deleteNode 的输入是二叉树的根节点 root 和一个整数 key，输出是删除值为 key 的节点后的二叉树，并保持二叉树的有序性。可以按照以下情况分类讨论：</p>\n<ul>\n<li>root 为空，代表未搜索到值为 key 的节点，返回空。</li>\n<li>root.val&gt;key，表示值为 key 的节点可能存在于 root 的左子树中，需要递归地在 root.left 调用 deleteNode，并返回 root。</li>\n<li>root.val&lt;key，表示值为 key 的节点可能存在于 root 的右子树中，需要递归地在 root.right 调用 deleteNode，并返回 root。</li>\n<li>root.val&#x3D;key，root 即为要删除的节点。此时要做的是删除 root，并将它的子树合并成一棵子树，保持有序性，并返回根节点。根据 root 的子树情况分成以下情况讨论：<ul>\n<li>root 为叶子节点，没有子树。此时可以直接将它删除，即返回空。</li>\n<li>root 只有左子树，没有右子树。此时可以将它的左子树作为新的子树，返回它的左子节点。</li>\n<li>root 只有右子树，没有左子树。此时可以将它的右子树作为新的子树，返回它的右子节点。</li>\n<li>root 有左右子树。此时可以把右子树接到左子树中（通过循环找到左子树的最右叶子，插在这个叶子上作为右子树，因为root的右子树必然比左子树的任意值大）。</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -&gt; Optional[TreeNode]:\n        if not root: return \n        if root.val == key:\n            if not root.left and not root.right: return \n            elif not root.left: return root.right\n            elif not root.right: return root.left\n            else:\n                node = root.left\n                while node.right: node = node.right\n                node.right = root.right\n                root = root.left\n        elif root.val &gt; key: root.left = self.deleteNode(root.left, key)\n        elif root.val &lt; key: root.right = self.deleteNode(root.right, key)\n        return root\n</code></pre>\n<p>作者：力扣官方题解<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC9zb2x1dGlvbnMvMTUyOTcwMC9zaGFuLWNodS1lci1jaGEtc291LXN1by1zaHUtemhvbmctZGUtamllLW42dm8v\">https://leetcode.cn/problems/delete-node-in-a-bst/solutions/1529700/shan-chu-er-cha-sou-suo-shu-zhong-de-jie-n6vo/</span></p>\n<p>:::</p>\n","categories":["技能工具"]},{"title":"Office卸载","url":"/2025/06/25/2025-06-25-Office%E5%8D%B8%E8%BD%BD/","content":"<p>其他工具——Office卸载</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Office卸载\"><a href=\"#Office卸载\" class=\"headerlink\" title=\"Office卸载\"></a>Office卸载</h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>起因是想下载Visio套件，因此需要通过官方下载整体Office包，但是下载后一直显示还是原来的Office教育版。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h4 id=\"通过控制面板卸载已安装的旧版Office。\"><a href=\"#通过控制面板卸载已安装的旧版Office。\" class=\"headerlink\" title=\"通过控制面板卸载已安装的旧版Office。\"></a>通过控制面板卸载已安装的旧版Office。</h4><p>:::info no-icon</p>\n<p>Win + R，输入“control”，回车，在卸载程序中找到Office软件，右键卸载。</p>\n<p>:::</p>\n<h4 id=\"清理注册表文件\"><a href=\"#清理注册表文件\" class=\"headerlink\" title=\"清理注册表文件\"></a>清理注册表文件</h4><ul>\n<li>下载Office助手——[“Office Tool Plus”](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9vdHAubGFuZGlhbi52aXAvemgtY24v\">Office Tool Plus | 一键部署 Office</span>)</li>\n<li>在工具箱内找到”移除Office“选择移除。</li>\n<li>执行后到注册表下检测。</li>\n</ul>\n<p>Win + R，输入“regedit”，回车。</p>\n<p>检查以下两项是否存在，若存在可以手动删除。</p>\n<p>:::info no-icon</p>\n<p>如果提示没有删除权限，请在对应的键上，右键“权限”→选中当前登录账号，高级→勾选左下角“使用可从此对象继承的权限项目替换所有子对象的权限项目”→应用，确定。然后尝试再次删除就可以删除掉了。</p>\n<p>:::</p>\n","categories":["其他工具"]},{"title":"Leetcode刷题记录","url":"/2025/08/15/Z2025-08-15-Leetcode%20-%20%E5%89%AF%E6%9C%AC/","content":"<p>Leetcode刷题记录</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Leetcode刷题\"><a href=\"#Leetcode刷题\" class=\"headerlink\" title=\"Leetcode刷题\"></a>Leetcode刷题</h1><h2 id=\"数组-字符串\"><a href=\"#数组-字符串\" class=\"headerlink\" title=\"数组&#x2F;字符串\"></a>数组&#x2F;字符串</h2><h3 id=\"1071-字符串的最大公因子\"><a href=\"#1071-字符串的最大公因子\" class=\"headerlink\" title=\"1071. 字符串的最大公因子\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmVhdGVzdC1jb21tb24tZGl2aXNvci1vZi1zdHJpbmdzLw==\">1071. 字符串的最大公因子</span></h3><p>对于字符串 <code>s</code> 和 <code>t</code>，只有在 <code>s = t + t + t + ... + t + t</code>（<code>t</code> 自身连接 1 次或多次）时，我们才认定 “<code>t</code> 能除尽 <code>s</code>”。</p>\n<p>给定两个字符串 <code>str1</code> 和 <code>str2</code> 。返回 <em>最长字符串 <code>x</code>，要求满足 <code>x</code> 能除尽 <code>str1</code> 且 <code>x</code> 能除尽 <code>str2</code></em> 。</p>\n<p>:::info no-icon</p>\n<p>若两个字符串是由同一个字符串 X重复拼接而成，那么无论先拼哪个，结果应该相同。<br>如果 str1 + str2 !&#x3D; str2 +str1，说明不存在公共的重复因子，直接返回空串 “”。<br>如果两个字符串都是由同一个字符串 X 组成，那么 X 的长度必然是str1.size()和 str2.size() 的最大公约数。</p>\n<pre><code class=\"language-python\">class Solution:\n    def gcdOfStrings(self, str1: str, str2: str) -&gt; str:\n        if not str1 + str2 == str2 + str1:\n            return &quot;&quot;\n        return str1[0:self.gcd(len(str1), len(str2))]\n    \n    def gcd(self, a,b):\n        if b == 0: return a\n        else: return gcd(b, a%b)\n    \n</code></pre>\n<p>作者：Random<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncmVhdGVzdC1jb21tb24tZGl2aXNvci1vZi1zdHJpbmdzL3NvbHV0aW9ucy8zNzQ5ODkxL3NodS14dWUtenVpLWRhLWdvbmcteXVlLXNodS1ieS1jb2Rlci1yYW4tYTg4dS8=\">https://leetcode.cn/problems/greatest-common-divisor-of-strings/solutions/3749891/shu-xue-zui-da-gong-yue-shu-by-coder-ran-a88u/</span></p>\n<p>:::</p>\n<h3 id=\"605-种花问题\"><a href=\"#605-种花问题\" class=\"headerlink\" title=\"605. 种花问题\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tcGxhY2UtZmxvd2Vycy8=\">605. 种花问题</span></h3><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>\n<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code> 。</p>\n<p>:::info no-icon</p>\n<p>从左到右遍历数组，能种花就立刻种花。</p>\n<p>如何判断能否种花？由于「花不能种植在相邻的地块上」，如果要在下标 i 处种花，需要满足 flowerbed[i−1],flowerbed[i],flowerbed[i+1] 均为 0。</p>\n<p>每种一朵花，就把 n 减一。如果最后 n≤0，则返回 true，否则返回 false。</p>\n<p>为了简化判断逻辑，可以在数组的开头和末尾各插入一个 0。</p>\n<pre><code class=\"language-python\">class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -&gt; bool:\n      nums = len(flowerbed)\n      new_flowerbed = [0] + flowerbed + [0]\n      for i in range(1,len(new_flowerbed)-1):\n        if new_flowerbed[i-1] == 0 and new_flowerbed[i+1] == 0 and new_flowerbed[i] == 0:\n          new_flowerbed[i] = 1\n          n -= 1\n      return n &lt;= 0\n</code></pre>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tcGxhY2UtZmxvd2Vycy9zb2x1dGlvbnMvMjQ2MzAxOC9iZW4tdGktenVpLWppYW4tZGFuLXhpZS1mYS1weXRob25qYXZhY2dvLTZhNmsv\">https://leetcode.cn/problems/can-place-flowers/solutions/2463018/ben-ti-zui-jian-dan-xie-fa-pythonjavacgo-6a6k/</span></p>\n<p>:::</p>\n<h3 id=\"334-递增的三元子序列\"><a href=\"#334-递增的三元子序列\" class=\"headerlink\" title=\"334. 递增的三元子序列\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbmNyZWFzaW5nLXRyaXBsZXQtc3Vic2VxdWVuY2Uv\">334. 递增的三元子序列</span></h3><p>给你一个整数数组 <code>nums</code> ，判断这个数组中是否存在长度为 <code>3</code> 的递增子序列。</p>\n<p>如果存在这样的三元组下标 <code>(i, j, k)</code> 且满足 <code>i &lt; j &lt; k</code> ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>:::info no-icon</p>\n<p>;;;id1 巧解</p>\n<p>核心想法：遍历一遍数组，希望遍历到的这个数three，前面已经有一个比他小的数two，再前面有一个比two小的数one。<br>我们需要维护两个变量：one和two。代表递增子序列的第一个数和第二个数。<br>假设我们已经有了这两个数，那么three的大小有以下三种情况：</p>\n<ol>\n<li><p><strong>three大于two</strong>    此情况下：即找到了三元组，直接返回true。</p>\n\n</li>\n<li><p><strong>three介于two和one之间</strong>     此情况下：应更新two，赋值为这个更小的值。这相当于帮我们扩大了three的可选择范围，当再次遇到一个比更新过的two大的数即可找到。</p>\n\n\n\n</li>\n<li><p><strong>three小于one</strong>     此情况下：应更新one，赋值为这个更小的值。而不需要动two。这相当于帮我们扩大了之后出现的two的可选择范围。进而扩大了之后出现的three的可选择范围。</p>\n</li>\n</ol>\n\n\n\n\n<p><img data-src=\"C:\\Users\\HNing\\Dropbox\\PC\\Desktop\\2025-08-15-Leetcode\\334-06.png\" alt=\"300\"></p>\n<p>需要注意的是，我们只更新one，原先的two不需要更改，因为子序列是从前往后的，只有当之后再出现比two小的数的时候再按照第二步那样更改。</p>\n<p>假设有如下示例：[2,5,1,6]，在遇到1之后更新了one，后遇到6，因为先判断是否大于two，由于6大于5，就直接返回true了。</p>\n\n\n<p>注意：two附带隐含信息——这之前有个数比two小<br>所以此时找到的递增子序列不是one、two、three的1 5 6，而是old one、two、three的2 5 6。</p>\n<p>这里更新的one的意思是，为之后可能存在的更小的递增子序列打基础。<br>假设有如下示例：[2,5,1,2,6]，在遇到1之后更新了one，后遇到2，2介于1和5（two）之间，更新two为2，后遇到6，由于6大于2，返回true。<br>此时找到的递增子序列才是one、two、three的1 2 6</p>\n<p>最后考虑one、two的初值，容易想到设定为Integer.MAX_VALUE即可。</p>\n<p>作者：Xzz<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbmNyZWFzaW5nLXRyaXBsZXQtc3Vic2VxdWVuY2Uvc29sdXRpb25zLzUzNTcyNS9wb3UteGktYmVuLXpoaS15aS13ZW4tYmFuZy1uaS1rYW4tcWluZy10LTN5ZTIv\">https://leetcode.cn/problems/increasing-triplet-subsequence/solutions/535725/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/</span></p>\n<pre><code class=\"language-python\">class Solution:\n    def increasingTriplet(self, nums: List[int]) -&gt; bool:\n      one, two = inf, inf\n      for three in nums:\n        if three &gt; two : return True\n        elif three &lt;= one: one = three\n        else: two = three\n      return False\n</code></pre>\n<p>+++info 解析（GPT）</p>\n<p> <strong>1. 递增三元组的性质</strong></p>\n<p>假设数组中存在递增三元组 <code>a &lt; b &lt; c</code>，它们的顺序在数组中是 <strong>前后顺序</strong>，我们只关心：</p>\n<ul>\n<li>第一个数最小</li>\n<li>第二个数比第一个数大</li>\n<li>第三个数比第二个数大</li>\n</ul>\n<p><strong>关键点</strong>：我们不需要知道三元组具体位置，只需要保证存在。</p>\n<p> <strong>2. one 和 two 的作用</strong></p>\n<ul>\n<li><code>one</code>：当前找到的<strong>最小的候选第一个数</strong></li>\n<li><code>two</code>：在 <code>one</code> 之后，找到的<strong>最小的候选第二个数</strong></li>\n</ul>\n<p><strong>核心思想</strong>：</p>\n<ul>\n<li>我们并不是在找数组中所有可能的三元组，而是在<strong>维护最优候选序列</strong>。</li>\n<li>“最优候选”意味着 <strong>尽可能小的 one 和 two</strong>，这样可以最大化出现第三个数 three 的机会。</li>\n</ul>\n<p>换句话说：</p>\n<ol>\n<li>遍历到一个数 three：<ul>\n<li>如果 three &gt; two → 说明找到了一个合法三元组（不管前面 one&#x2F;two 是不是更新过的，都会形成合法的递增序列）。</li>\n</ul>\n</li>\n<li>如果 three &lt;&#x3D; one → 更新 one<ul>\n<li>因为这个更小的 one 可以为之后出现的 two 提供更多可能。</li>\n</ul>\n</li>\n<li>否则 → 更新 two<ul>\n<li>因为这个更小的 two 可以为之后出现的 three 提供更多可能。</li>\n</ul>\n</li>\n</ol>\n<p> <strong>3. 为什么不会漏掉任何情况</strong></p>\n<p>假设数组中有递增三元组 <code>x &lt; y &lt; z</code>，为什么算法一定能找到它？</p>\n<ul>\n<li>当我们遍历到 x：<ul>\n<li>one 会被更新为 ≤ x</li>\n</ul>\n</li>\n<li>当我们遍历到 y：<ul>\n<li>two 会被更新为 ≤ y</li>\n</ul>\n</li>\n<li>当我们遍历到 z：<ul>\n<li>如果 z &gt; two → 返回 True</li>\n</ul>\n</li>\n</ul>\n<p><strong>关键点</strong>：</p>\n<ul>\n<li>即使 one&#x2F;two 被后面更小的数更新过，<strong>old one&#x2F;two 仍然保留了前序信息</strong>，保证当前 three 大于某个二元组时，必然能形成递增三元组。</li>\n<li>换句话说，one&#x2F;two 是动态维护的 <strong>最小可能序列候选</strong>，任何真正存在的递增三元组都会被捕获。</li>\n</ul>\n<p>;;;</p>\n<p>;;;id1 常规</p>\n<p>常规解法</p>\n<p>;;;</p>\n<p>:::</p>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><h3 id=\"1208-尽可能使字符串相等\"><a href=\"#1208-尽可能使字符串相等\" class=\"headerlink\" title=\"1208. 尽可能使字符串相等\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZXQtZXF1YWwtc3Vic3RyaW5ncy13aXRoaW4tYnVkZ2V0Lw==\">1208. 尽可能使字符串相等</span></h3><p>给你两个长度相同的字符串，<code>s</code> 和 <code>t</code>。</p>\n<p>将 <code>s</code> 中的第 <code>i</code> 个字符变到 <code>t</code> 中的第 <code>i</code> 个字符需要 <code>|s[i] - t[i]|</code> 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。</p>\n<p>用于变更字符串的最大预算是 <code>maxCost</code>。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。</p>\n<p>如果你可以将 <code>s</code> 的子字符串转化为它在 <code>t</code> 中对应的子字符串，则返回可以转化的最大长度。</p>\n<p>如果 <code>s</code> 中没有子字符串可以转化成 <code>t</code> 中对应的子字符串，则返回 <code>0</code>。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, maxCost = 3\n输出：3\n解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, maxCost = 3\n输出：1\n解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。\n</code></pre>\n<p><strong>示例 3：</strong></p>\n<pre><code>输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, maxCost = 0\n输出：1\n解释：a -&gt; a, cost = 0，字符串未发生变化，所以最大长度为 1。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>两个长度相等字符串的 s 和 t ，把 i 位置的 s[i] 转成 t[i] 的开销是两者 ASCII 码之差的绝对值。题目给出了允许的最大预算 maxCost ，求不超过预算的情况下能够转换的最长子串。</p>\n<p>比如，对于 s &#x3D; “abcd”, t &#x3D; “bcdf”, cost &#x3D; 3 而言，我们使用 costs[i] 表示从 s[i]  转成 t[i] 的开销，那么 costs &#x3D; [1, 1, 1, 2] 。由于 maxCost &#x3D; 3， 所以最多允许其前面三个字符进行转换。</p>\n<p>于是题目变成了：<strong>已知一个数组 costs ，求：和不超过 maxCost 时最长的子数组的长度</strong>。</p>\n\n\n<pre><code class=\"language-python\">class Solution:\n    def equalSubstring(self, s: str, t: str, maxCost: int) -&gt; int:\n        n = len(s)\n        left, right = 0, 0\n        result = 0\n        cost = 0\n        while right &lt; n:\n            cost += abs(ord(s[right]) - ord(t[right]))\n            while cost &gt; maxCost:\n                cost -= abs(ord(s[left]) - ord(t[left]))\n                left += 1\n                \n            result = max(result, right - left + 1)\n            right += 1\n        return result\n</code></pre>\n<p>《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。</p>\n<p>+++info 滑动窗口问题模板</p>\n<p>我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXgtY29uc2VjdXRpdmUtb25lcy1paWkv\">1004. 最大连续1的个数 III</span>，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQv\">424. 替换后的最长重复字符</span>）：</p>\n<pre><code class=\"language-python\">def findSubArray(nums):\n    N = len(nums) # 数组/字符串长度\n    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间\n    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数\n    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度\n    while right &lt; N: # 当右边的指针没有搜索到 数组/字符串 的结尾\n        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数\n        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间\n            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数\n            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反\n        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串\n        res = max(res, right - left + 1) # 需要更新结果\n        right += 1 # 移动右指针，去探索新的区间\n    return res\n</code></pre>\n<p>滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。</p>\n<p>模板的整体思想是：</p>\n<p>定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；<br>第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和&#x2F;计数；<br>第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和&#x2F;计数；<br>在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。<br>right 指针每次向右移动一步，开始探索新的区间。<br>模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。</p>\n<p>另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间[left, right]不符合题意 。对于本题而言，就是该区内的和 sums 超过了 maxCost 。</p>\n<p>+++</p>\n<p>作者：负雪明烛<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nZXQtZXF1YWwtc3Vic3RyaW5ncy13aXRoaW4tYnVkZ2V0L3NvbHV0aW9ucy81OTIzNTQvZmVuLXhpYW5nLXpoZW4tY2FuZy1kZS1odWEtZG9uZy1jaHVhbmctay1lM3JkLw==\">https://leetcode.cn/problems/get-equal-substrings-within-budget/solutions/592354/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/</span><br>:::</p>\n<h3 id=\"424-替换后的最长重复字符\"><a href=\"#424-替换后的最长重复字符\" class=\"headerlink\" title=\"424. 替换后的最长重复字符\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQv\">424. 替换后的最长重复字符</span></h3><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p>\n<p>在执行上述操作后，返回 <em>包含相同字母的最长子字符串的长度。</em></p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;ABAB&quot;, k = 2\n输出：4\n解释：用两个&#39;A&#39;替换为两个&#39;B&#39;,反之亦然。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;AABABBA&quot;, k = 1\n输出：4\n解释：\n将中间的一个&#39;A&#39;替换为&#39;B&#39;,字符串变为 &quot;AABBBBA&quot;。\n子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。\n可能存在其他的方法来得到同样的结果。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>本题解根据常规的滑动窗口思路进行解题，不需要任何的技巧。<br>滑动窗口法是指通过Left以及Right指针来框定一个窗口，当在窗口内的字符串满足题目要求则记录下当前窗口长度并进一步扩张寻找更长的窗口，若不满足则进行窗口平移。<br>题目中给定的K值是让我们在选定有效窗口时的要求放宽了：</p>\n<p>当K&#x3D;0时，要求滑动窗口内部的所有字母都必须相同；<br>而当K&gt;0时，要求滑动窗口内最多替换K次使得所有字母都必须相同。这里有一个关键点，即我们将当前滑动窗口内出现次数最多的字母作为基准字母（Benchmark），那么其他不一样的字母(Others)都选择替换操作即可以最小的代价转换为全部相同的字母。<br>因此，我们首先通过一个数组(count)记录所有字母在当前窗口出现的次数，通过Max函数选择窗口内的基准字母，然后其他字母出现的次数为Sum(count)-Max(count)，通过与K进行比较，即可知道当前窗口是否有效，下一步是继续扩张还是位移。</p>\n<pre><code class=\"language-python\">class Solution:\n    def characterReplacement(self, s: str, k: int) -&gt; int:\n        count = [0 for _ in range(26)]  #记录当前窗口的字母出现次数\n        \n        left = 0    #滑动窗口左边界\n        right = 0   #滑动窗口右边界\n        retval = 0  #最长窗口长度\n        \n        while right &lt; len(s):\n            count[ord(s[right])-ord(&#39;A&#39;)] += 1  \n            benchmark = max(count)              #选择出现次数最多的字母为基准 \n            others = sum(count) - benchmark     #则其他字母需要通过替换操作来变为基准\n            if others &lt;= k:                     #通过与K进行比较来判断窗口是进行扩张？\n                right += 1\n                retval = max(retval, right-left)#记录当前有效窗口长度\n            else:                               #通过与K进行比较来判断窗口还是进行位移？\n                count[ord(s[left])-ord(&#39;A&#39;)] -= 1\n                left += 1\n                right += 1                      #这里注意：位移操作需要整个向右移，不仅仅只是left向右\n        \n        return retval                           #返回最长窗口长度\n        \n</code></pre>\n<p>作者：Derrick.S<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXJlcGVhdGluZy1jaGFyYWN0ZXItcmVwbGFjZW1lbnQvc29sdXRpb25zLzc5OTAxMy9odWEtZG9uZy1jaHVhbmcta291LWZhLWppYW4tZGFuLXlpLWRvbmctM3F3ZWwv\">https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/799013/hua-dong-chuang-kou-fa-jian-dan-yi-dong-3qwel/</span></p>\n<p>:::</p>\n<h2 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h2><h3 id=\"724-寻找数组的中心下标\"><a href=\"#724-寻找数组的中心下标\" class=\"headerlink\" title=\"724. 寻找数组的中心下标\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBpdm90LWluZGV4Lw==\">724. 寻找数组的中心下标</span></h3><p>给你一个整数数组 <code>nums</code> ，请计算数组的 <strong>中心下标</strong> 。</p>\n<p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n<p>如果中心下标位于数组最左端，那么左侧数之和视为 <code>0</code> ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>\n<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 <code>-1</code> 。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：nums = [1, 7, 3, 6, 5, 6]\n输出：3\n解释：\n中心下标是 3 。\n左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：nums = [1, 2, 3]\n输出：-1\n解释：\n数组中不存在满足此条件的中心下标。\n</code></pre>\n<p><strong>示例 3：</strong></p>\n<pre><code>输入：nums = [2, 1, -1]\n输出：0\n解释：\n中心下标是 0 。\n左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），\n右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>设 nums 的元素之和为 s。</p>\n<p>设中心下标为 i，其左侧元素和为 $leftS&#x3D;nums[0]+nums[1]+⋯+nums[i−1]$，那么右侧元素和为 $s−nums[i]−leftS$。</p>\n<p>由于左侧元素和等于右侧元素和，所以有</p>\n<p>$$leftS&#x3D;s−nums[i]−leftS$$<br>即</p>\n<p>$$2⋅leftS&#x3D;s−nums[i]$$<br>从左到右遍历数组，一边遍历，一边累加元素更新 leftS。每次累加前，检查是否满足上式，满足则返回 i。</p>\n<p>如果不存在这样的 i，返回 −1。</p>\n<pre><code class=\"language-python\">class Solution:\n    def pivotIndex(self, nums: List[int]) -&gt; int:\n        s = sum(nums)\n        sum_left = 0\n        for i, num in enumerate(nums):\n            if 2*sum_left == s - num:\n                return i\n            sum_left += num\n        return -1\n</code></pre>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXBpdm90LWluZGV4L3NvbHV0aW9ucy8yODM0Njg3L2ppYW4tamkteGllLWZhLW8xLWUtd2FpLWtvbmctamlhbi1weXRob24tdHowcC8=\">https://leetcode.cn/problems/find-pivot-index/solutions/2834687/jian-ji-xie-fa-o1-e-wai-kong-jian-python-tz0p/</span></p>\n<p>:::</p>\n<h3 id=\"2352-相等行列对\"><a href=\"#2352-相等行列对\" class=\"headerlink\" title=\"2352. 相等行列对\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lcXVhbC1yb3ctYW5kLWNvbHVtbi1wYWlycy8=\">2352. 相等行列对</span></h3><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code> 列相等的行列对 <code>(Ri, Cj)</code> 的数目*。*</p>\n<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>\n<p>::: info no-icon</p>\n<p>用哈希表统计每行出现的次数，然后遍历列，累加哈希表中列出现的次数。</p>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9lcXVhbC1yb3ctYW5kLWNvbHVtbi1wYWlycy9zb2x1dGlvbnMvMTY5NDA0Ny9oYS14aS1iaWFvLXB5dGhvbi1saWFuZy14aW5nLWJ5LWVuZGxlc3NjLWxqYWUv\">https://leetcode.cn/problems/equal-row-and-column-pairs/solutions/1694047/ha-xi-biao-python-liang-xing-by-endlessc-ljae/</span></p>\n<p>;;;id2 Demo 1</p>\n<pre><code class=\"language-python\">class Solution:\n    def equalPairs(self, grid: List[List[int]]) -&gt; int:\n        cnt = Counter(tuple(row) for row in grid)\n        return sum(cnt[col] for col in zip(*grid))\n</code></pre>\n<p>;;;</p>\n<p>;;;id2 Demo2</p>\n<pre><code class=\"language-python\">class Solution:\n    def equalPairs(self, grid: List[List[int]]) -&gt; int:\n        n = len(grid)\n        count = &#123;&#125;\n        result = 0\n        for i in range(n):\n            count[tuple(grid[i])] = count.get(tuple(grid[i]), 0) + 1\n        print(count)\n        for j in zip(*grid):\n            print(j)\n            result += count.get(j,0)\n            # print(grid[:][j], grid[j][:])\n        return result\n</code></pre>\n<p>;;;</p>\n<p>:::</p>\n<h2 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h2><h3 id=\"735-小行星碰撞\"><a href=\"#735-小行星碰撞\" class=\"headerlink\" title=\"735. 小行星碰撞\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3Rlcm9pZC1jb2xsaXNpb24v\">735. 小行星碰撞</span></h3><p>给定一个整数数组 <code>asteroids</code>，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。</p>\n<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>\n<p>找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：asteroids = [5,10,-5]\n输出：[5,10]\n解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：asteroids = [8,-8]\n输出：[]\n解释：8 和 -8 碰撞后，两者都发生爆炸。\n</code></pre>\n<p><strong>示例 3：</strong></p>\n<pre><code>输入：asteroids = [10,2,-5]\n输出：[10]\n解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>这道栈的题目难点应该主要是在分析场景上了。<br>我们需要明确什么时候无脑入栈，什么时候需要判断，理解这两点就可以轻松解题了。<br>首先，循环每一个元素时，在什么情况下无脑入栈呢？</p>\n<p>栈为空<br>栈顶元素为负数(下一个为负数则一起向左，下一个为正数则分向两边)<br>当前元素为正数（栈顶为正一起向右，栈顶为负分向两边）<br>下来，我们需要看碰撞的场景又细分为什么情况：</p>\n<p>栈顶元素大于abs(当前元素)，当前元素被撞毁<br>栈顶元素等于abs(当前元素)，栈顶弹出和当前元素抵消<br>栈顶元素小于abs(当前元素)，栈顶弹出，并与新栈顶完成上述判断<br>最终返回栈即可。</p>\n<pre><code class=\"language-python\">class Solution:\n    def asteroidCollision(self, asteroids: List[int]) -&gt; List[int]:\n        stack, index = [], 0\n        while index &lt; len(asteroids):\n            ast = asteroids[index]\n            if ast &gt; 0 or len(stack)==0 or stack[-1]&lt;0: stack.append(ast)\n            elif stack[-1] &lt;= - ast:\n                if stack.pop(-1) &lt; - ast:\n                    continue\n            index += 1\n        return stack\n</code></pre>\n<p>作者：清风Python<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3Rlcm9pZC1jb2xsaXNpb24vc29sdXRpb25zLzk5NDEwMC83MzV4aW5nLXhpbmctcGVuZy16aHVhbmctamkteXUtemhhbi1xdS1mLXhwZDEv\">https://leetcode.cn/problems/asteroid-collision/solutions/994100/735xing-xing-peng-zhuang-ji-yu-zhan-qu-f-xpd1/</span></p>\n<p>:::</p>\n<h3 id=\"394-字符串解码\"><a href=\"#394-字符串解码\" class=\"headerlink\" title=\"394. 字符串解码\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nLw==\">394. 字符串解码</span></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>\n<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>\n<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>\n<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>\n<p>测试用例保证输出的长度不会超过 <code>105</code>。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：s = &quot;3[a]2[bc]&quot;\n输出：&quot;aaabcbc&quot;\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：s = &quot;3[a2[c]]&quot;\n输出：&quot;accaccacc&quot;\n</code></pre>\n<p><strong>示例 3：</strong></p>\n<pre><code>输入：s = &quot;2[abc]3[cd]ef&quot;\n输出：&quot;abcabccdcdcdef&quot;\n</code></pre>\n<p><strong>示例 4：</strong></p>\n<pre><code>输入：s = &quot;abc3[cd]xyz&quot;\n输出：&quot;abccdcdcdxyz&quot;\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<ul>\n<li><p>本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。</p>\n</li>\n<li><p>算法流程：</p>\n<ul>\n<li><p>构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</p>\n<ul>\n<li><p>当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</p>\n</li>\n<li><p>当 c 为字母时，在 res 尾部添加 c；</p>\n</li>\n<li><p>当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：<br>记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；<br>记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × […] 字符串。<br>进入到新 [ 后，res 和 multi 重新记录。</p>\n</li>\n<li><p>当 c 为 ] 时，stack 出栈，拼接字符串 res &#x3D; last_res + cur_multi * res，其中:</p>\n<ul>\n<li>last_res是上个 [ 到当前 [ 的字符串，例如 “3[a2[c]]” 中的 a；</li>\n<li>cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 “3[a2[c]]” 中的 2。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>返回字符串 res。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-python\">class Solution:\n    def decodeString(self, s: str) -&gt; str:\n        result = &#39;&#39;\n        stack = []\n        res, num = &#39;&#39;, 0\n        for c in s:\n            if c == &#39;[&#39;:\n                stack.append((res, num))\n                res, num = &#39;&#39;, 0\n            elif c == &#39;]&#39;:\n                out_res, out_num = stack.pop()\n                res = out_res + out_num*res\n            elif &#39;0&#39;&lt;= c &lt;= &#39;9&#39;:\n                num = num*10 + int(c)\n            else:\n                res += c\n        return res\n</code></pre>\n<p>作者：Krahets<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWNvZGUtc3RyaW5nL3NvbHV0aW9ucy8xOTQ0Ny9kZWNvZGUtc3RyaW5nLWZ1LXpodS16aGFuLWZhLWRpLWd1aS1mYS1ieS1qeWQv\">https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/</span></p>\n<p>:::</p>\n<h3 id=\"649-Dota2-参议院\"><a href=\"#649-Dota2-参议院\" class=\"headerlink\" title=\"649. Dota2 参议院\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kb3RhMi1zZW5hdGUv\">649. Dota2 参议院</span></h3><p>Dota2 的世界里有两个阵营：<code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）</p>\n<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一</strong> 项：</p>\n<ul>\n<li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 <strong>所有的权利</strong> 。</li>\n<li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li>\n</ul>\n<p>给你一个字符串 <code>senate</code> 代表每个参议员的阵营。字母 <code>&#39;R&#39;</code> 和 <code>&#39;D&#39;</code>分别代表了 <code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是 <code>n</code>。</p>\n<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>\n<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 <code>&quot;Radiant&quot;</code> 或 <code>&quot;Dire&quot;</code> 。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<pre><code>输入：senate = &quot;RD&quot;\n输出：&quot;Radiant&quot;\n解释：\n第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。\n这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。\n第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n<pre><code>输入：senate = &quot;RDD&quot;\n输出：&quot;Dire&quot;\n解释：\n第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。\n这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。\n这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。\n因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>这道题模拟了一个游戏过程，最终当有权利投票的参议员都是 同一个阵营的 ，这个阵营即获胜。</p>\n<p>那么两个阵营的每个参议员为了获胜，当他拥有权力的时候，一定是会将自己之后首个对立阵营的参议员的权力禁止掉。【这就是每一位参议会为自己的政党做出最好的策略】。请注意：当之后没有对立阵营的参议员的时候，相当于将之前的参议员加到其之后。</p>\n\n\n\n\n\n\n\n\n\n\n<pre><code class=\"language-python\">class Solution:\n    def predictPartyVictory(self, senate: str) -&gt; str:\n        radiants, dires = [], []\n        n = len(senate)\n        for i, se in enumerate(senate):\n            if se == &#39;R&#39;: radiants.append(i)\n            else: dires.append(i)\n        while radiants and dires:\n            if radiants[0] &lt; dires[0]:\n                dires.pop(0)\n                radiants.append(radiants.pop(0) + n)\n            else:\n                radiants.pop(0)\n                dires.append(dires.pop(0) + n)\n        return &quot;Radiant&quot; if radiants else &#39;Dire&#39;\n        \n</code></pre>\n<p>作者：画图小匠<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kb3RhMi1zZW5hdGUvc29sdXRpb25zLzI4NjIxMTUvamF2YXB5dGhvbjNjZHVpLWxpZS1tby1uaS1qaW4temhpLXpoaS1oby1sNHBiLw==\">https://leetcode.cn/problems/dota2-senate/solutions/2862115/javapython3cdui-lie-mo-ni-jin-zhi-zhi-ho-l4pb/</span></p>\n<p>:::</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>:::info no-icon</p>\n<ol>\n<li>找中间节点：快慢指针</li>\n</ol>\n<ul>\n<li><p>中间值左侧：需要加一个dummy节点。</p>\n<pre><code class=\"language-python\">dummy = ListNode(0, head)\nslow, fast = dummy, dummy\nwhile fast and fast.next:\n    fast = fast.next.next\n    if not fast: break\n    slow = slow.next\n</code></pre>\n</li>\n<li><p>中间值右侧：直接从head开始</p>\n<pre><code class=\"language-python\">slow, fast = head, head\nwhile fast and fast.next:\n    fast = fast.next.next\n    if not fast: break\n    slow = slow.next\n</code></pre>\n</li>\n</ul>\n<p>:::</p>\n<h3 id=\"2095-删除链表的中间节点\"><a href=\"#2095-删除链表的中间节点\" class=\"headerlink\" title=\"2095. 删除链表的中间节点\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtdGhlLW1pZGRsZS1ub2RlLW9mLWEtbGlua2VkLWxpc3Qv\">2095. 删除链表的中间节点</span></h3><p>给你一个链表的头节点 <code>head</code> 。<strong>删除</strong> 链表的 <strong>中间节点</strong> ，并返回修改后的链表的头节点 <code>head</code> 。</p>\n<p>长度为 <code>n</code> 链表的中间节点是从头数起第 <code>⌊n / 2⌋</code> 个节点（下标从 <strong>0</strong> 开始），其中 <code>⌊x⌋</code> 表示小于或等于 <code>x</code> 的最大整数。</p>\n<ul>\n<li>对于 <code>n</code> &#x3D; <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 和 <code>5</code> 的情况，中间节点的下标分别是 <code>0</code>、<code>1</code>、<code>1</code>、<code>2</code> 和 <code>2</code> 。</li>\n</ul>\n<p> :::info no-icon</p>\n<p>本题可遍历计数先得到 n，再遍历一次删除指定节点即可，这很简单。本篇讲的是快慢指针这种方法。</p>\n<p>我们令 fast 和 slow 这两个指针同时前进，fast 每次移动两格，slow 每次移动一格，在检测到 <code>fast.next == null</code> 或者 <code>fast.next.next == null</code> 时退出循环。</p>\n<p>引入一个哑巴节点 dummy 便于处理，考虑循环停止时的场景。<br>为方便考虑，本篇题解认为原链表下标从 1 开始，需要删除第 $⌊\\frac{n}{2}⌋+1$ 个节点。</p>\n<ul>\n<li>如果 <em>n</em> 为偶数，如下所示。设 <em>n</em>&#x3D;2<em>k</em>，fast 停在第 2<em>k</em> 个节点，slow 停在第 <em>k</em> 即 $⌊\\frac{n}{2}⌋$ 个节点。</li>\n</ul>\n\n\n<ul>\n<li>如果 <em>n</em> 为奇数，如下所示，设 <em>n</em>&#x3D;2<em>k</em>+1。fast 停在第 2<em>k</em> 个节点，slow 停在第 <em>k</em> 即 $⌊\\frac{n}{2}⌋$ 个节点。</li>\n</ul>\n\n\n<p>所以退出循环时 slow 一定停在 $⌊\\frac{n}{2}⌋$ 个节点，令 <code>slow.next = slow.next.next</code> 即删除了 $⌊\\frac{n}{2}⌋+1$ 个节点。</p>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        zero = ListNode(0, head)\n        slow, fast = zero, zero\n        while fast and fast.next:\n            fast = fast.next.next\n            if not fast: break\n            slow = slow.next\n        slow.next = slow.next.next\n        return zero.next\n\n        \n</code></pre>\n<p>作者：Shawxing精讲算法<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtdGhlLW1pZGRsZS1ub2RlLW9mLWEtbGlua2VkLWxpc3Qvc29sdXRpb25zLzI4NDQyMjkvamlhbi1taW5nLXlhbi1qaW4tZGUta3VhaS1tYW4temhpLXpoZW4tZi04NHN4Lw==\">https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solutions/2844229/jian-ming-yan-jin-de-kuai-man-zhi-zhen-f-84sx/</span></p>\n<p>:::</p>\n<h3 id=\"328-奇偶链表\"><a href=\"#328-奇偶链表\" class=\"headerlink\" title=\"328. 奇偶链表\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC8=\">328. 奇偶链表</span></h3><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。</p>\n<p><strong>第一个</strong>节点的索引被认为是 <strong>奇数</strong> ， <strong>第二个</strong>节点的索引为 <strong>偶数</strong> ，以此类推。</p>\n<p>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。</p>\n<p>你必须在 <code>O(1)</code> 的额外空间复杂度和 <code>O(n)</code> 的时间复杂度下解决这个问题。</p>\n<p>:::info no-icon</p>\n<p>如果链表为空，则直接返回链表。</p>\n<p>对于原始链表，每个节点都是奇数节点或偶数节点。头节点是奇数节点，头节点的后一个节点是偶数节点，相邻节点的奇偶性不同。因此可以将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。</p>\n<p>原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead &#x3D; head.next，则 evenHead 是偶数链表的头节点。</p>\n<p>维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd &#x3D; head，even &#x3D; evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。</p>\n<ul>\n<li><p>更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next &#x3D; even.next，然后令 odd &#x3D; odd.next，此时 odd 变成 even 的后一个节点。</p>\n</li>\n<li><p>更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next &#x3D; odd.next，然后令 even &#x3D; even.next，此时 even 变成 odd 的后一个节点。</p>\n</li>\n</ul>\n\n\n\n\n\n\n\n\n<p>在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。</p>\n<p>最后令 odd.next &#x3D; evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。</p>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def oddEvenList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:\n        if not head: return head\n        even_head = head.next\n        odd, even = head, even_head\n        while even and even.next:\n            odd.next = even.next\n            odd = odd.next\n            even.next = odd.next\n            even = even.next\n        odd.next = even_head\n        return head\n</code></pre>\n<p>作者：力扣官方题解<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9vZGQtZXZlbi1saW5rZWQtbGlzdC9zb2x1dGlvbnMvNDgyNzM3L3FpLW91LWxpYW4tYmlhby1ieS1sZWV0Y29kZS1zb2x1dGlvbi8=\">https://leetcode.cn/problems/odd-even-linked-list/solutions/482737/qi-ou-lian-biao-by-leetcode-solution/</span></p>\n<p>:::</p>\n<h3 id=\"2130-链表最大孪生和\"><a href=\"#2130-链表最大孪生和\" class=\"headerlink\" title=\"2130. 链表最大孪生和\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXR3aW4tc3VtLW9mLWEtbGlua2VkLWxpc3Qv\">2130. 链表最大孪生和</span></h3><p>在一个大小为 <code>n</code> 且 <code>n</code> 为 <strong>偶数</strong> 的链表中，对于 <code>0 &lt;= i &lt;= (n / 2) - 1</code> 的 <code>i</code> ，第 <code>i</code> 个节点（下标从 <strong>0</strong> 开始）的孪生节点为第 <code>(n-1-i)</code> 个节点 。</p>\n<ul>\n<li>比方说，<code>n = 4</code> 那么节点 <code>0</code> 是节点 <code>3</code> 的孪生节点，节点 <code>1</code> 是节点 <code>2</code> 的孪生节点。这是长度为 <code>n = 4</code> 的链表中所有的孪生节点。</li>\n</ul>\n<p><strong>孪生和</strong> 定义为一个节点和它孪生节点两者值之和。</p>\n<p>给你一个长度为偶数的链表的头节点 <code>head</code> ，请你返回链表的 <strong>最大孪生和</strong> 。</p>\n<p> +++info 示例</p>\n<p><strong>示例 1：</strong></p>\n\n\n<pre><code>输入：head = [5,4,2,1]\n输出：6\n解释：\n节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。\n链表中没有其他孪生节点。\n所以，链表的最大孪生和是 6 。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n\n\n<pre><code>输入：head = [4,2,2,3]\n输出：7\n解释：\n链表中的孪生节点为：\n- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。\n- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。\n所以，最大孪生和为 max(7, 4) = 7 。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p><strong>核心思想：寻找链表中间值</strong></p>\n<p>以下两种方法的快慢指针有所不同，参见<a href=\"#%E9%93%BE%E8%A1%A8\">链表</a>。</p>\n<p>;;;id3 快慢指针+反转链表</p>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def pairSum(self, head: Optional[ListNode]) -&gt; int:\n        mid = self.middleNode(head)\n        head2 = self.reverseNode(mid)\n        result = -inf\n        while head2:\n            result = max(result, head.val + head2.val)\n            head = head.next\n            head2 = head2.next\n        return result\n\n    def reverseNode(self, head):\n        cur, pre = head, None\n        while cur:\n            nxt = cur.next\n            cur.next = pre\n            pre = cur\n            cur = nxt\n        return pre\n        \n    def middleNode(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n        \n</code></pre>\n<p>;;;</p>\n<p>;;;id3 快慢指针+入栈</p>\n<pre><code class=\"language-python\"># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def pairSum(self, head: Optional[ListNode]) -&gt; int:\n        dummy = ListNode(next=head)\n        slow, fast = dummy, dummy\n        stack = []\n        result = -inf\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n            stack.append(slow.val)\n        print(slow.val)\n        while slow.next:\n            slow = slow.next\n            result = max(result, stack.pop(-1)+slow.val)\n        return result\n        \n</code></pre>\n<p>;;;</p>\n<p>:::</p>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>:::info no-icon</p>\n<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVVENHkxWTc2OS8/dmRfc291cmNlPTliMDUwMzdjNzdlYzk0MGRhZTNhZjhlNjk5NjllMGQ2\">看到递归就晕？带你理解递归的本质！【基础算法精讲 09】_哔哩哔哩_bilibili</span></li>\n</ol>\n<p>:::</p>\n<h3 id=\"437-路径总和-III（与560-和为-K-的子数组方法相似）\"><a href=\"#437-路径总和-III（与560-和为-K-的子数组方法相似）\" class=\"headerlink\" title=\"437. 路径总和 III（与560. 和为 K 的子数组方法相似）\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkv\">437. 路径总和 III</span>（与<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsv\">560. 和为 K 的子数组</span>方法相似）</h3><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>\n<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n\n\n<pre><code>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n输出：3\n解释：和等于 8 的路径有 3 条，如图所示。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>如果二叉树是一条链，本题就和 560. 和为 K 的子数组 完全一样了：统计有多少个非空连续子数组的元素和恰好等于 targetSum。所以你必须先弄明白 560 题（特殊情况），再来做本题（一般情况）。560 题的做法见 我的题解。</p>\n<p>这两题的联系如下：</p>\n<table>\n<thead>\n<tr>\n<th>560 题</th>\n<th>本题</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>连续子数组</td>\n<td>方向向下的路径</td>\n</tr>\n<tr>\n<td>前缀</td>\n<td>从根节点开始的路径</td>\n</tr>\n<tr>\n<td>做法：枚举子数组右端点，统计有多少个左端点</td>\n<td>做法：枚举路径的终点，统计有多少个起点<br/>我们要解决的问题是：DFS 遍历这棵树，遍历到节点 node 时，假设 node 是路径的终点，那么有多少个起点，满足起点到终点 node 的路径总和恰好等于 targetSum？</td>\n</tr>\n</tbody></table>\n<p>和 560 题一样的套路：一边遍历二叉树，一边用哈希表 cnt 统计前缀和（从根节点开始的路径和）的出现次数。设从根到终点 node 的路径和为 s，那么起点的个数就是 cnt[s−targetSum]，加入答案。对比 560 题，我们在枚举子数组的右端点（终点），统计有多少个左端点（起点），做法完全一致。</p>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; int:\n        ans = 0\n        hp = collections.defaultdict(int)\n        hp[0] = 1\n        def dfs(node, s):\n            if not node: return \n            nonlocal ans\n            s += node.val\n            ans += hp[s - targetSum]\n\n            hp[s] += 1\n            dfs(node.left, s)\n            dfs(node.right, s)\n            hp[s] -= 1\n        dfs(root, 0)\n        return ans\n</code></pre>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS1paWkvc29sdXRpb25zLzI3ODQ4NTYvenVvLWZhLWhlLTU2MC10aS1zaGkteWkteWFuZy1kZS1weXRob25qYS1mbXpvLw==\">https://leetcode.cn/problems/path-sum-iii/solutions/2784856/zuo-fa-he-560-ti-shi-yi-yang-de-pythonja-fmzo/</span></p>\n<p>:::</p>\n<h3 id=\"1372-二叉树中的最长交错路径\"><a href=\"#1372-二叉树中的最长交错路径\" class=\"headerlink\" title=\"1372. 二叉树中的最长交错路径\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXppZ3phZy1wYXRoLWluLWEtYmluYXJ5LXRyZWUv\">1372. 二叉树中的最长交错路径</span></h3><p>给你一棵以 <code>root</code> 为根的二叉树，二叉树中的交错路径定义如下：</p>\n<ul>\n<li>选择二叉树中 <strong>任意</strong> 节点和一个方向（左或者右）。</li>\n<li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li>\n<li>改变前进方向：左变右或者右变左。</li>\n<li>重复第二步和第三步，直到你在树中无法继续移动。</li>\n</ul>\n<p>交错路径的长度定义为：<strong>访问过的节点数目 - 1</strong>（单个节点的路径长度为 0 ）。</p>\n<p>请你返回给定树中最长 <strong>交错路径</strong> 的长度。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n\n\n<pre><code>输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]\n输出：3\n解释：蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n\n\n<pre><code>输入：root = [1,1,1,null,1,null,null,1,1,null,1]\n输出：4\n解释：蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>在 DFS 的过程中，每次我们都把当前点的 len 参数和答案 maxAns 打擂台，这样可以比出一个最大的。然后我们根据 dir 分类讨论。如果当前点应该向左且可以向左，那么就让他向左走一步，新的 len 是当前的 len 加一。如果的的点应该向左但是却没有左子树呢？很无奈那就只能向右了，这个时候 len 的值应该「重置」。</p>\n<p>思考：「重置」为什么是把 len 变成 1 而不是 0？ 因为当前的点下传到它的子节点的时候已经走了一条长度为 1 的边。那么为什么 main 函数中传入的 len 值是 0 而不是 1 呢？ 因为 main 函数中的 root 是没有父亲节点的，所以当前已经走过的路为 0。</p>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def longestZigZag(self, root: Optional[TreeNode]) -&gt; int:\n        result = 0\n        def search(node, mode, l):\n            if not node:return \n            nonlocal result\n            result = max(result, l)\n            if mode == &#39;left&#39;: \n                search(node.right, &#39;right&#39;,l+1)\n                search(node.left, &#39;left&#39;, 1)\n            elif mode == &#39;right&#39;: \n                search(node.left, &#39;left&#39;, l+1)\n                search(node.right, &#39;right&#39;, 1)\n        search(root,&#39;left&#39;, 0)\n        search(root, &#39;right&#39;, 0)\n        return result\n</code></pre>\n<p>作者：力扣官方题解<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXppZ3phZy1wYXRoLWluLWEtYmluYXJ5LXRyZWUvc29sdXRpb25zLzE0NzQyNS9lci1jaGEtc2h1LXpob25nLWRlLXp1aS1jaGFuZy1qaWFvLWN1by1sdS1qaW5nLWItMi8=\">https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/solutions/147425/er-cha-shu-zhong-de-zui-chang-jiao-cuo-lu-jing-b-2/</span></p>\n<p>:::</p>\n<h3 id=\"236-二叉树的最近公共祖先\"><a href=\"#236-二叉树的最近公共祖先\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb3dlc3QtY29tbW9uLWFuY2VzdG9yLW9mLWEtYmluYXJ5LXRyZWUv\">236. 二叉树的最近公共祖先</span></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOUMlODAlRTglQkYlOTElRTUlODUlQUMlRTUlODUlQjElRTclQTUlOTYlRTUlODUlODgvODkxODgzND9mcj1hbGFkZGlu\">百度百科</span>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n<p> +++info 示例</p>\n<p><strong>示例 1：</strong></p>\n\n\n<pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。\n</code></pre>\n<p><strong>示例 2：</strong></p>\n\n\n<pre><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n</code></pre>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVc0NHkxWjdBUi8/dmRfc291cmNlPTliMDUwMzdjNzdlYzk0MGRhZTNhZjhlNjk5NjllMGQ2\">二叉树的最近公共祖先【基础算法精讲 12】_哔哩哔哩_bilibili</span></p>\n\n\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:\n        if root == None or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if right and left: return root\n        return left or right\n        \n</code></pre>\n<p>:::</p>\n<h3 id=\"199-二叉树的右视图\"><a href=\"#199-二叉树的右视图\" class=\"headerlink\" title=\"199. 二叉树的右视图\"></a><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv\">199. 二叉树的右视图</span></h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n<p>+++info 示例</p>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入：</strong> root &#x3D; [1,2,3,null,5,null,4]</p>\n<p><strong>输出：</strong>[1,3,4]</p>\n<p><strong>解释：</strong></p>\n\n\n<p><strong>示例 2：</strong></p>\n<p>**输入：**root &#x3D; [1,2,3,4,null,null,null,5]</p>\n<p><strong>输出：</strong>[1,3,4,5]</p>\n<p><strong>解释：</strong></p>\n\n\n<p><strong>示例 3：</strong></p>\n<p>**输入：**root &#x3D; [1,null,3]</p>\n<p><strong>输出：</strong>[1,3]</p>\n<p>+++</p>\n<p>:::info no-icon</p>\n<p>;;;id4 深度优先算法</p>\n<p><strong>视频讲解</strong>：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMThNNDExejdiYi8=\">【基础算法精讲 10】</span></p>\n<p><strong>思路</strong>：先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。</p>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:\n        result = []\n        def dfs(root, depth):\n            if not root: return \n            if depth == len(result):\n                result.append(root.val)\n            dfs(root.right, depth + 1)\n            dfs(root.left, depth + 1)\n        dfs(root, 0)\n        return result\n</code></pre>\n<p>作者：灵茶山艾府<br>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcvc29sdXRpb25zLzIwMTUwNjEvcnUtaGUtbGluZy1odW8teXVuLXlvbmctZGktZ3VpLWxhaS1rYW4tcy1yMW5jLw==\">https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/</span></p>\n<p>;;;</p>\n<p>;;;id4 层序遍历</p>\n<p><strong>思路</strong>：将每层的元素加入队列，从右到左依序遍历每层。</p>\n<pre><code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -&gt; List[int]:\n        if not root: return []\n        result = []\n        que = [root]\n        while len(que) &gt; 0:\n            result.append(que[0].val)\n            for _ in range(len(que)):\n                node = que.pop(0)\n                if node.right: que.append(node.right)\n                if node.left: que.append(node.left)\n        return result\n</code></pre>\n<p>;;;</p>\n<p>:::</p>\n","categories":["技能工具"]}]