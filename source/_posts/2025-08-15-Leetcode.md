---
title: Leetcode刷题记录
math: true
fancybox: true
date: 2025-08-15
categories:
- 技能工具

---

Leetcode刷题记录

<!-- more -->

# Leetcode刷题



## 数组/字符串

### [1071. 字符串的最大公因子](https://leetcode.cn/problems/greatest-common-divisor-of-strings/)

对于字符串 `s` 和 `t`，只有在 `s = t + t + t + ... + t + t`（`t` 自身连接 1 次或多次）时，我们才认定 “`t` 能除尽 `s`”。

给定两个字符串 `str1` 和 `str2` 。返回 *最长字符串 `x`，要求满足 `x` 能除尽 `str1` 且 `x` 能除尽 `str2`* 。

:::info no-icon

若两个字符串是由同一个字符串 X重复拼接而成，那么无论先拼哪个，结果应该相同。
如果 str1 + str2 != str2 +str1，说明不存在公共的重复因子，直接返回空串 ""。
如果两个字符串都是由同一个字符串 X 组成，那么 X 的长度必然是str1.size()和 str2.size() 的最大公约数。

```python
class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        if not str1 + str2 == str2 + str1:
            return ""
        return str1[0:self.gcd(len(str1), len(str2))]
    
    def gcd(self, a,b):
        if b == 0: return a
        else: return gcd(b, a%b)
    
```

作者：Random
链接：https://leetcode.cn/problems/greatest-common-divisor-of-strings/solutions/3749891/shu-xue-zui-da-gong-yue-shu-by-coder-ran-a88u/

:::

### [605. 种花问题](https://leetcode.cn/problems/can-place-flowers/)

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false` 。

:::info no-icon

从左到右遍历数组，能种花就立刻种花。

如何判断能否种花？由于「花不能种植在相邻的地块上」，如果要在下标 i 处种花，需要满足 flowerbed[i−1],flowerbed[i],flowerbed[i+1] 均为 0。

每种一朵花，就把 n 减一。如果最后 n≤0，则返回 true，否则返回 false。

为了简化判断逻辑，可以在数组的开头和末尾各插入一个 0。

```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
      nums = len(flowerbed)
      new_flowerbed = [0] + flowerbed + [0]
      for i in range(1,len(new_flowerbed)-1):
        if new_flowerbed[i-1] == 0 and new_flowerbed[i+1] == 0 and new_flowerbed[i] == 0:
          new_flowerbed[i] = 1
          n -= 1
      return n <= 0

```

作者：灵茶山艾府
链接：https://leetcode.cn/problems/can-place-flowers/solutions/2463018/ben-ti-zui-jian-dan-xie-fa-pythonjavacgo-6a6k/

:::

### [334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `3` 的递增子序列。

如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。

:::info no-icon

;;;id1 巧解

核心想法：遍历一遍数组，希望遍历到的这个数three，前面已经有一个比他小的数two，再前面有一个比two小的数one。
我们需要维护两个变量：one和two。代表递增子序列的第一个数和第二个数。
假设我们已经有了这两个数，那么three的大小有以下三种情况：

1. **three大于two**    此情况下：即找到了三元组，直接返回true。

   ![300](2025-08-15-Leetcode/334-01.png)

2. **three介于two和one之间**     此情况下：应更新two，赋值为这个更小的值。这相当于帮我们扩大了three的可选择范围，当再次遇到一个比更新过的two大的数即可找到。

   ![300](2025-08-15-Leetcode/334-02.png)

   ![300](2025-08-15-Leetcode/334-03.png)

3. **three小于one**     此情况下：应更新one，赋值为这个更小的值。而不需要动two。这相当于帮我们扩大了之后出现的two的可选择范围。进而扩大了之后出现的three的可选择范围。

![300](2025-08-15-Leetcode/334-04.png)

![300](2025-08-15-Leetcode/334-05.png)

![300](2025-08-15-Leetcode/334-06.png)

需要注意的是，我们只更新one，原先的two不需要更改，因为子序列是从前往后的，只有当之后再出现比two小的数的时候再按照第二步那样更改。

假设有如下示例：[2,5,1,6]，在遇到1之后更新了one，后遇到6，因为先判断是否大于two，由于6大于5，就直接返回true了。

![300](2025-08-15-Leetcode/334-07.png)

注意：two附带隐含信息——这之前有个数比two小
所以此时找到的递增子序列不是one、two、three的1 5 6，而是old one、two、three的2 5 6。

这里更新的one的意思是，为之后可能存在的更小的递增子序列打基础。
假设有如下示例：[2,5,1,2,6]，在遇到1之后更新了one，后遇到2，2介于1和5（two）之间，更新two为2，后遇到6，由于6大于2，返回true。
此时找到的递增子序列才是one、two、three的1 2 6

最后考虑one、two的初值，容易想到设定为Integer.MAX_VALUE即可。

作者：Xzz
链接：https://leetcode.cn/problems/increasing-triplet-subsequence/solutions/535725/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/

```python
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
      one, two = inf, inf
      for three in nums:
        if three > two : return True
        elif three <= one: one = three
        else: two = three
      return False
```



+++info 解析（GPT）

 **1. 递增三元组的性质**

假设数组中存在递增三元组 `a < b < c`，它们的顺序在数组中是 **前后顺序**，我们只关心：

- 第一个数最小
- 第二个数比第一个数大
- 第三个数比第二个数大

**关键点**：我们不需要知道三元组具体位置，只需要保证存在。

 **2. one 和 two 的作用**

- `one`：当前找到的**最小的候选第一个数**
- `two`：在 `one` 之后，找到的**最小的候选第二个数**

**核心思想**：

- 我们并不是在找数组中所有可能的三元组，而是在**维护最优候选序列**。
- “最优候选”意味着 **尽可能小的 one 和 two**，这样可以最大化出现第三个数 three 的机会。

换句话说：

1. 遍历到一个数 three：
   - 如果 three > two → 说明找到了一个合法三元组（不管前面 one/two 是不是更新过的，都会形成合法的递增序列）。
2. 如果 three <= one → 更新 one
   - 因为这个更小的 one 可以为之后出现的 two 提供更多可能。
3. 否则 → 更新 two
   - 因为这个更小的 two 可以为之后出现的 three 提供更多可能。

 **3. 为什么不会漏掉任何情况**

假设数组中有递增三元组 `x < y < z`，为什么算法一定能找到它？

- 当我们遍历到 x：
  - one 会被更新为 ≤ x
- 当我们遍历到 y：
  - two 会被更新为 ≤ y
- 当我们遍历到 z：
  - 如果 z > two → 返回 True

**关键点**：

- 即使 one/two 被后面更小的数更新过，**old one/two 仍然保留了前序信息**，保证当前 three 大于某个二元组时，必然能形成递增三元组。
- 换句话说，one/two 是动态维护的 **最小可能序列候选**，任何真正存在的递增三元组都会被捕获。



;;;

;;;id1 常规

常规解法

;;;

:::



### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

+++info 示例

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**示例 3：**

```
输入：intervals = [[4,7],[1,4]]
输出：[[1,7]]
解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。
```

+++

:::info no-icon

重要定理：能够合并的区间都必然是连续的。

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort(key=lambda x:x[0])
        result = []
        for interval in intervals:
            if not result or interval[0] > result[-1][-1]:
                result.append(interval)
            else:
                result[-1][-1] = max(result[-1][-1], interval[-1])
        return result
```

作者：力扣官方题解
链接：https://leetcode.cn/problems/merge-intervals/solutions/203562/he-bing-qu-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

:::

### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

+++info 示例

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

+++

:::info no-icon

这里假设 0≤k<n，对于 k≥n 的情况，可以转换成 0≤k<n 的情况（证明见后文）。

设 nums=A+B，其中 A 是 nums 的前 n−k 个数，B 是后 k 个数。在上例中，A=[1,2,3,4]，B=[5,6,7]。

题目要求把 A+B 变成 B+A，这可以用三次反转实现：

把 nums=A+B 反转，我们得到了 rev(B)+rev(A)，其中 rev(A) 表示数组 A 反转后的结果。在上例中，rev(B)+rev(A)=[7,6,5]+[4,3,2,1]。
单独反转 rev(B)，因为一个数组反转两次是不变的，所以 rev(rev(B))=B，我们得到了 B。
单独反转 rev(A)，得到 rev(rev(A))=A。
现在数组变成 B+A。在上例中，B+A=[5,6,7]+[1,2,3,4]，这正是我们想要的结果。

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        def reverse(l,r):
            while l < r:
                nums[l], nums[r] = nums[r], nums[l]
                l += 1
                r -= 1
        n = len(nums)
        k = k % n
        reverse(0,n-1)
        reverse(0,k-1)
        reverse(k,n-1)
        return 
```

作者：灵茶山艾府
链接：https://leetcode.cn/problems/rotate-array/solutions/2784427/tu-jie-yuan-di-zuo-fa-yi-tu-miao-dong-py-ryfv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

:::

### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

+++info 示例

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。
```

 

+++

:::info no-icon

由于我们只在意 [1,N] 中的数，因此我们可以先对数组进行遍历，把不在 [1,N] 范围内的数修改成任意一个大于 N 的数（例如 N+1）。这样一来，数组中的所有数就都是正数了，因此我们就可以将「标记」表示为「负号」。算法的流程如下：

我们将数组中所有小于等于 0 的数修改为 N+1；

我们遍历数组中的每一个数 x，它可能已经被打了标记，因此原本对应的数为 ∣x∣，其中 ∣∣ 为绝对值符号。如果 ∣x∣∈[1,N]，那么我们给数组中的第 ∣x∣−1 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；

在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 N+1，否则答案是第一个正数的位置加 1。

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0:
                nums[i] = n+1
        for i in range(n):
            num = abs(nums[i])
            if num <= n:
                nums[num-1] = -abs(nums[num-1])
        for i in range(n):
            if nums[i] > 0:
                return i+1
        return n+1
        
```

作者：力扣官方题解
链接：https://leetcode.cn/problems/first-missing-positive/solutions/304743/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



:::

## 矩阵

### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。



给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

+++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/54-01.png)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

+++

:::info no-icon

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        m, n = len(matrix), len(matrix[0])
        visited = [[0]*n for _ in range(m)]
        count = m*n
        directions = [[0,1],[1,0],[0,-1],[-1,0]]
        x, y = 0, 0
        mode = 0
        result = []
        for i in range(count):
            visited[x][y] = 1
            result.append(matrix[x][y])
            mode = mode % 4
            if 0 <= x + directions[mode][0] < m and 0 <= y + directions[mode][1] < n and visited[x + directions[mode][0]][y + directions[mode][1]]==0:
                x += directions[mode][0]
                y += directions[mode][1]
                # print(visited)
            else:
                mode = (mode + 1)%4
                x += directions[mode][0]
                y += directions[mode][1]
        return result
```

:::

### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

+++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/48-01.png)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

+++

:::info no-icon

先沿对角线翻转，后沿中轴线翻转。

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        m = len(matrix)
        for i in range(m):
            for j in range(i):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        for i in range(m):
            for j in range(m//2):
                matrix[i][j], matrix[i][m-1-j] = matrix[i][m-1-j], matrix[i][j]
        return
```

:::



### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

:::info no-icon

分离出每行，在每行内执行二分查找。

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        def bi_sect(rows, left, right):
            while left <= right:
                mid = (left + right) // 2
                if target == rows[mid]: return True
                elif target > rows[mid]: left = mid+1
                else:right = mid-1
            return False
        n = len(matrix)
        for i in range(n):
            if bi_sect(matrix[i],0,len(matrix[i])-1):return True
        return False
```

:::



## 滑动窗口

### [1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)

给你两个长度相同的字符串，`s` 和 `t`。

将 `s` 中的第 `i` 个字符变到 `t` 中的第 `i` 个字符需要 `|s[i] - t[i]|` 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 `maxCost`。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 `s` 的子字符串转化为它在 `t` 中对应的子字符串，则返回可以转化的最大长度。

如果 `s` 中没有子字符串可以转化成 `t` 中对应的子字符串，则返回 `0`。

+++info 示例

**示例 1：**

```
输入：s = "abcd", t = "bcdf", maxCost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。
```

**示例 2：**

```
输入：s = "abcd", t = "cdef", maxCost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。
```

**示例 3：**

```
输入：s = "abcd", t = "acde", maxCost = 0
输出：1
解释：a -> a, cost = 0，字符串未发生变化，所以最大长度为 1。
```

+++

:::info no-icon

两个长度相等字符串的 s 和 t ，把 i 位置的 s[i] 转成 t[i] 的开销是两者 ASCII 码之差的绝对值。题目给出了允许的最大预算 maxCost ，求不超过预算的情况下能够转换的最长子串。

比如，对于 s = "abcd", t = "bcdf", cost = 3 而言，我们使用 costs[i] 表示从 s[i]  转成 t[i] 的开销，那么 costs = [1, 1, 1, 2] 。由于 maxCost = 3， 所以最多允许其前面三个字符进行转换。

于是题目变成了：**已知一个数组 costs ，求：和不超过 maxCost 时最长的子数组的长度**。

![300](2025-08-15-Leetcode/1208-01.png)

```python
class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        n = len(s)
        left, right = 0, 0
        result = 0
        cost = 0
        while right < n:
            cost += abs(ord(s[right]) - ord(t[right]))
            while cost > maxCost:
                cost -= abs(ord(s[left]) - ord(t[left]))
                left += 1
                
            result = max(result, right - left + 1)
            right += 1
        return result

```



《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。

+++info 滑动窗口问题模板

我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题（[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)，[424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)）：

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```

滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

模板的整体思想是：

定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；
第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和/计数；
第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和/计数；
在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。
right 指针每次向右移动一步，开始探索新的区间。
模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。

另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间[left, right]不符合题意 。对于本题而言，就是该区内的和 sums 超过了 maxCost 。

+++



作者：负雪明烛
链接：https://leetcode.cn/problems/get-equal-substrings-within-budget/solutions/592354/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/
:::





### [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。

在执行上述操作后，返回 *包含相同字母的最长子字符串的长度。*

+++info 示例

**示例 1：**

```
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

**示例 2：**

```
输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
可能存在其他的方法来得到同样的结果。
```

+++

:::info no-icon

本题解根据常规的滑动窗口思路进行解题，不需要任何的技巧。
滑动窗口法是指通过Left以及Right指针来框定一个窗口，当在窗口内的字符串满足题目要求则记录下当前窗口长度并进一步扩张寻找更长的窗口，若不满足则进行窗口平移。
题目中给定的K值是让我们在选定有效窗口时的要求放宽了：

当K=0时，要求滑动窗口内部的所有字母都必须相同；
而当K>0时，要求滑动窗口内最多替换K次使得所有字母都必须相同。这里有一个关键点，即我们将当前滑动窗口内出现次数最多的字母作为基准字母（Benchmark），那么其他不一样的字母(Others)都选择替换操作即可以最小的代价转换为全部相同的字母。
因此，我们首先通过一个数组(count)记录所有字母在当前窗口出现的次数，通过Max函数选择窗口内的基准字母，然后其他字母出现的次数为Sum(count)-Max(count)，通过与K进行比较，即可知道当前窗口是否有效，下一步是继续扩张还是位移。

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = [0 for _ in range(26)]  #记录当前窗口的字母出现次数
        
        left = 0    #滑动窗口左边界
        right = 0   #滑动窗口右边界
        retval = 0  #最长窗口长度
        
        while right < len(s):
            count[ord(s[right])-ord('A')] += 1  
            benchmark = max(count)              #选择出现次数最多的字母为基准 
            others = sum(count) - benchmark     #则其他字母需要通过替换操作来变为基准
            if others <= k:                     #通过与K进行比较来判断窗口是进行扩张？
                right += 1
                retval = max(retval, right-left)#记录当前有效窗口长度
            else:                               #通过与K进行比较来判断窗口还是进行位移？
                count[ord(s[left])-ord('A')] -= 1
                left += 1
                right += 1                      #这里注意：位移操作需要整个向右移，不仅仅只是left向右
        
        return retval                           #返回最长窗口长度
        
```

作者：Derrick.S
链接：https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/799013/hua-dong-chuang-kou-fa-jian-dan-yi-dong-3qwel/

:::

### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

 +++info 示例

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

+++

:::info no-icon

回忆 最小栈 ，其使用 单调栈 实现了随意入栈、出栈情况下的 O(1) 时间获取 “栈内最小值” 。本题同理，不同点在于 “出栈操作” 删除的是 “列表尾部元素” ，而 “窗口滑动” 删除的是 “列表首部元素” 。

窗口对应的数据结构为 双端队列 ，本题使用 单调队列 即可解决以上问题。遍历数组时，每轮保证单调队列 deque ：

1. deque 内 仅包含窗口内的元素 ⇒ 每轮窗口滑动移除了元素 nums[i−1] ，需将 deque 内的对应元素一起删除。
2.  deque 内的元素 非严格递减 ⇒ 每轮窗口滑动添加了元素 nums[j+1] ，需将 deque 内所有 <nums[j+1] 的元素删除。

算法流程：

1. 初始化： 双端队列 deque ，结果列表 res ，数组长度 n ；

2. 滑动窗口： 左边界范围 i∈[1−k,n−k] ，右边界范围 j∈[0,n−1] 
   + 若 i>0 且 队首元素 deque[0] = 被删除元素 nums[i−1] ：则队首元素出队；
   + 删除 deque 内所有 <nums[j] 的元素，以保持 deque 递减；
   + 将 nums[j] 添加至 deque 尾部；
   + 若已形成窗口（即 i≥0 ）：将窗口最大值（即队首元素 deque[0] ）添加至列表 res ；
3. 返回值： 返回结果列表 res ；

```python
def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        # if n < k:return []
        # elif n == k :return [max(nums)]
        deque = []
        result = []

        for right in range(n):
            left = right - k + 1
            if left > 0 and deque[0] == nums[left-1]:
                deque.pop(0)
            while deque and deque[-1] < nums[right]:
                deque.pop(-1)
            deque.append(nums[right])
            if left >= 0:
                result.append(deque[0])
        return result
```



作者：Krahets
链接：https://leetcode.cn/problems/sliding-window-maximum/solutions/2361228/239-hua-dong-chuang-kou-zui-da-zhi-dan-d-u6h0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

:::



### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

 

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

 +++info 示例

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
解释：整个字符串 s 是最小覆盖子串。
```

**示例 3:**

```
输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
```

+++

:::info no-icon

1. 初始化 ansLeft=−1, ansRight=m，用来记录最短子串的左右端点，其中 m 是 s 的长度。
2. 用一个哈希表（或者数组）cntT 统计 t 中每个字母的出现次数。
3. 初始化 left=0，以及一个空哈希表（或者数组）cntS，用来统计 s 子串中每个字母的出现次数。
4. 初始化 less 为 t 中的不同字母个数。
5. 遍历 s，设当前枚举的子串右端点为 right，把字母 c=s[right] 的出现次数加一。加一后，如果 cntS[c]=cntT[c]，说明 c 的出现次数满足要求，把 less 减一。
6. 如果 less=0，说明 cntS 中的每个字母及其出现次数都大于等于 cntT 中的字母出现次数，那么：
   + 如果 right−left<ansRight−ansLeft，说明我们找到了更短的子串，更新 ansLeft=left, ansRight=right。
   + 把字母 x=s[left] 的出现次数减一。减一前，如果 cntS[x]=cntT[x]，说明 x 的出现次数不满足要求，把 less 加一。
   + 左端点右移，即 left 加一。
   + 重复上述三步，直到 less>0，即 cntS 有字母的出现次数小于 cntT 中该字母的出现次数为止。
7. 最后，如果 ansLeft<0，说明没有找到符合要求的子串，返回空字符串，否则返回下标 ansLeft 到下标 ansRight 之间的子串。

代码实现时，可以把 cntS 和 cntT 合并成一个 cnt，定义

$$cnt[x]=cntT[x]−cntS[x]$$
如果 cnt[x]=0，就意味着窗口内字母 x 的出现次数和 t 的一样多。

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        cnt = collections.defaultdict(int)
        for c in t:
            cnt[c] += 1
        count = len(cnt)
        res_left, res_right = -1, len(s)
        left = 0
        for right, c in enumerate(s):
            cnt[c] -= 1
            if cnt[c] == 0:
                count -= 1
            while count == 0:
                if right-left < res_right-res_left:
                    res_left, res_right = left, right
                if cnt[s[left]] == 0:
                    count += 1
                cnt[s[left]] += 1
                left += 1
        return '' if res_left<0 else s[res_left: res_right+1]
        
        
```



作者：灵茶山艾府
链接：https://leetcode.cn/problems/minimum-window-substring/solutions/2713911/liang-chong-fang-fa-cong-o52mn-dao-omnfu-3ezz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





:::









## 前缀和

### [724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

+++info 示例

**示例 1：**

```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
```

**示例 2：**

```
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```

**示例 3：**

```
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
```

+++

:::info no-icon

设 nums 的元素之和为 s。

设中心下标为 i，其左侧元素和为 $leftS=nums[0]+nums[1]+⋯+nums[i−1]$，那么右侧元素和为 $s−nums[i]−leftS$。

由于左侧元素和等于右侧元素和，所以有

$$leftS=s−nums[i]−leftS$$
即

$$2⋅leftS=s−nums[i]$$
从左到右遍历数组，一边遍历，一边累加元素更新 leftS。每次累加前，检查是否满足上式，满足则返回 i。

如果不存在这样的 i，返回 −1。

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        s = sum(nums)
        sum_left = 0
        for i, num in enumerate(nums):
            if 2*sum_left == s - num:
                return i
            sum_left += num
        return -1
```

作者：灵茶山艾府
链接：https://leetcode.cn/problems/find-pivot-index/solutions/2834687/jian-ji-xie-fa-o1-e-wai-kong-jian-python-tz0p/

:::

### [2352. 相等行列对](https://leetcode.cn/problems/equal-row-and-column-pairs/)

给你一个下标从 **0** 开始、大小为 `n x n` 的整数矩阵 `grid` ，返回满足 `Ri` 行和 `Cj` 列相等的行列对 `(Ri, Cj)` 的数目*。*

如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。

::: info no-icon

用哈希表统计每行出现的次数，然后遍历列，累加哈希表中列出现的次数。



作者：灵茶山艾府
链接：https://leetcode.cn/problems/equal-row-and-column-pairs/solutions/1694047/ha-xi-biao-python-liang-xing-by-endlessc-ljae/

;;;id2 Demo 1

```python
class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        cnt = Counter(tuple(row) for row in grid)
        return sum(cnt[col] for col in zip(*grid))

```

;;;

;;;id2 Demo2

```python
class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        n = len(grid)
        count = {}
        result = 0
        for i in range(n):
            count[tuple(grid[i])] = count.get(tuple(grid[i]), 0) + 1
        print(count)
        for j in zip(*grid):
            print(j)
            result += count.get(j,0)
            # print(grid[:][j], grid[j][:])
        return result
```

;;;

:::

### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

 +++info 示例

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

+++

:::info no-icon

**转化**
回顾 303 题的前缀和的定义：s[0]=0, s[i]=nums[0]+nums[1]+⋯+nums[i−1]。注意 s 是一个长为 n+1 的数组，第一项一定是 0。

设 i<j，如果 nums[i] 到 nums[j−1] 的元素和等于 k，用前缀和表示，就是

$$s[j]−s[i]=k$$
问题转化为：

+ s 中有多少对下标 (i,j) 满足 i<j 且 s[j]−s[i]=k？

写成 s[j]+(−s[i])=k 就能看得更明白，这是梦开始的地方——1. 两数之和。不过那题只需找到一对下标，而本题需要计算所有满足条件的下标对的个数。

**枚举右，维护左**
以 nums=[1,1,−1,1,−1]，k=1 为例，其前缀和数组为 s=[0,1,2,1,2,1]。

如果用二重循环暴力枚举有多少个 s[j]−s[i]=k，时间复杂度是 O($n^2$)，太慢了。如何加速？

从两数之和中，我们可以学到什么？我们可以把 s[j]−s[i]=k 移项，得

$$s[i]=s[j]−k$$
遍历 s，一边枚举右边的 j，一边用哈希表统计左边有多少个 i 满足 i<j 且 s[i]=s[j]−k。

比如 s[j]=2，那么 s[i]=s[j]−k=2−1=1，我们要找的是 j 左边有多少个 s[i]=1。在上面的例子中，遍历到 s[4]=2 时，我们知道左边有 2 个 s[i]=1，所以新找到了 2 个和为 1 的子数组。

```python
def subarraySum(self, nums: List[int], k: int) -> int:
        n = len(nums)
        sums = 0
        ht = collections.defaultdict(int)
        ht[0] = 1
        result = 0
        for i in range(n):
            sums += nums[i]
            cnt = sums - k
            result += ht[cnt]
            ht[sums] += 1 
        return result
```



作者：灵茶山艾府
链接：https://leetcode.cn/problems/subarray-sum-equals-k/solutions/2781031/qian-zhui-he-ha-xi-biao-cong-liang-ci-bi-4mwr/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



:::





## 栈与队列

### [735. 小行星碰撞](https://leetcode.cn/problems/asteroid-collision/)

给定一个整数数组 `asteroids`，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。

对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。

找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。

+++info 示例

**示例 1：**

```
输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
```

**示例 2：**

```
输入：asteroids = [8,-8]
输出：[]
解释：8 和 -8 碰撞后，两者都发生爆炸。
```

**示例 3：**

```
输入：asteroids = [10,2,-5]
输出：[10]
解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。
```

+++

:::info no-icon

这道栈的题目难点应该主要是在分析场景上了。
我们需要明确什么时候无脑入栈，什么时候需要判断，理解这两点就可以轻松解题了。
首先，循环每一个元素时，在什么情况下无脑入栈呢？

栈为空
栈顶元素为负数(下一个为负数则一起向左，下一个为正数则分向两边)
当前元素为正数（栈顶为正一起向右，栈顶为负分向两边）
下来，我们需要看碰撞的场景又细分为什么情况：

栈顶元素大于abs(当前元素)，当前元素被撞毁
栈顶元素等于abs(当前元素)，栈顶弹出和当前元素抵消
栈顶元素小于abs(当前元素)，栈顶弹出，并与新栈顶完成上述判断
最终返回栈即可。

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack, index = [], 0
        while index < len(asteroids):
            ast = asteroids[index]
            if ast > 0 or len(stack)==0 or stack[-1]<0: stack.append(ast)
            elif stack[-1] <= - ast:
                if stack.pop(-1) < - ast:
                    continue
            index += 1
        return stack
```

作者：清风Python
链接：https://leetcode.cn/problems/asteroid-collision/solutions/994100/735xing-xing-peng-zhuang-ji-yu-zhan-qu-f-xpd1/

:::

### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

测试用例保证输出的长度不会超过 `105`。

+++info 示例

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**示例 4：**

```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

+++

:::info no-icon

+ 本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。

+ 算法流程：

  + 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；

    + 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；

    + 当 c 为字母时，在 res 尾部添加 c；

    + 当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：
      记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；
      记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。
      进入到新 [ 后，res 和 multi 重新记录。

    + 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:
      + last_res是上个 [ 到当前 [ 的字符串，例如 "3[a2[c]]" 中的 a；
      + cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 "3[a2[c]]" 中的 2。

  + 返回字符串 res。

```python
class Solution:
    def decodeString(self, s: str) -> str:
        result = ''
        stack = []
        res, num = '', 0
        for c in s:
            if c == '[':
                stack.append((res, num))
                res, num = '', 0
            elif c == ']':
                out_res, out_num = stack.pop()
                res = out_res + out_num*res
            elif '0'<= c <= '9':
                num = num*10 + int(c)
            else:
                res += c
        return res
```

作者：Krahets
链接：https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/

:::

### [649. Dota2 参议院](https://leetcode.cn/problems/dota2-senate/)

Dota2 的世界里有两个阵营：`Radiant`（天辉）和 `Dire`（夜魇）

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 **一** 项：

- **禁止一名参议员的权利**：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 **所有的权利** 。
- **宣布胜利**：如果参议员发现有权利投票的参议员都是 **同一个阵营的** ，他可以宣布胜利并决定在游戏中的有关变化。

给你一个字符串 `senate` 代表每个参议员的阵营。字母 `'R'` 和 `'D'`分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `"Radiant"` 或 `"Dire"` 。

+++info 示例

**示例 1：**

```
输入：senate = "RD"
输出："Radiant"
解释：
第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。
这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。
第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。
```

**示例 2：**

```
输入：senate = "RDD"
输出："Dire"
解释：
第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。
这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。
这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
```

+++

:::info no-icon

这道题模拟了一个游戏过程，最终当有权利投票的参议员都是 同一个阵营的 ，这个阵营即获胜。

那么两个阵营的每个参议员为了获胜，当他拥有权力的时候，一定是会将自己之后首个对立阵营的参议员的权力禁止掉。【这就是每一位参议会为自己的政党做出最好的策略】。请注意：当之后没有对立阵营的参议员的时候，相当于将之前的参议员加到其之后。

![500](2025-08-15-Leetcode/649-01.png)

![500](2025-08-15-Leetcode/649-02.png)

![500](2025-08-15-Leetcode/649-03.png)

![500](2025-08-15-Leetcode/649-04.png)

![500](2025-08-15-Leetcode/649-05.png)

```python
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiants, dires = [], []
        n = len(senate)
        for i, se in enumerate(senate):
            if se == 'R': radiants.append(i)
            else: dires.append(i)
        while radiants and dires:
            if radiants[0] < dires[0]:
                dires.pop(0)
                radiants.append(radiants.pop(0) + n)
            else:
                radiants.pop(0)
                dires.append(dires.pop(0) + n)
        return "Radiant" if radiants else 'Dire'
        
```



作者：画图小匠
链接：https://leetcode.cn/problems/dota2-senate/solutions/2862115/javapython3cdui-lie-mo-ni-jin-zhi-zhi-ho-l4pb/

:::

## 链表

:::info no-icon

1. 找中间节点：快慢指针

+ 中间值左侧：需要加一个dummy节点。

  ```python
  dummy = ListNode(0, head)
  slow, fast = dummy, dummy
  while fast and fast.next:
      fast = fast.next.next
      if not fast: break
      slow = slow.next
  ```

+ 中间值右侧：直接从head开始

  ```python
  slow, fast = head, head
  while fast and fast.next:
      fast = fast.next.next
      if not fast: break
      slow = slow.next
  ```

  

:::

### [2095. 删除链表的中间节点](https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/)

给你一个链表的头节点 `head` 。**删除** 链表的 **中间节点** ，并返回修改后的链表的头节点 `head` 。

长度为 `n` 链表的中间节点是从头数起第 `⌊n / 2⌋` 个节点（下标从 **0** 开始），其中 `⌊x⌋` 表示小于或等于 `x` 的最大整数。

- 对于 `n` = `1`、`2`、`3`、`4` 和 `5` 的情况，中间节点的下标分别是 `0`、`1`、`1`、`2` 和 `2` 。

 :::info no-icon

本题可遍历计数先得到 n，再遍历一次删除指定节点即可，这很简单。本篇讲的是快慢指针这种方法。

我们令 fast 和 slow 这两个指针同时前进，fast 每次移动两格，slow 每次移动一格，在检测到 `fast.next == null` 或者 `fast.next.next == null` 时退出循环。

引入一个哑巴节点 dummy 便于处理，考虑循环停止时的场景。
为方便考虑，本篇题解认为原链表下标从 1 开始，需要删除第 $⌊\frac{n}{2}⌋+1$ 个节点。

+ 如果 *n* 为偶数，如下所示。设 *n*=2*k*，fast 停在第 2*k* 个节点，slow 停在第 *k* 即 $⌊\frac{n}{2}⌋$ 个节点。

![300](2025-08-15-Leetcode/2095-01.png)

+ 如果 *n* 为奇数，如下所示，设 *n*=2*k*+1。fast 停在第 2*k* 个节点，slow 停在第 *k* 即 $⌊\frac{n}{2}⌋$ 个节点。

![300](2025-08-15-Leetcode/2095-02.png)

所以退出循环时 slow 一定停在 $⌊\frac{n}{2}⌋$ 个节点，令 `slow.next = slow.next.next` 即删除了 $⌊\frac{n}{2}⌋+1$ 个节点。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        zero = ListNode(0, head)
        slow, fast = zero, zero
        while fast and fast.next:
            fast = fast.next.next
            if not fast: break
            slow = slow.next
        slow.next = slow.next.next
        return zero.next

        
```

作者：Shawxing精讲算法
链接：https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solutions/2844229/jian-ming-yan-jin-de-kuai-man-zhi-zhen-f-84sx/

:::

### [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)

给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。

**第一个**节点的索引被认为是 **奇数** ， **第二个**节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

:::info no-icon

如果链表为空，则直接返回链表。

对于原始链表，每个节点都是奇数节点或偶数节点。头节点是奇数节点，头节点的后一个节点是偶数节点，相邻节点的奇偶性不同。因此可以将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。

原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead = head.next，则 evenHead 是偶数链表的头节点。

维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd = head，even = evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。

+ 更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next = even.next，然后令 odd = odd.next，此时 odd 变成 even 的后一个节点。

+ 更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next = odd.next，然后令 even = even.next，此时 even 变成 odd 的后一个节点。

![400](2025-08-15-Leetcode/328-01.png)

![400](2025-08-15-Leetcode/328-02.png)

![400](2025-08-15-Leetcode/328-03.png)

![400](2025-08-15-Leetcode/328-04.png)

在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。

最后令 odd.next = evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head: return head
        even_head = head.next
        odd, even = head, even_head
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = even_head
        return head
```

作者：力扣官方题解
链接：https://leetcode.cn/problems/odd-even-linked-list/solutions/482737/qi-ou-lian-biao-by-leetcode-solution/

:::

### [2130. 链表最大孪生和](https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/)

在一个大小为 `n` 且 `n` 为 **偶数** 的链表中，对于 `0 <= i <= (n / 2) - 1` 的 `i` ，第 `i` 个节点（下标从 **0** 开始）的孪生节点为第 `(n-1-i)` 个节点 。

- 比方说，`n = 4` 那么节点 `0` 是节点 `3` 的孪生节点，节点 `1` 是节点 `2` 的孪生节点。这是长度为 `n = 4` 的链表中所有的孪生节点。

**孪生和** 定义为一个节点和它孪生节点两者值之和。

给你一个长度为偶数的链表的头节点 `head` ，请你返回链表的 **最大孪生和** 。

 +++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/2130-01.png)

```
输入：head = [5,4,2,1]
输出：6
解释：
节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。
链表中没有其他孪生节点。
所以，链表的最大孪生和是 6 。
```

**示例 2：**

![300](2025-08-15-Leetcode/2130-02.png)

```
输入：head = [4,2,2,3]
输出：7
解释：
链表中的孪生节点为：
- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。
- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。
所以，最大孪生和为 max(7, 4) = 7 。
```

+++

:::info no-icon

**核心思想：寻找链表中间值**

以下两种方法的快慢指针有所不同，参见[链表](#链表)。

;;;id3 快慢指针+反转链表

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        mid = self.middleNode(head)
        head2 = self.reverseNode(mid)
        result = -inf
        while head2:
            result = max(result, head.val + head2.val)
            head = head.next
            head2 = head2.next
        return result

    def reverseNode(self, head):
        cur, pre = head, None
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
        
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
        
```

;;;

;;;id3 快慢指针+入栈

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        dummy = ListNode(next=head)
        slow, fast = dummy, dummy
        stack = []
        result = -inf
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            stack.append(slow.val)
        print(slow.val)
        while slow.next:
            slow = slow.next
            result = max(result, stack.pop(-1)+slow.val)
        return result
        
```

;;;

:::

### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![300](2025-08-15-Leetcode/160-01.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

:::info no-icon

![300](2025-08-15-Leetcode/160-02.png)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        A, B = headA, headB
        while A != B :
            A = A.next if A else headB
            B = B.next if B else headA
        return B
        
```

:::

### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

+++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/206-01.png)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**

![300](2025-08-15-Leetcode/206-02.png)

```
输入：head = [1,2]
输出：[2,1]
```

+++

:::info no-icon

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        cur_p, pre_p = head, None
        while cur_p:
            next_p = cur_p.next
            cur_p.next = pre_p
            pre_p = cur_p
            cur_p = next_p
        return pre_p
```

:::



### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

 +++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/138-01.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

+++







## 二叉树

:::info no-icon

1. [看到递归就晕？带你理解递归的本质！【基础算法精讲 09】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1UD4y1Y769/?vd_source=9b05037c77ec940dae3af8e69969e0d6)



:::



### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

+++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/226-01.png)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![300](2025-08-15-Leetcode/226-02.png)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

+++

:::info no-icon

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return root
        left = self.invertTree(root.left)
        right = self.invertTree(root.right)
        root.left = right
        root.right = left
        return root
```

:::

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 +++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/101-01.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

+++

:::info no-icon

判断核心是从上到下，重点是判断出不符合对称的情况，如果符合就持续深层判断直到根节点。

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root: return True
        def dfs(left, right):
            if not left and not right:
                return True
            elif not (left and right):
                return False
            else:
                if left.val != right.val:
                    return False
            return dfs(left.left, right.right) and dfs(left.right, right.left)
        return dfs(root.left, root.right)
```

:::

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

 :::info no-icon

**方法一：前序遍历**

*dfs* 额外传入两个参数，分别表示从根到当前节点路径上的最小值和最大值。当前节点的值必须在最小值和最大值之间（不能等于）。

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode], left = -inf, right = inf) -> bool:
        if not root:return True
        x = root.val
        if x >= right or x <= left: return False
        return self.isValidBST(root.left, left, x) and self.isValidBST(root.right, x, right)
```

**方法二：中序遍历**
本题是二叉搜索树，中序遍历是自然的做法。

中序遍历时，可以把二叉搜索树看成一个有序数组。

怎么判断一个数组是有序数组？比较相邻元素的大小即可。

```python
class Solution:
    pre = -inf
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if root is None:
            return True
        if not self.isValidBST(root.left):  # 左
            return False
        if root.val <= self.pre:  # 中
            return False
        self.pre = root.val
        return self.isValidBST(root.right)  # 右

```

**方法三：后序遍历**

*dfs* 返回子树的最小值和最大值，供上面的节点判断是否为二叉搜索树。

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        def dfs(node: Optional[TreeNode]) -> Tuple:
            if node is None:
                return inf, -inf
            l_min, l_max = dfs(node.left)
            r_min, r_max = dfs(node.right)
            x = node.val
            # 也可以在递归完左子树之后立刻判断，如果发现不是二叉搜索树，就不用递归右子树了
            if x <= l_max or x >= r_min:
                return -inf, inf
            return min(l_min, x), max(r_max, x)
        return dfs(root)[1] != inf
```

作者：灵茶山艾府
链接：https://leetcode.cn/problems/validate-binary-search-tree/solutions/2020306/qian-xu-zhong-xu-hou-xu-san-chong-fang-f-yxvh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

:::

### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 +++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/114-01.png)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

+++

:::info no-icon



```python
class Solution:
    head = None
    def flatten(self, root: Optional[TreeNode]) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        if not root:return root
        self.flatten(root.right)
        self.flatten(root.left)
        root.left = None
        root.right = self.head
        self.head = root
```

:::





### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)（与[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)方法相似）

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

+++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/437-01.png)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

+++

:::info no-icon

如果二叉树是一条链，本题就和 560. 和为 K 的子数组 完全一样了：统计有多少个非空连续子数组的元素和恰好等于 targetSum。所以你必须先弄明白 560 题（特殊情况），再来做本题（一般情况）。560 题的做法见 我的题解。

这两题的联系如下：

| 560 题                                     | 本题                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 连续子数组                                 | 方向向下的路径                                               |
| 前缀                                       | 从根节点开始的路径                                           |
| 做法：枚举子数组右端点，统计有多少个左端点 | 做法：枚举路径的终点，统计有多少个起点<br/>我们要解决的问题是：DFS 遍历这棵树，遍历到节点 node 时，假设 node 是路径的终点，那么有多少个起点，满足起点到终点 node 的路径总和恰好等于 targetSum？ |

和 560 题一样的套路：一边遍历二叉树，一边用哈希表 cnt 统计前缀和（从根节点开始的路径和）的出现次数。设从根到终点 node 的路径和为 s，那么起点的个数就是 cnt[s−targetSum]，加入答案。对比 560 题，我们在枚举子数组的右端点（终点），统计有多少个左端点（起点），做法完全一致。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        ans = 0
        hp = collections.defaultdict(int)
        hp[0] = 1
        def dfs(node, s):
            if not node: return 
            nonlocal ans
            s += node.val
            ans += hp[s - targetSum]

            hp[s] += 1
            dfs(node.left, s)
            dfs(node.right, s)
            hp[s] -= 1
        dfs(root, 0)
        return ans
```

作者：灵茶山艾府
链接：https://leetcode.cn/problems/path-sum-iii/solutions/2784856/zuo-fa-he-560-ti-shi-yi-yang-de-pythonja-fmzo/

:::

### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)（与[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)相似）

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

 +++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/124-02.png)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![300](2025-08-15-Leetcode/124-01.png)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

+++

:::info no-icon

```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        max_result = -inf
        def max_(a,b,c):
            d = max(a,b)
            return max(d,c)

        def dfs(root):
            if not root: return 0
            left, right = dfs(root.left), dfs(root.right)
            node_max = root.val
            if left > 0: node_max += left
            if right > 0: node_max += right
            nonlocal max_result
            max_result = max(max_result, node_max)
            return root.val + max_(left, right, 0)
        dfs(root)
        return max_result
```

+++info [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

![300](2025-08-15-Leetcode/124-03.png)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        max_result = 0
        def dfs(root):
            if not root:
                return 0
            left, right = dfs(root.left), dfs(root.right)
            result = left + right + 1
            nonlocal max_result
            max_result = max(max_result, result)
            return max(left, right) + 1
        dfs(root)
        return max_result - 1
```



+++



:::







### [1372. 二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)

给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：

- 选择二叉树中 **任意** 节点和一个方向（左或者右）。
- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
- 改变前进方向：左变右或者右变左。
- 重复第二步和第三步，直到你在树中无法继续移动。

交错路径的长度定义为：**访问过的节点数目 - 1**（单个节点的路径长度为 0 ）。

请你返回给定树中最长 **交错路径** 的长度。

+++info 示例

**示例 1：**

![100](2025-08-15-Leetcode/1372-01.png)

```
输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
输出：3
解释：蓝色节点为树中最长交错路径（右 -> 左 -> 右）。
```

**示例 2：**

![100](2025-08-15-Leetcode/1372-02.png)

```
输入：root = [1,1,1,null,1,null,null,1,1,null,1]
输出：4
解释：蓝色节点为树中最长交错路径（左 -> 右 -> 左 -> 右）。
```

+++

:::info no-icon

在 DFS 的过程中，每次我们都把当前点的 len 参数和答案 maxAns 打擂台，这样可以比出一个最大的。然后我们根据 dir 分类讨论。如果当前点应该向左且可以向左，那么就让他向左走一步，新的 len 是当前的 len 加一。如果的的点应该向左但是却没有左子树呢？很无奈那就只能向右了，这个时候 len 的值应该「重置」。

思考：「重置」为什么是把 len 变成 1 而不是 0？ 因为当前的点下传到它的子节点的时候已经走了一条长度为 1 的边。那么为什么 main 函数中传入的 len 值是 0 而不是 1 呢？ 因为 main 函数中的 root 是没有父亲节点的，所以当前已经走过的路为 0。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        result = 0
        def search(node, mode, l):
            if not node:return 
            nonlocal result
            result = max(result, l)
            if mode == 'left': 
                search(node.right, 'right',l+1)
                search(node.left, 'left', 1)
            elif mode == 'right': 
                search(node.left, 'left', l+1)
                search(node.right, 'right', 1)
        search(root,'left', 0)
        search(root, 'right', 0)
        return result
```

作者：力扣官方题解
链接：https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/solutions/147425/er-cha-shu-zhong-de-zui-chang-jiao-cuo-lu-jing-b-2/

:::

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 +++info 示例

**示例 1：**

![200](2025-08-15-Leetcode/236-01.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![200](2025-08-15-Leetcode/236-02.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

+++

:::info no-icon

[二叉树的最近公共祖先【基础算法精讲 12】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1W44y1Z7AR/?vd_source=9b05037c77ec940dae3af8e69969e0d6)

![500](2025-08-15-Leetcode/236-03.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root == None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if right and left: return root
        return left or right
        
```

+++info 补充理解

基于灵神的题解，我加了一些自己的解释说明。

见 [我的补充题解](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3669565/ling-shen-ti-jie-de-jian-dan-jie-shi-by-jmxxr/)。

不好理解，是因为灵神代码复用了 lowestCommonAncestor 方法做递归。

但是从字面代码看，语义更接近于 find_p_or_q 才对。
改个名字，稍加注释后，似乎一切都说得通了。

在题目限制条件下（有解且唯一，且节点 unique），find_p_or_q 等价于 find_LCA，是关键所在。

改名 & 加注释后代码：

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        def find_p_or_q(_r, _p, _q) -> tuple[bool, bool]:
            # (1) 因为有解且唯一，所以递归过程类似于寻找 p 或 q。
            if not _r:
                return False
            elif _r.val == _p.val or _r.val == _q.val:
                # (2) 自顶向下查找，找到一个匹配的立即返回即可（因为题目一定有解）
                return _r
            else:
                _lret = find_p_or_q(_r.left, _p, _q)
                _rret = find_p_or_q(_r.right, _p, _q)
                if _lret and _rret:
                    # (3) 都有的情况，应该是一左一右，所以父节点是 lca
                    return _r
                else:
                    return _lret or _rret

        return find_p_or_q(root, p, q)
```

+++

:::

### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

+++info 示例

**示例 1：**

**输入：** root = [1,2,3,null,5,null,4]

**输出：**[1,3,4]

**解释：**

![300](2025-08-15-Leetcode/199-01.png)

**示例 2：**

**输入：** root = [1,2,3,4,null,null,null,5]

**输出：**[1,3,4,5]

**解释：**

![300](2025-08-15-Leetcode/199-02.png)

**示例 3：**

**输入：** root = [1,null,3]

**输出：**[1,3]

+++

:::info no-icon

;;;id4 深度优先算法

**视频讲解**：[【基础算法精讲 10】](https://www.bilibili.com/video/BV18M411z7bb/)

**思路**：先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        def dfs(root, depth):
            if not root: return 
            if depth == len(result):
                result.append(root.val)
            dfs(root.right, depth + 1)
            dfs(root.left, depth + 1)
        dfs(root, 0)
        return result
```

作者：灵茶山艾府
链接：https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/

;;;

;;;id4 层序遍历

**思路**：将每层的元素加入队列，从右到左依序遍历每层。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root: return []
        result = []
        que = [root]
        while len(que) > 0:
            result.append(que[0].val)
            for _ in range(len(que)):
                node = que.pop(0)
                if node.right: que.append(node.right)
                if node.left: que.append(node.left)
        return result
```

;;;

:::



### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

+++info 示例

**示例 1:**

![300](2025-08-15-Leetcode/450-01.png)

```
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```

**示例 2:**

![300](2025-08-15-Leetcode/450-02.png)

```
输入: root = [5,3,6,2,4,null,7], key = 0
输出: [5,3,6,2,4,null,7]
解释: 二叉树不包含值为 0 的节点
```

+++

:::info no-icon

[视频解析]([【LeetCode75】第四十二题 删除二叉搜索树中的节点_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Ru4y1C72d/?spm_id_from=333.337.search-card.all.click&vd_source=9b05037c77ec940dae3af8e69969e0d6))

二叉搜索树的题目往往可以用递归来解决。此题要求删除二叉树的节点，函数 deleteNode 的输入是二叉树的根节点 root 和一个整数 key，输出是删除值为 key 的节点后的二叉树，并保持二叉树的有序性。可以按照以下情况分类讨论：

+ root 为空，代表未搜索到值为 key 的节点，返回空。
+ root.val>key，表示值为 key 的节点可能存在于 root 的左子树中，需要递归地在 root.left 调用 deleteNode，并返回 root。
+ root.val<key，表示值为 key 的节点可能存在于 root 的右子树中，需要递归地在 root.right 调用 deleteNode，并返回 root。
+ root.val=key，root 即为要删除的节点。此时要做的是删除 root，并将它的子树合并成一棵子树，保持有序性，并返回根节点。根据 root 的子树情况分成以下情况讨论：
  + root 为叶子节点，没有子树。此时可以直接将它删除，即返回空。
  + root 只有左子树，没有右子树。此时可以将它的左子树作为新的子树，返回它的左子节点。
  + root 只有右子树，没有左子树。此时可以将它的右子树作为新的子树，返回它的右子节点。
  + root 有左右子树。此时可以把右子树接到左子树中（通过循环找到左子树的最右叶子，插在这个叶子上作为右子树，因为root的右子树必然比左子树的任意值大）。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:
        if not root: return 
        if root.val == key:
            if not root.left and not root.right: return 
            elif not root.left: return root.right
            elif not root.right: return root.left
            else:
                node = root.left
                while node.right: node = node.right
                node.right = root.right
                root = root.left
        elif root.val > key: root.left = self.deleteNode(root.left, key)
        elif root.val < key: root.right = self.deleteNode(root.right, key)
        return root
```

作者：力扣官方题解
链接：https://leetcode.cn/problems/delete-node-in-a-bst/solutions/1529700/shan-chu-er-cha-sou-suo-shu-zhong-de-jie-n6vo/

:::



## 二分查找

### [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

+++info 示例

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2：**

```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

+++



:::info no-icon

定理：如果 i<n−1 且 nums[i]<nums[i+1]，那么在下标 [i+1,n−1] 中一定存在峰值。

证明：反证法，假设下标 [i+1,n−1] 中没有峰值。

由于 i+1 不是峰值且 nums[i]<nums[i+1]，所以一定有 nums[i+1]<nums[i+2] 成立，否则 i+1 就是峰值了。注意题目保证相邻元素不同，不存在相邻元素相等的情况。
由于 i+2 不是峰值且 nums[i+1]<nums[i+2]，所以一定有 nums[i+2]<nums[i+3] 成立，否则 i+2 就是峰值了。
依此类推，得
nums[i]<nums[i+1]<nums[i+2]<⋯<nums[n−1]>nums[n]=−∞
这意味着 nums[n−1] 是峰值，矛盾，所以原命题成立。
同理可得，如果 i<n−1 且 nums[i]>nums[i+1]，那么在 [0,i] 中一定存在峰值。

所以，通过比较 nums[i] 和 nums[i+1] 的大小关系，不断地缩小存在峰值的范围，二分找到峰值。

```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left, right = -1, len(nums)-1
        while right > left+1:
            mid = (right + left) // 2
            if nums[mid] < nums[mid+1]:
                left = mid
            else:
                right = mid
        return right
```



作者：灵茶山艾府
链接：https://leetcode.cn/problems/find-peak-element/solutions/1987497/by-endlesscheng-9ass/





:::



























