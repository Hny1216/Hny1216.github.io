---
title: Leetcode刷题记录
math: true
fancybox: true
date: 2025-08-15
categories:
- 技能工具
---

Leetcode刷题记录

<!-- more -->

# Leetcode刷题

## 数组/字符串

### [1071. 字符串的最大公因子](https://leetcode.cn/problems/greatest-common-divisor-of-strings/)

对于字符串 `s` 和 `t`，只有在 `s = t + t + t + ... + t + t`（`t` 自身连接 1 次或多次）时，我们才认定 “`t` 能除尽 `s`”。

给定两个字符串 `str1` 和 `str2` 。返回 *最长字符串 `x`，要求满足 `x` 能除尽 `str1` 且 `x` 能除尽 `str2`* 。

:::info no-icon

若两个字符串是由同一个字符串 X重复拼接而成，那么无论先拼哪个，结果应该相同。
如果 str1 + str2 != str2 +str1，说明不存在公共的重复因子，直接返回空串 ""。
如果两个字符串都是由同一个字符串 X 组成，那么 X 的长度必然是str1.size()和 str2.size() 的最大公约数。

作者：Random
链接：https://leetcode.cn/problems/greatest-common-divisor-of-strings/solutions/3749891/shu-xue-zui-da-gong-yue-shu-by-coder-ran-a88u/

:::

```python
class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        if not str1 + str2 == str2 + str1:
            return ""
        return str1[0:self.gcd(len(str1), len(str2))]
    
    def gcd(self, a,b):
        if b == 0: return a
        else: return gcd(b, a%b)
    
```



### [605. 种花问题](https://leetcode.cn/problems/can-place-flowers/)

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false` 。

:::info no-icon

从左到右遍历数组，能种花就立刻种花。

如何判断能否种花？由于「花不能种植在相邻的地块上」，如果要在下标 i 处种花，需要满足 flowerbed[i−1],flowerbed[i],flowerbed[i+1] 均为 0。

每种一朵花，就把 n 减一。如果最后 n≤0，则返回 true，否则返回 false。

为了简化判断逻辑，可以在数组的开头和末尾各插入一个 0。

作者：灵茶山艾府
链接：https://leetcode.cn/problems/can-place-flowers/solutions/2463018/ben-ti-zui-jian-dan-xie-fa-pythonjavacgo-6a6k/

:::

```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
      nums = len(flowerbed)
      new_flowerbed = [0] + flowerbed + [0]
      for i in range(1,len(new_flowerbed)-1):
        if new_flowerbed[i-1] == 0 and new_flowerbed[i+1] == 0 and new_flowerbed[i] == 0:
          new_flowerbed[i] = 1
          n -= 1
      return n <= 0

```



### [334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `3` 的递增子序列。

如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。

:::info no-icon

;;;id1 巧解

核心想法：遍历一遍数组，希望遍历到的这个数three，前面已经有一个比他小的数two，再前面有一个比two小的数one。
我们需要维护两个变量：one和two。代表递增子序列的第一个数和第二个数。
假设我们已经有了这两个数，那么three的大小有以下三种情况：

1. **three大于two**    此情况下：即找到了三元组，直接返回true。

   ![300](2025-08-15-Leetcode/334-01.png)

2. **three介于two和one之间**     此情况下：应更新two，赋值为这个更小的值。这相当于帮我们扩大了three的可选择范围，当再次遇到一个比更新过的two大的数即可找到。

   ![300](2025-08-15-Leetcode/334-02.png)

   ![300](2025-08-15-Leetcode/334-03.png)

3. **three小于one**     此情况下：应更新one，赋值为这个更小的值。而不需要动two。这相当于帮我们扩大了之后出现的two的可选择范围。进而扩大了之后出现的three的可选择范围。

![300](2025-08-15-Leetcode/334-04.png)

![300](2025-08-15-Leetcode/334-05.png)

![300](2025-08-15-Leetcode/334-06.png)

需要注意的是，我们只更新one，原先的two不需要更改，因为子序列是从前往后的，只有当之后再出现比two小的数的时候再按照第二步那样更改。

假设有如下示例：[2,5,1,6]，在遇到1之后更新了one，后遇到6，因为先判断是否大于two，由于6大于5，就直接返回true了。

![300](2025-08-15-Leetcode/334-07.png)

注意：two附带隐含信息——这之前有个数比two小
所以此时找到的递增子序列不是one、two、three的1 5 6，而是old one、two、three的2 5 6。

这里更新的one的意思是，为之后可能存在的更小的递增子序列打基础。
假设有如下示例：[2,5,1,2,6]，在遇到1之后更新了one，后遇到2，2介于1和5（two）之间，更新two为2，后遇到6，由于6大于2，返回true。
此时找到的递增子序列才是one、two、three的1 2 6

最后考虑one、two的初值，容易想到设定为Integer.MAX_VALUE即可。

作者：Xzz
链接：https://leetcode.cn/problems/increasing-triplet-subsequence/solutions/535725/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/

```python
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
      one, two = inf, inf
      for three in nums:
        if three > two : return True
        elif three <= one: one = three
        else: two = three
      return False
```



+++info 解析（GPT）

 **1. 递增三元组的性质**

假设数组中存在递增三元组 `a < b < c`，它们的顺序在数组中是 **前后顺序**，我们只关心：

- 第一个数最小
- 第二个数比第一个数大
- 第三个数比第二个数大

**关键点**：我们不需要知道三元组具体位置，只需要保证存在。

 **2. one 和 two 的作用**

- `one`：当前找到的**最小的候选第一个数**
- `two`：在 `one` 之后，找到的**最小的候选第二个数**

**核心思想**：

- 我们并不是在找数组中所有可能的三元组，而是在**维护最优候选序列**。
- “最优候选”意味着 **尽可能小的 one 和 two**，这样可以最大化出现第三个数 three 的机会。

换句话说：

1. 遍历到一个数 three：
   - 如果 three > two → 说明找到了一个合法三元组（不管前面 one/two 是不是更新过的，都会形成合法的递增序列）。
2. 如果 three <= one → 更新 one
   - 因为这个更小的 one 可以为之后出现的 two 提供更多可能。
3. 否则 → 更新 two
   - 因为这个更小的 two 可以为之后出现的 three 提供更多可能。

 **3. 为什么不会漏掉任何情况**

假设数组中有递增三元组 `x < y < z`，为什么算法一定能找到它？

- 当我们遍历到 x：
  - one 会被更新为 ≤ x
- 当我们遍历到 y：
  - two 会被更新为 ≤ y
- 当我们遍历到 z：
  - 如果 z > two → 返回 True

**关键点**：

- 即使 one/two 被后面更小的数更新过，**old one/two 仍然保留了前序信息**，保证当前 three 大于某个二元组时，必然能形成递增三元组。
- 换句话说，one/two 是动态维护的 **最小可能序列候选**，任何真正存在的递增三元组都会被捕获。





+++



;;;

;;;id1 常规

常规解法

;;;

:::



## 滑动窗口

### [1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)

给你两个长度相同的字符串，`s` 和 `t`。

将 `s` 中的第 `i` 个字符变到 `t` 中的第 `i` 个字符需要 `|s[i] - t[i]|` 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 `maxCost`。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 `s` 的子字符串转化为它在 `t` 中对应的子字符串，则返回可以转化的最大长度。

如果 `s` 中没有子字符串可以转化成 `t` 中对应的子字符串，则返回 `0`。

+++info 示例

**示例 1：**

```
输入：s = "abcd", t = "bcdf", maxCost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。
```

**示例 2：**

```
输入：s = "abcd", t = "cdef", maxCost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。
```

**示例 3：**

```
输入：s = "abcd", t = "acde", maxCost = 0
输出：1
解释：a -> a, cost = 0，字符串未发生变化，所以最大长度为 1。
```

+++

:::info no-icon

两个长度相等字符串的 s 和 t ，把 i 位置的 s[i] 转成 t[i] 的开销是两者 ASCII 码之差的绝对值。题目给出了允许的最大预算 maxCost ，求不超过预算的情况下能够转换的最长子串。

比如，对于 s = "abcd", t = "bcdf", cost = 3 而言，我们使用 costs[i] 表示从 s[i]  转成 t[i] 的开销，那么 costs = [1, 1, 1, 2] 。由于 maxCost = 3， 所以最多允许其前面三个字符进行转换。

于是题目变成了：**已知一个数组 costs ，求：和不超过 maxCost 时最长的子数组的长度**。

![300](2025-08-15-Leetcode/1208-01.png)

```python
class Solution:
    def equalSubstring(self, s: str, t: str, maxCost: int) -> int:
        n = len(s)
        left, right = 0, 0
        result = 0
        cost = 0
        while right < n:
            cost += abs(ord(s[right]) - ord(t[right]))
            while cost > maxCost:
                cost -= abs(ord(s[left]) - ord(t[left]))
                left += 1
                
            result = max(result, right - left + 1)
            right += 1
        return result

```



《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」，我觉得非常生动形象。因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。

+++info 滑动窗口问题模板

我分享一个滑动窗口的模板，能解决大多数的滑动窗口问题（[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)，[424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)）：

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```

滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

模板的整体思想是：

定义两个指针 left 和 right 分别指向区间的开头和结尾，注意是闭区间；定义 sums 用来统计该区间内的各个字符出现次数；
第一重 while 循环是为了判断 right 指针的位置是否超出了数组边界；当 right 每次到了新位置，需要增加 right 指针的求和/计数；
第二重 while 循环是让 left 指针向右移动到 [left, right] 区间符合题意的位置；当 left 每次移动到了新位置，需要减少 left 指针的求和/计数；
在第二重 while 循环之后，成功找到了一个符合题意的 [left, right] 区间，题目要求最大的区间长度，因此更新 res 为 max(res, 当前区间的长度) 。
right 指针每次向右移动一步，开始探索新的区间。
模板中的 sums 需要根据题目意思具体去修改，本题是求和题目因此把sums 定义成整数用于求和；如果是计数题目，就需要改成字典用于计数。当左右指针发生变化的时候，都需要更新 sums 。

另外一个需要根据题目去修改的是内层 while 循环的判断条件，即： 区间[left, right]不符合题意 。对于本题而言，就是该区内的和 sums 超过了 maxCost 。

+++



作者：负雪明烛
链接：https://leetcode.cn/problems/get-equal-substrings-within-budget/solutions/592354/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/
:::





### [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

给你一个字符串 `s` 和一个整数 `k` 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 `k` 次。

在执行上述操作后，返回 *包含相同字母的最长子字符串的长度。*

+++info 示例

**示例 1：**

```
输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
```

**示例 2：**

```
输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。
可能存在其他的方法来得到同样的结果。
```

+++

:::info no-icon

本题解根据常规的滑动窗口思路进行解题，不需要任何的技巧。
滑动窗口法是指通过Left以及Right指针来框定一个窗口，当在窗口内的字符串满足题目要求则记录下当前窗口长度并进一步扩张寻找更长的窗口，若不满足则进行窗口平移。
题目中给定的K值是让我们在选定有效窗口时的要求放宽了：

当K=0时，要求滑动窗口内部的所有字母都必须相同；
而当K>0时，要求滑动窗口内最多替换K次使得所有字母都必须相同。这里有一个关键点，即我们将当前滑动窗口内出现次数最多的字母作为基准字母（Benchmark），那么其他不一样的字母(Others)都选择替换操作即可以最小的代价转换为全部相同的字母。
因此，我们首先通过一个数组(count)记录所有字母在当前窗口出现的次数，通过Max函数选择窗口内的基准字母，然后其他字母出现的次数为Sum(count)-Max(count)，通过与K进行比较，即可知道当前窗口是否有效，下一步是继续扩张还是位移。

作者：Derrick.S
链接：https://leetcode.cn/problems/longest-repeating-character-replacement/solutions/799013/hua-dong-chuang-kou-fa-jian-dan-yi-dong-3qwel/

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = [0 for _ in range(26)]  #记录当前窗口的字母出现次数
        
        left = 0    #滑动窗口左边界
        right = 0   #滑动窗口右边界
        retval = 0  #最长窗口长度
        
        while right < len(s):
            count[ord(s[right])-ord('A')] += 1  
            benchmark = max(count)              #选择出现次数最多的字母为基准 
            others = sum(count) - benchmark     #则其他字母需要通过替换操作来变为基准
            if others <= k:                     #通过与K进行比较来判断窗口是进行扩张？
                right += 1
                retval = max(retval, right-left)#记录当前有效窗口长度
            else:                               #通过与K进行比较来判断窗口还是进行位移？
                count[ord(s[left])-ord('A')] -= 1
                left += 1
                right += 1                      #这里注意：位移操作需要整个向右移，不仅仅只是left向右
        
        return retval                           #返回最长窗口长度
        
```

:::

## 前缀和

### [724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

+++info 示例

**示例 1：**

```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
```

**示例 2：**

```
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```

**示例 3：**

```
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
```

+++

:::info no-icon

设 nums 的元素之和为 s。

设中心下标为 i，其左侧元素和为 $leftS=nums[0]+nums[1]+⋯+nums[i−1]$，那么右侧元素和为 $s−nums[i]−leftS$。

由于左侧元素和等于右侧元素和，所以有

$$leftS=s−nums[i]−leftS$$
即

$$2⋅leftS=s−nums[i]$$
从左到右遍历数组，一边遍历，一边累加元素更新 leftS。每次累加前，检查是否满足上式，满足则返回 i。

如果不存在这样的 i，返回 −1。

作者：灵茶山艾府
链接：https://leetcode.cn/problems/find-pivot-index/solutions/2834687/jian-ji-xie-fa-o1-e-wai-kong-jian-python-tz0p/

```python
class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        s = sum(nums)
        sum_left = 0
        for i, num in enumerate(nums):
            if 2*sum_left == s - num:
                return i
            sum_left += num
        return -1
```

:::

### [2352. 相等行列对](https://leetcode.cn/problems/equal-row-and-column-pairs/)

给你一个下标从 **0** 开始、大小为 `n x n` 的整数矩阵 `grid` ，返回满足 `Ri` 行和 `Cj` 列相等的行列对 `(Ri, Cj)` 的数目*。*

如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。

::: info no-icon

用哈希表统计每行出现的次数，然后遍历列，累加哈希表中列出现的次数。



作者：灵茶山艾府
链接：https://leetcode.cn/problems/equal-row-and-column-pairs/solutions/1694047/ha-xi-biao-python-liang-xing-by-endlessc-ljae/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

;;;id2 Demo 1

```python
class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        cnt = Counter(tuple(row) for row in grid)
        return sum(cnt[col] for col in zip(*grid))

```

;;;

;;;id2 Demo2

```python
class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        n = len(grid)
        count = {}
        result = 0
        for i in range(n):
            count[tuple(grid[i])] = count.get(tuple(grid[i]), 0) + 1
        print(count)
        for j in zip(*grid):
            print(j)
            result += count.get(j,0)
            # print(grid[:][j], grid[j][:])
        return result
```

;;;

:::

## 栈与队列

### [735. 小行星碰撞](https://leetcode.cn/problems/asteroid-collision/)

给定一个整数数组 `asteroids`，表示在同一行的小行星。数组中小行星的索引表示它们在空间中的相对位置。

对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。

找出碰撞后剩下的所有小行星。碰撞规则：两个小行星相互碰撞，较小的小行星会爆炸。如果两颗小行星大小相同，则两颗小行星都会爆炸。两颗移动方向相同的小行星，永远不会发生碰撞。

+++info 示例

**示例 1：**

```
输入：asteroids = [5,10,-5]
输出：[5,10]
解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。
```

**示例 2：**

```
输入：asteroids = [8,-8]
输出：[]
解释：8 和 -8 碰撞后，两者都发生爆炸。
```

**示例 3：**

```
输入：asteroids = [10,2,-5]
输出：[10]
解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。
```

+++

:::info no-icon

这道栈的题目难点应该主要是在分析场景上了。
我们需要明确什么时候无脑入栈，什么时候需要判断，理解这两点就可以轻松解题了。
首先，循环每一个元素时，在什么情况下无脑入栈呢？

栈为空
栈顶元素为负数(下一个为负数则一起向左，下一个为正数则分向两边)
当前元素为正数（栈顶为正一起向右，栈顶为负分向两边）
下来，我们需要看碰撞的场景又细分为什么情况：

栈顶元素大于abs(当前元素)，当前元素被撞毁
栈顶元素等于abs(当前元素)，栈顶弹出和当前元素抵消
栈顶元素小于abs(当前元素)，栈顶弹出，并与新栈顶完成上述判断
最终返回栈即可。

作者：清风Python
链接：https://leetcode.cn/problems/asteroid-collision/solutions/994100/735xing-xing-peng-zhuang-ji-yu-zhan-qu-f-xpd1/

```python
class Solution:
    def asteroidCollision(self, asteroids: List[int]) -> List[int]:
        stack, index = [], 0
        while index < len(asteroids):
            ast = asteroids[index]
            if ast > 0 or len(stack)==0 or stack[-1]<0: stack.append(ast)
            elif stack[-1] <= - ast:
                if stack.pop(-1) < - ast:
                    continue
            index += 1
        return stack
```

:::

### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

测试用例保证输出的长度不会超过 `105`。

+++info 示例

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**示例 4：**

```
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

+++

:::info no-icon

+ 本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。

+ 算法流程：

  + 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；

    + 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；

    + 当 c 为字母时，在 res 尾部添加 c；

    + 当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：
      记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；
      记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。
      进入到新 [ 后，res 和 multi 重新记录。

    + 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:
      + last_res是上个 [ 到当前 [ 的字符串，例如 "3[a2[c]]" 中的 a；
      + cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 "3[a2[c]]" 中的 2。

  + 返回字符串 res。

作者：Krahets
链接：https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/

```python
class Solution:
    def decodeString(self, s: str) -> str:
        result = ''
        stack = []
        res, num = '', 0
        for c in s:
            if c == '[':
                stack.append((res, num))
                res, num = '', 0
            elif c == ']':
                out_res, out_num = stack.pop()
                res = out_res + out_num*res
            elif '0'<= c <= '9':
                num = num*10 + int(c)
            else:
                res += c
        return res
```

:::

### [649. Dota2 参议院](https://leetcode.cn/problems/dota2-senate/)

Dota2 的世界里有两个阵营：`Radiant`（天辉）和 `Dire`（夜魇）

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 **一** 项：

- **禁止一名参议员的权利**：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 **所有的权利** 。
- **宣布胜利**：如果参议员发现有权利投票的参议员都是 **同一个阵营的** ，他可以宣布胜利并决定在游戏中的有关变化。

给你一个字符串 `senate` 代表每个参议员的阵营。字母 `'R'` 和 `'D'`分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `"Radiant"` 或 `"Dire"` 。

+++info 示例

**示例 1：**

```
输入：senate = "RD"
输出："Radiant"
解释：
第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。
这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。
第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。
```

**示例 2：**

```
输入：senate = "RDD"
输出："Dire"
解释：
第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。
这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。
这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
```

+++

:::info no-icon

这道题模拟了一个游戏过程，最终当有权利投票的参议员都是 同一个阵营的 ，这个阵营即获胜。

那么两个阵营的每个参议员为了获胜，当他拥有权力的时候，一定是会将自己之后首个对立阵营的参议员的权力禁止掉。【这就是每一位参议会为自己的政党做出最好的策略】。请注意：当之后没有对立阵营的参议员的时候，相当于将之前的参议员加到其之后。

![500](2025-08-15-Leetcode/649-01.png)

![500](2025-08-15-Leetcode/649-02.png)

![500](2025-08-15-Leetcode/649-03.png)

![500](2025-08-15-Leetcode/649-04.png)

![500](2025-08-15-Leetcode/649-05.png)

```python
class Solution:
    def predictPartyVictory(self, senate: str) -> str:
        radiants, dires = [], []
        n = len(senate)
        for i, se in enumerate(senate):
            if se == 'R': radiants.append(i)
            else: dires.append(i)
        while radiants and dires:
            if radiants[0] < dires[0]:
                dires.pop(0)
                radiants.append(radiants.pop(0) + n)
            else:
                radiants.pop(0)
                dires.append(dires.pop(0) + n)
        return "Radiant" if radiants else 'Dire'
        
```



作者：画图小匠
链接：https://leetcode.cn/problems/dota2-senate/solutions/2862115/javapython3cdui-lie-mo-ni-jin-zhi-zhi-ho-l4pb/

:::

## 链表

:::info no-icon

1. 找中间节点：快慢指针

+ 中间值左侧：需要加一个dummy节点。

  ```python
  dummy = ListNode(0, head)
  slow, fast = dummy, dummy
  while fast and fast.next:
      fast = fast.next.next
      if not fast: break
      slow = slow.next
  ```

+ 中间值右侧：直接从head开始

  ```python
  slow, fast = head, head
  while fast and fast.next:
      fast = fast.next.next
      if not fast: break
      slow = slow.next
  ```

  

:::

### [2095. 删除链表的中间节点](https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/)

给你一个链表的头节点 `head` 。**删除** 链表的 **中间节点** ，并返回修改后的链表的头节点 `head` 。

长度为 `n` 链表的中间节点是从头数起第 `⌊n / 2⌋` 个节点（下标从 **0** 开始），其中 `⌊x⌋` 表示小于或等于 `x` 的最大整数。

- 对于 `n` = `1`、`2`、`3`、`4` 和 `5` 的情况，中间节点的下标分别是 `0`、`1`、`1`、`2` 和 `2` 。

 :::info no-icon

本题可遍历计数先得到 n，再遍历一次删除指定节点即可，这很简单。本篇讲的是快慢指针这种方法。

我们令 fast 和 slow 这两个指针同时前进，fast 每次移动两格，slow 每次移动一格，在检测到 `fast.next == null` 或者 `fast.next.next == null` 时退出循环。

引入一个哑巴节点 dummy 便于处理，考虑循环停止时的场景。
为方便考虑，本篇题解认为原链表下标从 1 开始，需要删除第 $⌊\frac{n}{2}⌋+1$ 个节点。

+ 如果 *n* 为偶数，如下所示。设 *n*=2*k*，fast 停在第 2*k* 个节点，slow 停在第 *k* 即 $⌊\frac{n}{2}⌋$ 个节点。

![300](2025-08-15-Leetcode/2095-01.png)

+ 如果 *n* 为奇数，如下所示，设 *n*=2*k*+1。fast 停在第 2*k* 个节点，slow 停在第 *k* 即 $⌊\frac{n}{2}⌋$ 个节点。

![300](2025-08-15-Leetcode/2095-02.png)

所以退出循环时 slow 一定停在 $⌊\frac{n}{2}⌋$ 个节点，令 `slow.next = slow.next.next` 即删除了 $⌊\frac{n}{2}⌋+1$ 个节点。



作者：Shawxing精讲算法
链接：https://leetcode.cn/problems/delete-the-middle-node-of-a-linked-list/solutions/2844229/jian-ming-yan-jin-de-kuai-man-zhi-zhen-f-84sx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        zero = ListNode(0, head)
        slow, fast = zero, zero
        while fast and fast.next:
            fast = fast.next.next
            if not fast: break
            slow = slow.next
        slow.next = slow.next.next
        return zero.next

        
```

:::

### [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)

给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。

**第一个**节点的索引被认为是 **奇数** ， **第二个**节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

:::info no-icon

如果链表为空，则直接返回链表。

对于原始链表，每个节点都是奇数节点或偶数节点。头节点是奇数节点，头节点的后一个节点是偶数节点，相邻节点的奇偶性不同。因此可以将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。

原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 evenHead = head.next，则 evenHead 是偶数链表的头节点。

维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 odd = head，even = evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点。

+ 更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 odd.next = even.next，然后令 odd = odd.next，此时 odd 变成 even 的后一个节点。

+ 更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 even.next = odd.next，然后令 even = even.next，此时 even 变成 odd 的后一个节点。

![400](2025-08-15-Leetcode/328-01.png)

![400](2025-08-15-Leetcode/328-02.png)

![400](2025-08-15-Leetcode/328-03.png)

![400](2025-08-15-Leetcode/328-04.png)

在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 even.next 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）。

最后令 odd.next = evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head。

作者：力扣官方题解
链接：https://leetcode.cn/problems/odd-even-linked-list/solutions/482737/qi-ou-lian-biao-by-leetcode-solution/

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head: return head
        even_head = head.next
        odd, even = head, even_head
        while even and even.next:
            odd.next = even.next
            odd = odd.next
            even.next = odd.next
            even = even.next
        odd.next = even_head
        return head
```

:::

### [2130. 链表最大孪生和](https://leetcode.cn/problems/maximum-twin-sum-of-a-linked-list/)

在一个大小为 `n` 且 `n` 为 **偶数** 的链表中，对于 `0 <= i <= (n / 2) - 1` 的 `i` ，第 `i` 个节点（下标从 **0** 开始）的孪生节点为第 `(n-1-i)` 个节点 。

- 比方说，`n = 4` 那么节点 `0` 是节点 `3` 的孪生节点，节点 `1` 是节点 `2` 的孪生节点。这是长度为 `n = 4` 的链表中所有的孪生节点。

**孪生和** 定义为一个节点和它孪生节点两者值之和。

给你一个长度为偶数的链表的头节点 `head` ，请你返回链表的 **最大孪生和** 。

 +++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/2130-01.png)

```
输入：head = [5,4,2,1]
输出：6
解释：
节点 0 和节点 1 分别是节点 3 和 2 的孪生节点。孪生和都为 6 。
链表中没有其他孪生节点。
所以，链表的最大孪生和是 6 。
```

**示例 2：**

![300](2025-08-15-Leetcode/2130-02.png)

```
输入：head = [4,2,2,3]
输出：7
解释：
链表中的孪生节点为：
- 节点 0 是节点 3 的孪生节点，孪生和为 4 + 3 = 7 。
- 节点 1 是节点 2 的孪生节点，孪生和为 2 + 2 = 4 。
所以，最大孪生和为 max(7, 4) = 7 。
```

+++

:::info no-icon

**核心思想：寻找链表中间值**

以下两种方法的快慢指针有所不同，参见[链表](#链表)。

;;;id3 快慢指针+反转链表

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        mid = self.middleNode(head)
        head2 = self.reverseNode(mid)
        result = -inf
        while head2:
            result = max(result, head.val + head2.val)
            head = head.next
            head2 = head2.next
        return result

    def reverseNode(self, head):
        cur, pre = head, None
        while cur:
            nxt = cur.next
            cur.next = pre
            pre = cur
            cur = nxt
        return pre
        
    def middleNode(self, head):
        slow = fast = head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
        return slow
        
```

;;;

;;;id3 快慢指针+入栈

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def pairSum(self, head: Optional[ListNode]) -> int:
        dummy = ListNode(next=head)
        slow, fast = dummy, dummy
        stack = []
        result = -inf
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            stack.append(slow.val)
        print(slow.val)
        while slow.next:
            slow = slow.next
            result = max(result, stack.pop(-1)+slow.val)
        return result
        
```

;;;

:::

## 二叉树

:::info no-icon

1. [看到递归就晕？带你理解递归的本质！【基础算法精讲 09】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1UD4y1Y769/?vd_source=9b05037c77ec940dae3af8e69969e0d6)



:::



### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)（与[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)方法相似）

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

+++info 示例

**示例 1：**

![300](2025-08-15-Leetcode/437-01.png)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

+++

:::info no-icon

如果二叉树是一条链，本题就和 560. 和为 K 的子数组 完全一样了：统计有多少个非空连续子数组的元素和恰好等于 targetSum。所以你必须先弄明白 560 题（特殊情况），再来做本题（一般情况）。560 题的做法见 我的题解。

这两题的联系如下：

| 560 题                                     | 本题                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| 连续子数组                                 | 方向向下的路径                                               |
| 前缀                                       | 从根节点开始的路径                                           |
| 做法：枚举子数组右端点，统计有多少个左端点 | 做法：枚举路径的终点，统计有多少个起点<br/>我们要解决的问题是：DFS 遍历这棵树，遍历到节点 node 时，假设 node 是路径的终点，那么有多少个起点，满足起点到终点 node 的路径总和恰好等于 targetSum？ |

和 560 题一样的套路：一边遍历二叉树，一边用哈希表 cnt 统计前缀和（从根节点开始的路径和）的出现次数。设从根到终点 node 的路径和为 s，那么起点的个数就是 cnt[s−targetSum]，加入答案。对比 560 题，我们在枚举子数组的右端点（终点），统计有多少个左端点（起点），做法完全一致。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        ans = 0
        hp = collections.defaultdict(int)
        hp[0] = 1
        def dfs(node, s):
            if not node: return 
            nonlocal ans
            s += node.val
            ans += hp[s - targetSum]

            hp[s] += 1
            dfs(node.left, s)
            dfs(node.right, s)
            hp[s] -= 1
        dfs(root, 0)
        return ans
```

作者：灵茶山艾府
链接：https://leetcode.cn/problems/path-sum-iii/solutions/2784856/zuo-fa-he-560-ti-shi-yi-yang-de-pythonja-fmzo/

:::

### [1372. 二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)

给你一棵以 `root` 为根的二叉树，二叉树中的交错路径定义如下：

- 选择二叉树中 **任意** 节点和一个方向（左或者右）。
- 如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。
- 改变前进方向：左变右或者右变左。
- 重复第二步和第三步，直到你在树中无法继续移动。

交错路径的长度定义为：**访问过的节点数目 - 1**（单个节点的路径长度为 0 ）。

请你返回给定树中最长 **交错路径** 的长度。

+++info 示例

**示例 1：**

![100](2025-08-15-Leetcode/1372-01.png)

```
输入：root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1,null,1]
输出：3
解释：蓝色节点为树中最长交错路径（右 -> 左 -> 右）。
```

**示例 2：**

![100](2025-08-15-Leetcode/1372-02.png)

```
输入：root = [1,1,1,null,1,null,null,1,1,null,1]
输出：4
解释：蓝色节点为树中最长交错路径（左 -> 右 -> 左 -> 右）。
```

+++

:::info no-icon

在 DFS 的过程中，每次我们都把当前点的 len 参数和答案 maxAns 打擂台，这样可以比出一个最大的。然后我们根据 dir 分类讨论。如果当前点应该向左且可以向左，那么就让他向左走一步，新的 len 是当前的 len 加一。如果的的点应该向左但是却没有左子树呢？很无奈那就只能向右了，这个时候 len 的值应该「重置」。

思考：「重置」为什么是把 len 变成 1 而不是 0？ 因为当前的点下传到它的子节点的时候已经走了一条长度为 1 的边。那么为什么 main 函数中传入的 len 值是 0 而不是 1 呢？ 因为 main 函数中的 root 是没有父亲节点的，所以当前已经走过的路为 0。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def longestZigZag(self, root: Optional[TreeNode]) -> int:
        result = 0
        def search(node, mode, l):
            if not node:return 
            nonlocal result
            result = max(result, l)
            if mode == 'left': 
                search(node.right, 'right',l+1)
                search(node.left, 'left', 1)
            elif mode == 'right': 
                search(node.left, 'left', l+1)
                search(node.right, 'right', 1)
        search(root,'left', 0)
        search(root, 'right', 0)
        return result
```

作者：力扣官方题解
链接：https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/solutions/147425/er-cha-shu-zhong-de-zui-chang-jiao-cuo-lu-jing-b-2/

:::

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 +++info 示例

**示例 1：**

![200](2025-08-15-Leetcode/236-01.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![200](2025-08-15-Leetcode/236-02.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

+++

:::info no-icon

[二叉树的最近公共祖先【基础算法精讲 12】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1W44y1Z7AR/?vd_source=9b05037c77ec940dae3af8e69969e0d6)

![500](2025-08-15-Leetcode/236-03.png)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root == None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        if right and left: return root
        return left or right
        
```

:::

### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

+++info 示例

**示例 1：**

**输入：** root = [1,2,3,null,5,null,4]

**输出：**[1,3,4]

**解释：**

![300](2025-08-15-Leetcode/199-01.png)

**示例 2：**

**输入：**root = [1,2,3,4,null,null,null,5]

**输出：**[1,3,4,5]

**解释：**

![300](2025-08-15-Leetcode/199-02.png)

**示例 3：**

**输入：**root = [1,null,3]

**输出：**[1,3]

+++

:::info no-icon

;;;id4 深度优先算法

**视频讲解**：[【基础算法精讲 10】](https://www.bilibili.com/video/BV18M411z7bb/)

**思路**：先递归右子树，再递归左子树，当某个深度首次到达时，对应的节点就在右视图中。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        result = []
        def dfs(root, depth):
            if not root: return 
            if depth == len(result):
                result.append(root.val)
            dfs(root.right, depth + 1)
            dfs(root.left, depth + 1)
        dfs(root, 0)
        return result
```

作者：灵茶山艾府
链接：https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/

;;;

;;;id4 层序遍历

**思路**：将每层的元素加入队列，从右到左依序遍历每层。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root: return []
        result = []
        que = [root]
        while len(que) > 0:
            result.append(que[0].val)
            for _ in range(len(que)):
                node = que.pop(0)
                if node.right: que.append(node.right)
                if node.left: que.append(node.left)
        return result
```

:::













































