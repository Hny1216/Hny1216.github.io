---
title: Leetcode刷题记录
math: true
fancybox: true
date: 2025-08-15
categories:
- 技能工具
---

Leetcode刷题记录

<!-- more -->

# Leetcode刷题

## 数组/字符串

### [1071. 字符串的最大公因子](https://leetcode.cn/problems/greatest-common-divisor-of-strings/)

对于字符串 `s` 和 `t`，只有在 `s = t + t + t + ... + t + t`（`t` 自身连接 1 次或多次）时，我们才认定 “`t` 能除尽 `s`”。

给定两个字符串 `str1` 和 `str2` 。返回 *最长字符串 `x`，要求满足 `x` 能除尽 `str1` 且 `x` 能除尽 `str2`* 。

:::info no-icon

若两个字符串是由同一个字符串 X重复拼接而成，那么无论先拼哪个，结果应该相同。
如果 str1 + str2 != str2 +str1，说明不存在公共的重复因子，直接返回空串 ""。
如果两个字符串都是由同一个字符串 X 组成，那么 X 的长度必然是str1.size()和 str2.size() 的最大公约数。

作者：Random
链接：https://leetcode.cn/problems/greatest-common-divisor-of-strings/solutions/3749891/shu-xue-zui-da-gong-yue-shu-by-coder-ran-a88u/

:::

```python
class Solution:
    def gcdOfStrings(self, str1: str, str2: str) -> str:
        if not str1 + str2 == str2 + str1:
            return ""
        return str1[0:self.gcd(len(str1), len(str2))]
    
    def gcd(self, a,b):
        if b == 0: return a
        else: return gcd(b, a%b)
    
```



### [605. 种花问题](https://leetcode.cn/problems/can-place-flowers/)

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 `flowerbed` 表示花坛，由若干 `0` 和 `1` 组成，其中 `0` 表示没种植花，`1` 表示种植了花。另有一个数 `n` ，能否在不打破种植规则的情况下种入 `n` 朵花？能则返回 `true` ，不能则返回 `false` 。

:::info no-icon

从左到右遍历数组，能种花就立刻种花。

如何判断能否种花？由于「花不能种植在相邻的地块上」，如果要在下标 i 处种花，需要满足 flowerbed[i−1],flowerbed[i],flowerbed[i+1] 均为 0。

每种一朵花，就把 n 减一。如果最后 n≤0，则返回 true，否则返回 false。

为了简化判断逻辑，可以在数组的开头和末尾各插入一个 0。

作者：灵茶山艾府
链接：https://leetcode.cn/problems/can-place-flowers/solutions/2463018/ben-ti-zui-jian-dan-xie-fa-pythonjavacgo-6a6k/

:::

```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
      nums = len(flowerbed)
      new_flowerbed = [0] + flowerbed + [0]
      for i in range(1,len(new_flowerbed)-1):
        if new_flowerbed[i-1] == 0 and new_flowerbed[i+1] == 0 and new_flowerbed[i] == 0:
          new_flowerbed[i] = 1
          n -= 1
      return n <= 0

```



### [334. 递增的三元子序列](https://leetcode.cn/problems/increasing-triplet-subsequence/)

给你一个整数数组 `nums` ，判断这个数组中是否存在长度为 `3` 的递增子序列。

如果存在这样的三元组下标 `(i, j, k)` 且满足 `i < j < k` ，使得 `nums[i] < nums[j] < nums[k]` ，返回 `true` ；否则，返回 `false` 。

:::info no-icon

核心想法：遍历一遍数组，希望遍历到的这个数three，前面已经有一个比他小的数two，再前面有一个比two小的数one。
我们需要维护两个变量：one和two。代表递增子序列的第一个数和第二个数。
假设我们已经有了这两个数，那么three的大小有以下三种情况：

1. **three大于two**    此情况下：即找到了三元组，直接返回true。

   ![](https://s1.imagehub.cc/images/2023/11/16/b60b630ac478d2911b6c682866cf5d09.jpeg "芙宁娜200*300"){width=300 height=200}

   ![](2025-08-15-Leetcode/334-01.png){height="200px" width="300px"}

2. **three介于two和one之间**     此情况下：应更新two，赋值为这个更小的值。这相当于帮我们扩大了three的可选择范围，当再次遇到一个比更新过的two大的数即可找到。



3. **three小于one**     此情况下：应更新one，赋值为这个更小的值。而不需要动two。这相当于帮我们扩大了之后出现的two的可选择范围。进而扩大了之后出现的three的可选择范围。





需要注意的是，我们只更新one，原先的two不需要更改，因为子序列是从前往后的，只有当之后再出现比two小的数的时候再按照第二步那样更改。

假设有如下示例：[2,5,1,6]，在遇到1之后更新了one，后遇到6，因为先判断是否大于two，由于6大于5，就直接返回true了。



注意：two附带隐含信息——这之前有个数比two小
所以此时找到的递增子序列不是one、two、three的1 5 6，而是old one、two、three的2 5 6。

这里更新的one的意思是，为之后可能存在的更小的递增子序列打基础。
假设有如下示例：[2,5,1,2,6]，在遇到1之后更新了one，后遇到2，2介于1和5（two）之间，更新two为2，后遇到6，由于6大于2，返回true。
此时找到的递增子序列才是one、two、three的1 2 6

最后考虑one、two的初值，容易想到设定为Integer.MAX_VALUE即可。

作者：Xzz
链接：https://leetcode.cn/problems/increasing-triplet-subsequence/solutions/535725/pou-xi-ben-zhi-yi-wen-bang-ni-kan-qing-t-3ye2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

:::























